{"version":3,"file":"models.js","sourceRoot":"","sources":["../../../src/models.ts"],"names":[],"mappings":"AA69BA,iFAAiF;AACjF;;;;GAIG;AACH,MAAM,CAAN,IAAY,uBAGX;AAHD,WAAY,uBAAuB;IACjC,gEAAqC,CAAA;IACrC,kDAAuB,CAAA;AACzB,CAAC,EAHW,uBAAuB,KAAvB,uBAAuB,QAGlC;AACD;;;;GAIG;AACH,MAAM,CAAN,IAAY,cAGX;AAHD,WAAY,cAAc;IACxB,mCAAiB,CAAA;IACjB,iCAAe,CAAA;AACjB,CAAC,EAHW,cAAc,KAAd,cAAc,QAGzB;AACD;;;;GAIG;AACH,MAAM,CAAN,IAAY,gBAGX;AAHD,WAAY,gBAAgB;IAC1B,2CAAuB,CAAA;IACvB,iCAAa,CAAA;AACf,CAAC,EAHW,gBAAgB,KAAhB,gBAAgB,QAG3B;AA4XD,8DAA8D;AAC9D,6DAA6D;AAC7D,8DAA8D","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { HttpResponse, TransferProgressEvent } from \"@azure/core-http\";\n\nimport {\n  LeaseAccessConditions,\n  ModifiedAccessConditions as ModifiedAccessConditionsModel,\n  UserDelegationKeyModel,\n  BlobQueryArrowConfiguration,\n  ServiceRenameContainerOptions,\n  ContainerRenameResponse,\n  ContainerUndeleteResponse\n} from \"@azure/storage-blob\";\nimport { DataLakePathClient } from \"./clients\";\nexport type ModifiedAccessConditions = Omit<ModifiedAccessConditionsModel, \"ifTags\">;\n\n/**\n * Options to query file with Apache Arrow format. Only valid for {@link FileQueryOptions.outputTextConfiguration}.\n */\nexport type FileQueryArrowConfiguration = BlobQueryArrowConfiguration;\n\n/**\n * Options to configure {@link DataLakeServiceClient.renameFileSystem}.\n */\nexport type ServiceRenameFileSystemOptions = ServiceRenameContainerOptions;\n\n/**\n * Contains response data for the {@link DataLakeServiceClient.renameFileSystem} operation.\n */\nexport type FileSystemRenameResponse = ContainerRenameResponse;\n\n/**\n * Contains response data for the {@link DataLakeServiceClient.undeleteFileSystem} operation.\n */\nexport type FileSystemUndeleteResponse = ContainerUndeleteResponse;\n\nimport {\n  FileSystemListBlobHierarchySegmentHeaders,\n  FileSystemListPathsHeaders,\n  ListBlobsHierarchySegmentResponse,\n  PathCreateResponse,\n  PathDeleteResponse,\n  PathGetPropertiesHeaders as PathGetPropertiesHeadersModel,\n  PathList as PathListModel,\n  PathUndeleteHeaders\n} from \"./generated/src/models\";\nimport { DataLakeSASPermissions } from \"./sas/DataLakeSASPermissions\";\nimport { DirectorySASPermissions } from \"./sas/DirectorySASPermissions\";\nimport { FileSystemSASPermissions } from \"./sas/FileSystemSASPermissions\";\nimport { SasIPRange } from \"./sas/SasIPRange\";\nimport { SASProtocol } from \"./sas/SASQueryParameters\";\nimport { CommonOptions } from \"./StorageClient\";\n\nexport {\n  LeaseAccessConditions,\n  UserDelegationKeyModel,\n  ServiceListContainersSegmentResponse,\n  Lease,\n  LeaseOperationOptions,\n  LeaseOperationResponse\n} from \"@azure/storage-blob\";\n\nexport {\n  BlobHierarchyListSegment,\n  BlobItemModel,\n  BlobPrefix,\n  BlobPropertiesModel,\n  FileSystemListPathsHeaders,\n  FileSystemListBlobHierarchySegmentHeaders,\n  FileSystemListPathsResponse as ListPathsSegmentResponse,\n  ListBlobsHierarchySegmentResponse,\n  Path as PathModel,\n  PathList as PathListModel,\n  PathCreateHeaders,\n  PathDeleteHeaders,\n  PathDeleteResponse,\n  PathGetPropertiesHeaders as PathGetPropertiesHeadersModel,\n  PathSetAccessControlHeaders,\n  PathSetAccessControlResponse,\n  PathSetAccessControlResponse as PathSetPermissionsResponse,\n  PathResourceType as PathResourceTypeModel,\n  PathUndeleteHeaders,\n  PathUpdateHeaders,\n  PathAppendDataHeaders,\n  PathFlushDataHeaders,\n  PathAppendDataResponse as FileAppendResponse,\n  PathFlushDataResponse as FileFlushResponse,\n  PathFlushDataResponse as FileUploadResponse,\n  PathGetPropertiesAction as PathGetPropertiesActionModel,\n  PathRenameMode as PathRenameModeModel,\n  PathExpiryOptions as FileExpiryMode,\n  PathSetExpiryResponse as FileSetExpiryResponse,\n  PathSetExpiryHeaders as FileSetExpiryHeaders\n} from \"./generated/src/models\";\n\nexport { PathCreateResponse };\n\n/**\n * Common options of the {@link FileSystemGenerateSasUrlOptions}, {@link DirectoryGenerateSasUrlOptions}\n * and {@link FileGenerateSasUrlOptions}.\n */\nexport interface CommonGenerateSasUrlOptions {\n  /**\n   * The version of the service this SAS will target. If not specified, it will default to the version targeted by the\n   * library.\n   */\n  version?: string;\n\n  /**\n   * Optional. SAS protocols, HTTPS only or HTTPSandHTTP\n   */\n  protocol?: SASProtocol;\n\n  /**\n   * Optional. When the SAS will take effect.\n   */\n  startsOn?: Date;\n\n  /**\n   * Optional only when identifier is provided. The time after which the SAS will no longer work.\n   */\n  expiresOn?: Date;\n\n  /**\n   * Optional. IP ranges allowed in this SAS.\n   */\n  ipRange?: SasIPRange;\n\n  /**\n   * Optional. The name of the access policy on the container this SAS references if any.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/establishing-a-stored-access-policy\n   */\n  identifier?: string;\n\n  /**\n   * Optional. The cache-control header for the SAS.\n   */\n  cacheControl?: string;\n\n  /**\n   * Optional. The content-disposition header for the SAS.\n   */\n  contentDisposition?: string;\n\n  /**\n   * Optional. The content-encoding header for the SAS.\n   */\n  contentEncoding?: string;\n\n  /**\n   * Optional. The content-language header for the SAS.\n   */\n  contentLanguage?: string;\n\n  /**\n   * Optional. The content-type header for the SAS.\n   */\n  contentType?: string;\n}\n\n/** ***********************************************************/\n/** DataLakeServiceClient option and response related models */\n/** ***********************************************************/\n\nexport interface ServiceGetUserDelegationKeyOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n}\n\n// TODO: Leverage interface definitions from blob package directly, or duplicate create a copy here which will not have generation benefits\nexport interface ServiceGetUserDelegationKeyHeaders {\n  clientRequestId?: string;\n  requestId?: string;\n  version?: string;\n  date?: Date;\n}\n\nexport interface UserDelegationKey {\n  signedObjectId: string;\n  signedTenantId: string;\n  signedStartsOn: Date;\n  signedExpiresOn: Date;\n  signedService: string;\n  signedVersion: string;\n  value: string;\n}\n\nexport type ServiceGetUserDelegationKeyResponse = UserDelegationKey &\n  ServiceGetUserDelegationKeyHeaders & {\n    _response: HttpResponse & {\n      parsedHeaders: ServiceGetUserDelegationKeyHeaders;\n      bodyAsText: string;\n      parsedBody: UserDelegationKeyModel;\n    };\n  };\n\nexport interface ServiceListFileSystemsOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  prefix?: string;\n  includeMetadata?: boolean;\n\n  /**\n   * Specifies whether soft deleted File System should be included in the response.\n   */\n  includeDeleted?: boolean;\n}\n\nexport type LeaseStatusType = \"locked\" | \"unlocked\";\nexport type LeaseStateType = \"available\" | \"leased\" | \"expired\" | \"breaking\" | \"broken\";\nexport type LeaseDurationType = \"infinite\" | \"fixed\";\nexport type PublicAccessType = \"filesystem\" | \"file\";\n\nexport interface FileSystemProperties {\n  lastModified: Date;\n  etag: string;\n  leaseStatus?: LeaseStatusType;\n  leaseState?: LeaseStateType;\n  leaseDuration?: LeaseDurationType;\n  publicAccess?: PublicAccessType;\n  hasImmutabilityPolicy?: boolean;\n  hasLegalHold?: boolean;\n  deletedOn?: Date;\n  remainingRetentionDays?: number;\n}\n\nexport interface FileSystemItem {\n  name: string;\n  properties: FileSystemProperties;\n  metadata?: Metadata;\n  deleted?: boolean;\n  versionId?: string;\n}\n\nexport interface ListFileSystemsSegmentResponse {\n  serviceEndpoint: string;\n  prefix?: string;\n  marker?: string;\n  maxPageSize?: number;\n  fileSystemItems: FileSystemItem[];\n  continuationToken?: string;\n}\n\nexport interface ServiceListFileSystemsSegmentHeaders {\n  clientRequestId?: string;\n  requestId?: string;\n  version?: string;\n}\n\nexport type ServiceListFileSystemsSegmentResponse = ListFileSystemsSegmentResponse &\n  ServiceListFileSystemsSegmentHeaders & {\n    _response: HttpResponse & {\n      parsedHeaders: ServiceListFileSystemsSegmentHeaders;\n      bodyAsText: string;\n      parsedBody: ListFileSystemsSegmentResponse;\n    };\n  };\n\n/**\n * Options to configure {@link DataLakeServiceClient.generateAccountSasUrl} operation.\n */\nexport interface ServiceGenerateAccountSasUrlOptions {\n  /**\n   * The version of the service this SAS will target. If not specified, it will default to the version targeted by the\n   * library.\n   */\n  version?: string;\n\n  /**\n   * Optional. SAS protocols allowed.\n   */\n  protocol?: SASProtocol;\n\n  /**\n   * Optional. When the SAS will take effect.\n   */\n  startsOn?: Date;\n  /**\n   * Optional. IP range allowed.\n   */\n  ipRange?: SasIPRange;\n}\n\n/**\n * Options to configure {@link DataLakeServiceClient.undeleteFileSystem}.\n */\nexport interface ServiceUndeleteFileSystemOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Optional. Specifies the new name of the restored File System.\n   * Will use its original name if this is not specified.\n   * @deprecated Restore FileSystem to a different name is not supported by service anymore.\n   */\n  destinationFileSystemName?: string;\n}\n\n/** **************************************************************/\n/** DataLakeFileSystemClient option and response related models */\n/** **************************************************************/\n\nexport interface FileSystemCreateOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  metadata?: Metadata;\n  access?: PublicAccessType;\n}\n\nexport interface FileSystemCreateHeaders {\n  etag?: string;\n  lastModified?: Date;\n  clientRequestId?: string;\n  requestId?: string;\n  version?: string;\n  date?: Date;\n}\n\nexport type FileSystemCreateResponse = FileSystemCreateHeaders & {\n  _response: HttpResponse & {\n    parsedHeaders: FileSystemCreateHeaders;\n  };\n};\n\nexport interface FileSystemDeleteOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: DataLakeRequestConditions;\n}\n\nexport interface FileSystemDeleteHeaders {\n  clientRequestId?: string;\n  requestId?: string;\n  version?: string;\n  date?: Date;\n}\n\nexport type FileSystemDeleteResponse = FileSystemDeleteHeaders & {\n  _response: HttpResponse & {\n    parsedHeaders: FileSystemDeleteHeaders;\n  };\n};\n\nexport interface FileSystemGetPropertiesOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: LeaseAccessConditions;\n}\n\nexport interface FileSystemGetPropertiesHeaders {\n  metadata?: Metadata;\n  etag?: string;\n  lastModified?: Date;\n  leaseDuration?: LeaseDurationType;\n  leaseState?: LeaseStateType;\n  leaseStatus?: LeaseStatusType;\n  clientRequestId?: string;\n  requestId?: string;\n  version?: string;\n  date?: Date;\n  publicAccess?: PublicAccessType;\n  hasImmutabilityPolicy?: boolean;\n  hasLegalHold?: boolean;\n}\n\nexport type FileSystemGetPropertiesResponse = FileSystemGetPropertiesHeaders & {\n  _response: HttpResponse & {\n    parsedHeaders: FileSystemGetPropertiesHeaders;\n  };\n};\n\nexport interface FileSystemSetMetadataOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: DataLakeRequestConditions;\n}\n\nexport interface FileSystemSetMetadataHeaders {\n  etag?: string;\n  lastModified?: Date;\n  clientRequestId?: string;\n  requestId?: string;\n  version?: string;\n  date?: Date;\n}\n\nexport type FileSystemSetMetadataResponse = FileSystemSetMetadataHeaders & {\n  _response: HttpResponse & {\n    parsedHeaders: FileSystemSetMetadataHeaders;\n  };\n};\n\nexport interface FileSystemGetAccessPolicyOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: LeaseAccessConditions;\n}\n\nexport interface FileSystemGetAccessPolicyHeaders {\n  publicAccess?: PublicAccessType;\n  etag?: string;\n  lastModified?: Date;\n  clientRequestId?: string;\n  requestId?: string;\n  version?: string;\n  date?: Date;\n}\n\nexport interface RawAccessPolicy {\n  startsOn?: string;\n  expiresOn?: string;\n  permissions: string;\n}\n\nexport interface AccessPolicy {\n  startsOn?: Date;\n  expiresOn?: Date;\n  permissions: string;\n}\n\nexport interface SignedIdentifier<T> {\n  id: string;\n  accessPolicy: T;\n}\n\nexport type FileSystemGetAccessPolicyResponse = {\n  signedIdentifiers: SignedIdentifier<AccessPolicy>[];\n} & FileSystemGetAccessPolicyHeaders & {\n    _response: HttpResponse & {\n      parsedHeaders: FileSystemGetAccessPolicyHeaders;\n      bodyAsText: string;\n      parsedBody: SignedIdentifier<RawAccessPolicy>[];\n    };\n  };\n\nexport interface FileSystemSetAccessPolicyOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: DataLakeRequestConditions;\n}\n\nexport interface FileSystemSetAccessPolicyHeaders {\n  etag?: string;\n  lastModified?: Date;\n  clientRequestId?: string;\n  requestId?: string;\n  version?: string;\n  date?: Date;\n}\n\nexport type FileSystemSetAccessPolicyResponse = FileSystemSetAccessPolicyHeaders & {\n  _response: HttpResponse & {\n    parsedHeaders: FileSystemSetAccessPolicyHeaders;\n  };\n};\n\nexport interface ListPathsOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  recursive?: boolean;\n  path?: string;\n  userPrincipalName?: boolean;\n}\n\nexport interface ListPathsSegmentOptions extends ListPathsOptions {\n  maxResults?: number;\n}\n\nexport interface Path {\n  name?: string;\n  isDirectory?: boolean;\n  lastModified?: Date;\n  etag?: string;\n  contentLength?: number;\n  owner?: string;\n  group?: string;\n  permissions?: PathPermissions;\n}\n\nexport interface PathList {\n  pathItems?: Path[];\n}\n\nexport type FileSystemListPathsResponse = PathList &\n  FileSystemListPathsHeaders & {\n    _response: HttpResponse & {\n      parsedHeaders: FileSystemListPathsHeaders;\n      bodyAsText: string;\n      parsedBody: PathListModel;\n    };\n  };\n\nexport interface ListDeletedPathsOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  /** Filters results to filesystems within the specified prefix. */\n  prefix?: string;\n}\n\nexport interface ListDeletedPathsSegmentOptions extends ListDeletedPathsOptions {\n  maxResults?: number;\n}\n\nexport interface DeletedPath {\n  name: string;\n  deletionId?: string;\n  deletedOn?: Date;\n  remainingRetentionDays?: number;\n}\n\nexport interface DeletedPathList {\n  pathItems?: DeletedPath[];\n}\n\nexport type FileSystemListDeletedPathsResponse = DeletedPathList &\n  FileSystemListBlobHierarchySegmentHeaders &\n  ListBlobsHierarchySegmentResponse & {\n    _response: HttpResponse & {\n      /** The response body as text (string format) */\n      bodyAsText: string;\n\n      /** The response body as parsed JSON or XML */\n      parsedBody: ListBlobsHierarchySegmentResponse;\n      /** The parsed HTTP response headers. */\n      parsedHeaders: FileSystemListBlobHierarchySegmentHeaders;\n    };\n\n    continuation?: string;\n  };\n\nexport interface FileSystemUndeletePathOption extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n}\n\nexport type FileSystemUndeletePathResponse = PathUndeleteHeaders & {\n  _response: HttpResponse & {\n    parsedHeaders: PathUndeleteHeaders;\n  };\n  pathClient: DataLakePathClient;\n};\n\n/**\n * Option interface for Data Lake file system exists operations\n *\n * See:\n * - {@link DataLakeFileSystemClient.exists}\n */\nexport interface FileSystemExistsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Contains response data for the {@link DataLakeFileSystemClient.createIfNotExists} operation.\n */\nexport interface FileSystemCreateIfNotExistsResponse extends FileSystemCreateResponse {\n  /**\n   * Indicate whether the file system is successfully created. Is false when the file system is not changed as it already exists.\n   */\n  succeeded: boolean;\n}\n\n/**\n * Contains response data for the {@link DataLakeFileSystemClient.deleteIfExists} operation.\n */\nexport interface FileSystemDeleteIfExistsResponse extends FileSystemDeleteResponse {\n  /**\n   * Indicate whether the file system is successfully deleted. Is false if the file system doesn't exist in the first place.\n   */\n  succeeded: boolean;\n}\n\n/**\n * Options to configure {@link DataLakeFileSystemClient.generateSasUrl} operation.\n */\nexport interface FileSystemGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {\n  /**\n   * Optional only when identifier is provided. Specifies the list of permissions to be associated with the SAS.\n   */\n  permissions?: FileSystemSASPermissions;\n}\n\n/** ********************************************************/\n/** DataLakePathClient option and response related models */\n/** ********************************************************/\n\nexport interface Metadata {\n  [propertyName: string]: string;\n}\n\nexport interface DataLakeRequestConditions\n  extends ModifiedAccessConditions,\n    LeaseAccessConditions {}\n\nexport interface RolePermissions {\n  read: boolean;\n  write: boolean;\n  execute: boolean;\n}\n\nexport interface PathPermissions {\n  owner: RolePermissions;\n  group: RolePermissions;\n  other: RolePermissions;\n  stickyBit: boolean;\n  extendedAcls: boolean;\n}\n\nexport type AccessControlType = \"user\" | \"group\" | \"mask\" | \"other\";\n\nexport interface RemovePathAccessControlItem {\n  /**\n   * Indicates whether this is the default entry for the ACL.\n   */\n  defaultScope: boolean;\n  /**\n   * Specifies which role this entry targets.\n   */\n  accessControlType: AccessControlType;\n  /**\n   * Specifies the entity for which this entry applies.\n   * Must be omitted for types mask or other. It must also be omitted when the user or group is the owner.\n   */\n  entityId?: string;\n}\n\nexport interface PathAccessControlItem {\n  /**\n   * Indicates whether this is the default entry for the ACL.\n   */\n  defaultScope: boolean;\n  /**\n   * Specifies which role this entry targets.\n   */\n  accessControlType: AccessControlType;\n  /**\n   * Specifies the entity for which this entry applies.\n   */\n  entityId: string;\n  /**\n   * Access control permissions.\n   */\n  permissions: RolePermissions;\n}\n\nexport interface PathCreateHttpHeaders {\n  cacheControl?: string;\n  contentEncoding?: string;\n  contentLanguage?: string;\n  contentDisposition?: string;\n  contentType?: string;\n}\n\nexport interface PathCreateOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  metadata?: Metadata;\n  permissions?: string; // TODO: model or string?\n  umask?: string; // TODO: model or string?\n  conditions?: DataLakeRequestConditions;\n  pathHttpHeaders?: PathCreateHttpHeaders;\n}\n\nexport interface PathCreateIfNotExistsOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  metadata?: Metadata;\n  permissions?: string;\n  umask?: string;\n  pathHttpHeaders?: PathCreateHttpHeaders;\n}\n\nexport interface PathDeleteOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: DataLakeRequestConditions;\n}\n\nexport interface PathGetAccessControlOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: DataLakeRequestConditions;\n  userPrincipalName?: boolean;\n}\n\nexport interface PathGetAccessControlHeaders {\n  date?: Date;\n  etag?: string;\n  lastModified?: Date;\n  owner?: string;\n  group?: string;\n  requestId?: string;\n  version?: string;\n}\n\nexport interface PathAccessControl {\n  owner?: string;\n  group?: string;\n  permissions?: PathPermissions;\n  acl: PathAccessControlItem[];\n}\n\nexport type PathGetAccessControlResponse = PathAccessControl &\n  PathGetAccessControlHeaders & {\n    _response: HttpResponse & {\n      parsedHeaders: PathGetPropertiesHeadersModel;\n    };\n  };\n\nexport interface PathSetAccessControlOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: DataLakeRequestConditions;\n  owner?: string;\n  group?: string;\n}\n\n/**\n * Options type for `setAccessControlRecursive`, `updateAccessControlRecursive` and `removeAccessControlRecursive`.\n */\nexport interface PathChangeAccessControlRecursiveOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Optional. If data set size exceeds batch size then operation will be split into multiple requests so that progress can be tracked.\n   * Batch size should be between 1 and 2000. The default when unspecified is 2000.\n   */\n  batchSize?: number;\n  /**\n   * Optional. Defines maximum number of batches that single change Access Control operation can execute.\n   * If maximum is reached before all subpaths are processed then continuation token can be used to resume operation.\n   * Empty value indicates that maximum number of batches in unbound and operation continues till end.\n   */\n  maxBatches?: number;\n  /**\n   * Optional. Default false. If set to false, the operation will terminate quickly on encountering user failures.\n   * If true, the operation will ignore user failures and proceed with the operation on other sub-entities of the directory.\n   */\n  continueOnFailure?: boolean;\n  /**\n   * Continuation token to continue next batch of operations.\n   */\n  continuationToken?: string;\n  /**\n   * Callback where caller can track progress of the operation\n   * as well as collect paths that failed to change Access Control.\n   */\n  onProgress?: (progress: AccessControlChanges) => void;\n}\n\n/**\n * Represents an entry that failed to update Access Control List during `setAccessControlRecursive`, `updateAccessControlRecursive` and `removeAccessControlRecursive`.\n */\nexport interface AccessControlChangeError {\n  /**\n   * Returns name of an entry.\n   */\n  name: string;\n  /**\n   * Returns whether entry is a directory.\n   */\n  isDirectory: boolean;\n  /**\n   * Returns error message that is the reason why entry failed to update.\n   */\n  message: string;\n}\n\n/**\n * AccessControlChanges contains batch and cumulative counts of operations that change Access Control Lists recursively.\n * Additionally it exposes path entries that failed to update while these operations progress.\n */\nexport interface AccessControlChanges {\n  /**\n   * Path entries that failed to update Access Control List within single batch.\n   */\n  batchFailures: AccessControlChangeError[];\n  /**\n   * Counts of paths changed within single batch.\n   */\n  batchCounters: AccessControlChangeCounters;\n  /**\n   * Counts of paths changed from start of the operation.\n   */\n  aggregateCounters: AccessControlChangeCounters;\n  /**\n   * Optional. Value is present when operation is split into multiple batches and can be used to resume progress.\n   */\n  continuationToken?: string;\n}\n\n/**\n * AccessControlChangeCounters contains counts of operations that change Access Control Lists recursively.\n */\nexport interface AccessControlChangeCounters {\n  /**\n   * Returns number of directories where Access Control List has been updated successfully.\n   */\n  changedDirectoriesCount: number;\n  /**\n   * Returns number of files where Access Control List has been updated successfully.\n   */\n  changedFilesCount: number;\n  /**\n   * Returns number of paths where Access Control List update has failed.\n   */\n  failedChangesCount: number;\n}\n\n/**\n * Response type for `setAccessControlRecursive`, `updateAccessControlRecursive` and `removeAccessControlRecursive`.\n */\nexport interface PathChangeAccessControlRecursiveResponse {\n  /**\n   * Contains counts of paths changed from start of the operation.\n   */\n  counters: AccessControlChangeCounters;\n  /**\n   * Optional. Value is present when operation is split into multiple batches and can be used to resume progress.\n   */\n  continuationToken?: string;\n}\n\nexport interface PathSetPermissionsOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: DataLakeRequestConditions;\n  owner?: string;\n  group?: string;\n}\n\nexport interface PathGetPropertiesOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: DataLakeRequestConditions;\n}\n\nexport type CopyStatusType = \"pending\" | \"success\" | \"aborted\" | \"failed\";\n\nexport interface PathGetPropertiesHeaders {\n  lastModified?: Date;\n  createdOn?: Date;\n  metadata?: Metadata;\n  copyCompletedOn?: Date;\n  copyStatusDescription?: string;\n  copyId?: string;\n  copyProgress?: string;\n  copySource?: string;\n  copyStatus?: CopyStatusType;\n  isIncrementalCopy?: boolean;\n  destinationSnapshot?: string;\n  leaseDuration?: LeaseDurationType;\n  leaseState?: LeaseStateType;\n  leaseStatus?: LeaseStatusType;\n  contentLength?: number;\n  contentType?: string;\n  etag?: string;\n  contentMD5?: Uint8Array;\n  contentEncoding?: string;\n  contentDisposition?: string;\n  contentLanguage?: string;\n  cacheControl?: string;\n  // blobSequenceNumber?: number;\n  clientRequestId?: string;\n  requestId?: string;\n  version?: string;\n  date?: Date;\n  acceptRanges?: string;\n  // blobCommittedBlockCount?: number;\n  isServerEncrypted?: boolean;\n  encryptionKeySha256?: string;\n  accessTier?: string;\n  accessTierInferred?: boolean;\n  archiveStatus?: string;\n  accessTierChangedOn?: Date;\n\n  /**\n   * The time the file will expire.\n   */\n  expiresOn?: Date;\n}\n\nexport type PathGetPropertiesResponse = PathGetPropertiesHeaders & {\n  _response: HttpResponse & {\n    parsedHeaders: PathGetPropertiesHeaders;\n  };\n};\n\nexport interface PathSetHttpHeadersOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: DataLakeRequestConditions;\n}\n\nexport interface PathHttpHeaders {\n  cacheControl?: string;\n  contentEncoding?: string;\n  contentLanguage?: string;\n  contentDisposition?: string;\n  contentType?: string;\n  contentMD5?: Uint8Array;\n}\n\nexport interface PathSetHttpHeadersHeaders {\n  etag?: string;\n  lastModified?: Date;\n  clientRequestId?: string;\n  requestId?: string;\n  version?: string;\n  date?: Date;\n}\n\nexport type PathSetHttpHeadersResponse = PathSetHttpHeadersHeaders & {\n  _response: HttpResponse & {\n    parsedHeaders: PathSetHttpHeadersHeaders;\n  };\n};\n\nexport interface PathSetMetadataOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: DataLakeRequestConditions;\n}\n\nexport interface PathSetMetadataHeaders {\n  etag?: string;\n  lastModified?: Date;\n  clientRequestId?: string;\n  requestId?: string;\n  version?: string;\n  date?: Date;\n  isServerEncrypted?: boolean;\n  encryptionKeySha256?: string;\n}\n\nexport type PathSetMetadataResponse = PathSetMetadataHeaders & {\n  _response: HttpResponse & {\n    parsedHeaders: PathSetMetadataHeaders;\n  };\n};\n\nexport interface PathMoveOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: DataLakeRequestConditions;\n  destinationConditions?: DataLakeRequestConditions;\n}\n\nexport interface PathRemoveHeaders {\n  date?: Date;\n  etag?: string;\n  lastModified?: Date;\n  requestId?: string;\n  version?: string;\n  contentLength?: number;\n}\n\nexport type PathMoveResponse = PathRemoveHeaders & {\n  _response: HttpResponse & {\n    parsedHeaders: PathRemoveHeaders;\n  };\n};\n\n/**\n * Option interface for Data Lake directory/file exists operations\n *\n * See:\n * - {@link DataLakePathClient.exists}\n */\nexport interface PathExistsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  // customerProvidedKey?: CpkInfo; not supported yet\n}\n\n/**\n * Contains response data for the {@link DataLakePathClient.createIfNotExists} operation.\n */\nexport interface PathCreateIfNotExistsResponse extends PathCreateResponse {\n  /**\n   * Indicate whether the directory/file is successfully created. Is false when the directory/file is not changed as it already exists.\n   */\n  succeeded: boolean;\n}\n\n/**\n * Contains response data for the {@link DataLakePathClient.deleteIfExists} operation.\n */\nexport interface PathDeleteIfExistsResponse extends PathDeleteResponse {\n  /**\n   * Indicate whether the directory/file is successfully deleted. Is false if the directory/file doesn't exist in the first place.\n   */\n  succeeded: boolean;\n}\n\n// Keeping these for backward compatibility when we changed to use string unions.\n/**\n * Defines values for PathGetPropertiesAction.\n * Possible values include: 'getAccessControl', 'getStatus'\n * @readonly\n */\nexport enum PathGetPropertiesAction {\n  GetAccessControl = \"getAccessControl\",\n  GetStatus = \"getStatus\"\n}\n/**\n * Defines values for PathRenameMode.\n * Possible values include: 'legacy', 'posix'\n * @readonly\n */\nexport enum PathRenameMode {\n  Legacy = \"legacy\",\n  Posix = \"posix\"\n}\n/**\n * Defines values for PathResourceType.\n * Possible values include: 'directory', 'file'\n * @readonly\n */\nexport enum PathResourceType {\n  Directory = \"directory\",\n  File = \"file\"\n}\n\n/** **************************************************************/\n/** DataLakeDirectoryClient option and response related models **/\n/** **************************************************************/\n\nexport interface DirectoryCreateOptions extends PathCreateOptions {}\n\nexport interface DirectoryCreateIfNotExistsOptions extends PathCreateIfNotExistsOptions {}\n\nexport interface DirectoryCreateResponse extends PathCreateResponse {}\n\nexport interface DirectoryCreateIfNotExistsResponse extends PathCreateIfNotExistsResponse {}\n\n/**\n * Options to configure {@link DataLakeDirectoryClient.generateSasUrl} operation.\n */\nexport interface DirectoryGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {\n  /**\n   * Optional only when identifier is provided. Specifies the list of permissions to be associated with the SAS.\n   */\n  permissions?: DirectorySASPermissions;\n}\n\n/** *********************************************************/\n/** DataLakeFileClient option and response related models **/\n/** *********************************************************/\n\nexport interface FileReadOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  rangeGetContentMD5?: boolean;\n  rangeGetContentCrc64?: boolean;\n  conditions?: DataLakeRequestConditions;\n  onProgress?: (progress: TransferProgressEvent) => void;\n  maxRetryRequests?: number;\n}\n\nexport interface FileReadHeaders {\n  lastModified?: Date;\n  metadata?: Metadata;\n  contentLength?: number;\n  contentType?: string;\n  contentRange?: string;\n  etag?: string;\n  contentMD5?: Uint8Array;\n  contentEncoding?: string;\n  cacheControl?: string;\n  contentDisposition?: string;\n  contentLanguage?: string;\n  // blobSequenceNumber?: number;\n  copyCompletedOn?: Date;\n  copyStatusDescription?: string;\n  copyId?: string;\n  copyProgress?: string;\n  copySource?: string;\n  copyStatus?: CopyStatusType;\n  leaseDuration?: LeaseDurationType;\n  leaseState?: LeaseStateType;\n  leaseStatus?: LeaseStatusType;\n  clientRequestId?: string;\n  requestId?: string;\n  version?: string;\n  acceptRanges?: string;\n  date?: Date;\n  // blobCommittedBlockCount?: number;\n  isServerEncrypted?: boolean;\n  encryptionKeySha256?: string;\n  fileContentMD5?: Uint8Array; // Content MD5 for whole file\n  contentCrc64?: Uint8Array;\n}\n\nexport type FileReadResponse = FileReadHeaders & {\n  contentAsBlob?: Promise<Blob>;\n  readableStreamBody?: NodeJS.ReadableStream;\n  _response: HttpResponse & {\n    parsedHeaders: FileReadHeaders;\n  };\n};\n\nexport interface FileAppendOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: LeaseAccessConditions;\n  transactionalContentMD5?: Uint8Array;\n  onProgress?: (progress: TransferProgressEvent) => void;\n}\n\nexport interface FileFlushOptions extends CommonOptions {\n  abortSignal?: AbortSignalLike;\n  conditions?: DataLakeRequestConditions;\n  retainUncommittedData?: boolean;\n  close?: boolean;\n  pathHttpHeaders?: PathHttpHeaders;\n}\n\nexport interface FileCreateOptions extends PathCreateOptions {}\n\nexport interface FileCreateIfNotExistsOptions extends PathCreateIfNotExistsOptions {}\n\nexport interface FileCreateResponse extends PathCreateResponse {}\n\nexport interface FileCreateIfNotExistsResponse extends PathCreateIfNotExistsResponse {}\n\n/**\n * Option interface for Data Lake file - Upload operations\n *\n * See:\n * - {@link DataLakeFileClient.upload}\n * - {@link DataLakeFileClient.uploadFile}\n * - {@link DataLakeFileClient.uploadStream}\n */\nexport interface FileParallelUploadOptions extends CommonOptions {\n  // For all.\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Access conditions headers.\n   */\n  conditions?: DataLakeRequestConditions;\n\n  // For create and flush.\n  /**\n   * Http headers.\n   */\n  pathHttpHeaders?: PathHttpHeaders;\n\n  // For create.\n  /**\n   * A collection of key-value string pair to associate with the Data Lake file.\n   */\n  metadata?: Metadata;\n\n  /**\n   * Sets POSIX access permissions for the file owner, the file owning group, and others.\n   * Each class may be granted read, write, or execute permission. The sticky bit is also supported.\n   * Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.\n   */\n  permissions?: string; // TODO: model or string?\n\n  /**\n   * The umask restricts the permissions of the file to be created.\n   * The resulting permission is given by p & ^u, where p is the permission and u is the umask.\n   * For example, if p is 0777 and u is 0057, then the resulting permission is 0720.\n   * The default permission is 0666 for a file. The default umask is 0027.\n   * The umask must be specified in 4-digit octal notation (e.g. 0766).\n   */\n  umask?: string; // TODO: model or string?\n\n  // For append.\n  /**\n   * Progress updater.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n\n  // For flush.\n  /**\n   * When Azure Storage Events are enabled, a file changed event is raised.\n   * This event has a property indicating whether this is the final change\n   * to distinguish the difference between an intermediate flush to a file stream (when close set to \"false\")\n   * and the final close of a file stream (when close set to \"true\").\n   */\n  close?: boolean;\n\n  // For parallel transfer control.\n\n  /**\n   * Data size threshold in bytes to use a single upload operation rather than parallel uploading.\n   * Data of smaller size than this limit will be transferred in a single upload.\n   * Data larger than this limit will be transferred in chunks in parallel.\n   * Its default and max value is FILE_MAX_SINGLE_UPLOAD_THRESHOLD.\n   * Note: {@link DataLakeFileClient.uploadStream} do not respect this field and always do parallel uploading.\n   */\n  singleUploadThreshold?: number;\n\n  /**\n   * The size of data in bytes that will be transferred in parallel.\n   * If set to 0 or undefined, it will be automatically calculated according\n   * to the data size. Its max value is FILE_UPLOAD_MAX_CHUNK_SIZE.\n   */\n  chunkSize?: number;\n  /**\n   * Max concurrency of parallel uploading. Must be greater than or equal to 0. Its default value is DEFAULT_HIGH_LEVEL_CONCURRENCY.\n   */\n  maxConcurrency?: number;\n}\n\n/**\n * Option interface for Data Lake file - readToBuffer operations\n *\n * See:\n * - {@link DataLakeFileClient.readToBuffer}\n */\nexport interface FileReadToBufferOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Access conditions headers.\n   */\n  conditions?: DataLakeRequestConditions;\n\n  /**\n   * Progress updater.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * How many retries will perform for each read when the original chunk read stream ends unexpectedly.\n   * Above kind of ends will not trigger retry policy defined in a pipeline,\n   * because they doesn't emit network errors. Default value is 5.\n   */\n  maxRetryRequestsPerChunk?: number;\n\n  /**\n   * chunkSize is size of data every request trying to read.\n   * Must be greater than or equal to 0, if set to 0 or undefined, it will automatically calculated according\n   * to the file size.\n   */\n  chunkSize?: number;\n\n  /**\n   * Concurrency of parallel read.\n   */\n  concurrency?: number;\n}\n\n/**\n * Options to query file with JSON format.\n */\nexport interface FileQueryJsonTextConfiguration {\n  /**\n   * Record separator.\n   */\n  recordSeparator: string;\n  /**\n   * Query for a JSON format file.\n   */\n  kind: \"json\";\n}\n\n/**\n * Options to query file with CSV format.\n */\nexport interface FileQueryCsvTextConfiguration {\n  /**\n   * Record separator.\n   */\n  recordSeparator: string;\n  /**\n   * Query for a CSV format file.\n   */\n  kind: \"csv\";\n  /**\n   * Column separator. Default is \",\".\n   */\n  columnSeparator?: string;\n  /**\n   * Field quote.\n   */\n  fieldQuote?: string;\n  /**\n   * Escape character.\n   */\n  escapeCharacter?: string;\n  /**\n   * Has headers. Default is false.\n   */\n  hasHeaders?: boolean;\n}\n\n/**\n * Options to query file with Parquet format.\n */\nexport interface FileQueryParquetConfiguration {\n  /**\n   * Kind.\n   */\n  kind: \"parquet\";\n}\n\n/**\n * File query error type.\n */\nexport interface FileQueryError {\n  /**\n   * Whether the error is fatal or not. A fatal error will stop the query.\n   */\n  isFatal: boolean;\n  /**\n   * Error name.\n   */\n  name: string;\n  /**\n   * Position in bytes of the query.\n   */\n  position: number;\n  /**\n   * Error description.\n   */\n  description: string;\n}\n\n/**\n * Option interface for Data Lake file - query operations\n *\n * See:\n * - {@link DataLakeFileClient.query}\n */\nexport interface FileQueryOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Configurations for the query input.\n   */\n  inputTextConfiguration?:\n    | FileQueryJsonTextConfiguration\n    | FileQueryCsvTextConfiguration\n    | FileQueryParquetConfiguration;\n  /**\n   * Configurations for the query output.\n   */\n  outputTextConfiguration?:\n    | FileQueryJsonTextConfiguration\n    | FileQueryCsvTextConfiguration\n    | FileQueryArrowConfiguration;\n  /**\n   * Callback to receive events on the progress of query operation.\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * Callback to receive error events during the query operaiton.\n   */\n  onError?: (error: FileQueryError) => void;\n  /**\n   * Conditions to meet when uploading to the block file.\n   */\n  conditions?: DataLakeRequestConditions;\n}\n\n/**\n * Option interface for the {@link DataLakeFileClient.setExpiry} operation.\n */\nexport interface FileSetExpiryOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * The time to set the file to expire on, used in combination with the \"Absolute\" {@link FileExpiryMode}.\n   * A time in the past is not allowed and milliseconds will be dropped.\n   */\n  expiresOn?: Date;\n\n  /**\n   * The number of milliseconds to elapse before the file expires, used in combination with the \"RelativeToCreation\" or \"RelativeToNow\" {@link FileExpiryMode}.\n   */\n  timeToExpireInMs?: number;\n}\n\n/**\n * Options to configure {@link DataLakeFileClient.generateSasUrl} operation.\n */\nexport interface FileGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {\n  /**\n   * Optional only when identifier is provided. Specifies the list of permissions to be associated with the SAS.\n   */\n  permissions?: DataLakeSASPermissions;\n}\n\n/** *********************************************************/\n/** DataLakeLeaseClient option and response related models */\n/** *********************************************************/\n"]}