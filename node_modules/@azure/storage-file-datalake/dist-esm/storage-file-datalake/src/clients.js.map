{"version":3,"file":"clients.js","sourceRoot":"","sources":["../../../src/clients.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpRequestBody, isNode, TokenCredential } from \"@azure/core-http\";\nimport { BlobClient, BlockBlobClient } from \"@azure/storage-blob\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { Readable } from \"stream\";\n\nimport { BufferScheduler } from \"../../storage-common/src\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { DataLakeLeaseClient } from \"./DataLakeLeaseClient\";\nimport { Path } from \"./generated/src/operations\";\nimport {\n  AccessControlChanges,\n  DirectoryCreateIfNotExistsOptions,\n  DirectoryCreateIfNotExistsResponse,\n  DirectoryCreateOptions,\n  DirectoryCreateResponse,\n  DirectoryGenerateSasUrlOptions,\n  FileAppendOptions,\n  FileAppendResponse,\n  FileCreateIfNotExistsOptions,\n  FileCreateIfNotExistsResponse,\n  FileCreateOptions,\n  FileCreateResponse,\n  FileExpiryMode,\n  FileFlushOptions,\n  FileFlushResponse,\n  FileGenerateSasUrlOptions,\n  FileParallelUploadOptions,\n  FileQueryOptions,\n  FileReadOptions,\n  FileReadResponse,\n  FileReadToBufferOptions,\n  FileSetExpiryOptions,\n  FileSetExpiryResponse,\n  FileUploadResponse,\n  Metadata,\n  PathAccessControlItem,\n  PathChangeAccessControlRecursiveOptions,\n  PathChangeAccessControlRecursiveResponse,\n  PathCreateIfNotExistsOptions,\n  PathCreateIfNotExistsResponse,\n  PathCreateOptions,\n  PathCreateResponse,\n  PathDeleteIfExistsResponse,\n  PathDeleteOptions,\n  PathDeleteResponse,\n  PathExistsOptions,\n  PathGetAccessControlOptions,\n  PathGetAccessControlResponse,\n  PathGetPropertiesOptions,\n  PathGetPropertiesResponse,\n  PathHttpHeaders,\n  PathMoveOptions,\n  PathMoveResponse,\n  PathPermissions,\n  PathResourceTypeModel,\n  PathSetAccessControlOptions,\n  PathSetAccessControlResponse,\n  PathSetHttpHeadersOptions,\n  PathSetHttpHeadersResponse,\n  PathSetMetadataOptions,\n  PathSetMetadataResponse,\n  PathSetPermissionsOptions,\n  PathSetPermissionsResponse,\n  RemovePathAccessControlItem\n} from \"./models\";\nimport { PathSetAccessControlRecursiveMode } from \"./models.internal\";\nimport { newPipeline, Pipeline, StoragePipelineOptions } from \"./Pipeline\";\nimport { generateDataLakeSASQueryParameters } from \"./sas/DataLakeSASSignatureValues\";\nimport { StorageClient } from \"./StorageClient\";\nimport {\n  toAccessControlChangeFailureArray,\n  toAclString,\n  toPathGetAccessControlResponse,\n  toPermissionsString,\n  toProperties\n} from \"./transforms\";\nimport { Batch } from \"./utils/Batch\";\nimport {\n  BLOCK_BLOB_MAX_BLOCKS,\n  DEFAULT_HIGH_LEVEL_CONCURRENCY,\n  ETagAny,\n  FILE_MAX_SINGLE_UPLOAD_THRESHOLD,\n  FILE_MAX_SIZE_BYTES,\n  FILE_UPLOAD_DEFAULT_CHUNK_SIZE,\n  FILE_UPLOAD_MAX_CHUNK_SIZE\n} from \"./utils/constants\";\nimport { DataLakeAclChangeFailedError } from \"./utils/DataLakeAclChangeFailedError\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport {\n  appendToURLPath,\n  appendToURLQuery,\n  getURLPathAndQuery,\n  setURLPath,\n  setURLQueries\n} from \"./utils/utils.common\";\nimport { fsCreateReadStream, fsStat } from \"./utils/utils.node\";\n\n/**\n * A DataLakePathClient represents a URL to the Azure Storage path (directory or file).\n */\nexport class DataLakePathClient extends StorageClient {\n  /**\n   * pathContext provided by protocol layer.\n   */\n  private pathContext: Path;\n\n  /**\n   * blobClient provided by `@azure/storage-blob` package.\n   */\n  private blobClient: BlobClient;\n\n  /**\n   * SetAccessControlRecursiveInternal operation sets the Access Control on a path and sub paths.\n   *\n   * @param mode - Mode \\\"set\\\" sets POSIX access control rights on files and directories,\n   *                                                 Mode \\\"modify\\\" modifies one or more POSIX access control rights that pre-exist on files and directories,\n   *                                                 Mode \\\"remove\\\" removes one or more POSIX access control rights that were present earlier on files and directories.\n   * @param acl - The POSIX access control list for the file or directory.\n   * @param options - Optional. Options\n   */\n  private async setAccessControlRecursiveInternal(\n    mode: PathSetAccessControlRecursiveMode,\n    acl: PathAccessControlItem[] | RemovePathAccessControlItem[],\n    options: PathChangeAccessControlRecursiveOptions = {}\n  ): Promise<PathChangeAccessControlRecursiveResponse> {\n    if (options.maxBatches !== undefined && options.maxBatches < 1) {\n      throw RangeError(`Options maxBatches must be larger than 0.`);\n    }\n\n    if (options.batchSize !== undefined && options.batchSize < 1) {\n      throw RangeError(`Options batchSize must be larger than 0.`);\n    }\n\n    const { span, updatedOptions } = createSpan(\n      `DataLakePathClient-setAccessControlRecursiveInternal`,\n      options\n    );\n\n    const result: PathChangeAccessControlRecursiveResponse = {\n      counters: {\n        failedChangesCount: 0,\n        changedDirectoriesCount: 0,\n        changedFilesCount: 0\n      },\n      continuationToken: undefined\n    };\n\n    try {\n      let continuationToken = options.continuationToken;\n      let batchCounter = 0;\n      let reachMaxBatches = false;\n      do {\n        let response;\n        try {\n          response = await this.pathContext.setAccessControlRecursive(mode, {\n            ...options,\n            acl: toAclString(acl as PathAccessControlItem[]),\n            maxRecords: options.batchSize,\n            continuation: continuationToken,\n            forceFlag: options.continueOnFailure,\n            ...convertTracingToRequestOptionsBase(updatedOptions)\n          });\n        } catch (e) {\n          throw new DataLakeAclChangeFailedError(e, continuationToken);\n        }\n\n        batchCounter++;\n        continuationToken = response.continuation;\n\n        // Update result\n        result.continuationToken = continuationToken;\n        result.counters.failedChangesCount += response.failureCount || 0;\n        result.counters.changedDirectoriesCount += response.directoriesSuccessful || 0;\n        result.counters.changedFilesCount += response.filesSuccessful || 0;\n\n        // Progress event call back\n        if (options.onProgress) {\n          const progress: AccessControlChanges = {\n            batchFailures: toAccessControlChangeFailureArray(response.failedEntries),\n            batchCounters: {\n              failedChangesCount: response.failureCount || 0,\n              changedDirectoriesCount: response.directoriesSuccessful || 0,\n              changedFilesCount: response.filesSuccessful || 0\n            },\n            aggregateCounters: result.counters,\n            continuationToken: continuationToken\n          };\n          options.onProgress(progress);\n        }\n\n        reachMaxBatches =\n          options.maxBatches === undefined ? false : batchCounter >= options.maxBatches;\n      } while (continuationToken && !reachMaxBatches);\n\n      return result;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates an instance of DataLakePathClient from url and credential.\n   *\n   * @param url - A Client string pointing to Azure Storage data lake path (directory or file), such as\n   *                     \"https://myaccount.dfs.core.windows.net/filesystem/directory\" or \"https://myaccount.dfs.core.windows.net/filesystem/file\".\n   *                     You can append a SAS if using AnonymousCredential, such as \"https://myaccount.dfs.core.windows.net/filesystem/directory?sasString\".\n   * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  public constructor(\n    url: string,\n    credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: StoragePipelineOptions\n  );\n\n  /**\n   * Creates an instance of DataLakePathClient from url and pipeline.\n   *\n   * @param url - A Client string pointing to Azure Storage data lake path (directory or file), such as\n   *                     \"https://myaccount.dfs.core.windows.net/filesystem/directory\" or \"https://myaccount.dfs.core.windows.net/filesystem/file\".\n   *                     You can append a SAS if using AnonymousCredential, such as \"https://myaccount.dfs.core.windows.net/filesystem/directory?sasString\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  public constructor(url: string, pipeline: Pipeline);\n\n  public constructor(\n    url: string,\n    credentialOrPipeline?:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | Pipeline,\n    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: StoragePipelineOptions\n  ) {\n    if (credentialOrPipeline instanceof Pipeline) {\n      super(url, credentialOrPipeline);\n    } else {\n      let credential;\n      if (credentialOrPipeline === undefined) {\n        credential = new AnonymousCredential();\n      } else {\n        credential = credentialOrPipeline;\n      }\n\n      const pipeline = newPipeline(credential, options);\n      super(url, pipeline);\n    }\n\n    this.pathContext = new Path(this.storageClientContext);\n    this.blobClient = new BlobClient(this.blobEndpointUrl, this.pipeline);\n  }\n\n  /**\n   * Name of current file system.\n   *\n   * @readonly\n   */\n  public get fileSystemName(): string {\n    return this.blobClient.containerName;\n  }\n\n  /**\n   * Name of current path (directory or file).\n   *\n   * @readonly\n   */\n  public get name(): string {\n    return this.blobClient.name;\n  }\n\n  /**\n   * Convert current DataLakePathClient to DataLakeDirectoryClient if current path is a directory.\n   *\n   */\n  // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */\n  public toDirectoryClient(): DataLakeDirectoryClient {\n    return new DataLakeDirectoryClient(this.dfsEndpointUrl, this.pipeline);\n  }\n\n  /**\n   * Convert current DataLakePathClient to DataLakeFileClient if current path is a file.\n   *\n   */\n  // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */\n  public toFileClient(): DataLakeFileClient {\n    return new DataLakeFileClient(this.dfsEndpointUrl, this.pipeline);\n  }\n\n  /**\n   * Get a {@link DataLakeLeaseClient} that manages leases on the path (directory or file).\n   *\n   * @param proposeLeaseId - Optional. Initial proposed lease Id.\n   */\n  public getDataLakeLeaseClient(proposeLeaseId?: string): DataLakeLeaseClient {\n    return new DataLakeLeaseClient(this.blobClient.getBlobLeaseClient(proposeLeaseId));\n  }\n\n  /**\n   * Create a directory or path.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param resourceType - Resource type, \"directory\" or \"file\".\n   * @param options - Optional. Options when creating path.\n   */\n  public async create(\n    resourceType: PathResourceTypeModel,\n    options: PathCreateOptions = {}\n  ): Promise<PathCreateResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"DataLakePathClient-create\", options);\n    try {\n      return await this.pathContext.create({\n        ...options,\n        resource: resourceType,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: options.conditions,\n        properties: toProperties(options.metadata),\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Create a directory or file. If the resource already exists, it is not changed.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param resourceType - Resource type, \"directory\" or \"file\".\n   * @param options -\n   */\n  public async createIfNotExists(\n    resourceType: PathResourceTypeModel,\n    options: PathCreateIfNotExistsOptions = {}\n  ): Promise<PathCreateIfNotExistsResponse> {\n    const { span, updatedOptions } = createSpan(\"DataLakePathClient-createIfNotExists\", options);\n    try {\n      const conditions = { ifNoneMatch: ETagAny };\n      const res = await this.create(resourceType, {\n        ...options,\n        conditions,\n        tracingOptions: updatedOptions.tracingOptions\n      });\n      return {\n        succeeded: true,\n        ...res\n      };\n    } catch (e) {\n      if (e.details?.errorCode === \"PathAlreadyExists\") {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when creating a blob only if it does not already exist.\"\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response\n        };\n      }\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns true if the Data Lake file represented by this client exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing file might be deleted by other clients or\n   * applications. Vice versa new files might be added by other clients or applications after this\n   * function completes.\n   *\n   * @param options - options to Exists operation.\n   */\n  public async exists(options: PathExistsOptions = {}): Promise<boolean> {\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-exists\", options);\n    try {\n      return await this.blobClient.exists(updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Delete current path (directory or file).\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/delete\n   *\n   * @param recursive - Required and valid only when the resource is a directory. If \"true\", all paths beneath the directory will be deleted.\n   * @param options - Optional. Options when deleting path.\n   */\n  public async delete(\n    recursive?: boolean,\n    options: PathDeleteOptions = {}\n  ): Promise<PathDeleteResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"DataLakePathClient-delete\", options);\n    try {\n      let continuation;\n      let response;\n\n      // How to handle long delete loop?\n      do {\n        response = await this.pathContext.delete({\n          continuation,\n          recursive,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: options.conditions,\n          ...convertTracingToRequestOptionsBase(updatedOptions),\n          abortSignal: options.abortSignal\n        });\n        continuation = response.continuation;\n      } while (continuation !== undefined && continuation !== \"\");\n\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Delete current path (directory or file) if it exists.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/delete\n   *\n   * @param recursive - Required and valid only when the resource is a directory. If \"true\", all paths beneath the directory will be deleted.\n   * @param options -\n   */\n  public async deleteIfExists(\n    recursive?: boolean,\n    options: PathDeleteOptions = {}\n  ): Promise<PathDeleteIfExistsResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"DataLakePathClient-deleteIfExists\", options);\n    try {\n      const res = await this.delete(recursive, updatedOptions);\n      return {\n        succeeded: true,\n        ...res\n      };\n    } catch (e) {\n      if (e.details?.errorCode === \"PathNotFound\") {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: \"Expected exception when deleting a directory or file only if it exists.\"\n        });\n        return {\n          succeeded: false,\n          ...e.response?.parsedHeaders,\n          _response: e.response\n        };\n      }\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns the access control data for a path (directory of file).\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/getproperties\n   *\n   * @param options - Optional. Options when getting file access control.\n   */\n  public async getAccessControl(\n    options: PathGetAccessControlOptions = {}\n  ): Promise<PathGetAccessControlResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"DataLakePathClient-getAccessControl\", options);\n    try {\n      const response = await this.pathContext.getProperties({\n        action: \"getAccessControl\",\n        upn: options.userPrincipalName,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: options.conditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n        abortSignal: options.abortSignal\n      });\n      return toPathGetAccessControlResponse(response);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Set the access control data for a path (directory of file).\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update\n   *\n   * @param acl - The POSIX access control list for the file or directory.\n   * @param options - Optional. Options when setting path access control.\n   */\n  public async setAccessControl(\n    acl: PathAccessControlItem[],\n    options: PathSetAccessControlOptions = {}\n  ): Promise<PathSetAccessControlResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"DataLakePathClient-setAccessControl\", options);\n    try {\n      return await this.pathContext.setAccessControl({\n        ...options,\n        acl: toAclString(acl),\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: options.conditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets the Access Control on a path and sub paths.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update\n   *\n   * @param acl - The POSIX access control list for the file or directory.\n   * @param options - Optional. Options\n   */\n  public async setAccessControlRecursive(\n    acl: PathAccessControlItem[],\n    options: PathChangeAccessControlRecursiveOptions = {}\n  ): Promise<PathChangeAccessControlRecursiveResponse> {\n    const { span, updatedOptions } = createSpan(\n      \"DataLakePathClient-setAccessControlRecursive\",\n      options\n    );\n    try {\n      return this.setAccessControlRecursiveInternal(\"set\", acl, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Modifies the Access Control on a path and sub paths.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update\n   *\n   * @param acl - The POSIX access control list for the file or directory.\n   * @param options - Optional. Options\n   */\n  public async updateAccessControlRecursive(\n    acl: PathAccessControlItem[],\n    options: PathChangeAccessControlRecursiveOptions = {}\n  ): Promise<PathChangeAccessControlRecursiveResponse> {\n    const { span, updatedOptions } = createSpan(\n      \"DataLakePathClient-updateAccessControlRecursive\",\n      options\n    );\n    try {\n      return this.setAccessControlRecursiveInternal(\"modify\", acl, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Removes the Access Control on a path and sub paths.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update\n   *\n   * @param acl - The POSIX access control list for the file or directory.\n   * @param options - Optional. Options\n   */\n  public async removeAccessControlRecursive(\n    acl: RemovePathAccessControlItem[],\n    options: PathChangeAccessControlRecursiveOptions = {}\n  ): Promise<PathChangeAccessControlRecursiveResponse> {\n    const { span, updatedOptions } = createSpan(\n      \"DataLakePathClient-removeAccessControlRecursive\",\n      options\n    );\n    try {\n      return this.setAccessControlRecursiveInternal(\"remove\", acl, updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets the file permissions on a path.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update\n   *\n   * @param permissions - The POSIX access permissions for the file owner, the file owning group, and others.\n   * @param options - Optional. Options when setting path permissions.\n   */\n  public async setPermissions(\n    permissions: PathPermissions,\n    options: PathSetPermissionsOptions = {}\n  ): Promise<PathSetPermissionsResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"DataLakePathClient-setPermissions\", options);\n    try {\n      return await this.pathContext.setAccessControl({\n        ...options,\n        permissions: toPermissionsString(permissions),\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: options.conditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns all user-defined metadata, standard HTTP properties, and system properties\n   * for the path (directory or file).\n   *\n   * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n   * they originally contained uppercase characters. This differs from the metadata keys returned by\n   * the methods of {@link DataLakeFileSystemClient} that list paths using the `includeMetadata` option, which\n   * will retain their original casing.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-properties\n   *\n   * @param options - Optional. Options when getting path properties.\n   */\n  public async getProperties(\n    options: PathGetPropertiesOptions = {}\n  ): Promise<PathGetPropertiesResponse> {\n    const { span, updatedOptions } = createSpan(\"DataLakePathClient-getProperties\", options);\n    try {\n      return await this.blobClient.getProperties({\n        ...options,\n        customerProvidedKey: undefined, // Doesn't support customer provided key in data lake package yet\n        tracingOptions: updatedOptions.tracingOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets system properties on the path (directory or file).\n   *\n   * If no value provided, or no value provided for the specified blob HTTP headers,\n   * these blob HTTP headers without a value will be cleared.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n   *\n   * @param httpHeaders -\n   * @param options -\n   */\n  public async setHttpHeaders(\n    httpHeaders: PathHttpHeaders,\n    options: PathSetHttpHeadersOptions = {}\n  ): Promise<PathSetHttpHeadersResponse> {\n    const { span, updatedOptions } = createSpan(\"DataLakePathClient-setHttpHeaders\", options);\n    try {\n      return await this.blobClient.setHTTPHeaders(\n        {\n          blobCacheControl: httpHeaders.cacheControl,\n          blobContentType: httpHeaders.contentType,\n          blobContentMD5: httpHeaders.contentMD5,\n          blobContentEncoding: httpHeaders.contentEncoding,\n          blobContentLanguage: httpHeaders.contentLanguage,\n          blobContentDisposition: httpHeaders.contentDisposition\n        },\n        updatedOptions\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets user-defined metadata for the specified path (directory of file) as one or more name-value pairs.\n   *\n   * If no option provided, or no metadata defined in the parameter, the path\n   * metadata will be removed.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata\n   *\n   * @param metadata - Optional. Replace existing metadata with this value.\n   *                              If no value provided the existing metadata will be removed.\n   * @param options - Optional. Options when setting path metadata.\n   */\n  public async setMetadata(\n    metadata?: Metadata,\n    options: PathSetMetadataOptions = {}\n  ): Promise<PathSetMetadataResponse> {\n    const { span, updatedOptions } = createSpan(\"DataLakePathClient-setMetadata\", options);\n    try {\n      return await this.blobClient.setMetadata(metadata, {\n        ...options,\n        customerProvidedKey: undefined, // Doesn't support customer provided key in data lake package yet\n        tracingOptions: updatedOptions.tracingOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Move directory or file within same file system.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param destinationPath - Destination directory path like \"directory\" or file path \"directory/file\".\n   *                                 If the destinationPath is authenticated with SAS, add the SAS to the destination path like \"directory/file?sasToken\".\n   * @param options - Optional. Options when moving directory or file.\n   */\n  public async move(destinationPath: string, options?: PathMoveOptions): Promise<PathMoveResponse>;\n\n  /**\n   * Move directory or file to another file system.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param destinationFileSystem - Destination file system like \"filesystem\".\n   * @param destinationPath - Destination directory path like \"directory\" or file path \"directory/file\"\n   *                                 If the destinationPath is authenticated with SAS, add the SAS to the destination path like \"directory/file?sasToken\".\n   * @param options - Optional. Options when moving directory or file.\n   */\n  public async move(\n    destinationFileSystem: string,\n    destinationPath: string,\n    options?: PathMoveOptions\n  ): Promise<PathMoveResponse>;\n\n  public async move(\n    destinationPathOrFileSystem: string,\n    destinationPathOrOptions?: string | PathMoveOptions,\n    options?: PathMoveOptions\n  ): Promise<PathMoveResponse> {\n    let destinationFileSystem = this.fileSystemName;\n    let destinationPath = destinationPathOrFileSystem;\n\n    if (typeof destinationPathOrOptions === \"string\") {\n      destinationFileSystem = destinationPathOrFileSystem;\n      destinationPath = destinationPathOrOptions;\n      options = options || {};\n    } else {\n      options = destinationPathOrOptions || {};\n    }\n\n    options.conditions = options.conditions || {};\n    options.destinationConditions = options.destinationConditions || {};\n\n    const { span, updatedOptions } = createSpan(\"DataLakePathClient-move\", options);\n\n    const renameSource = getURLPathAndQuery(this.dfsEndpointUrl);\n\n    const split: string[] = destinationPath.split(\"?\");\n    let destinationUrl: string;\n    if (split.length === 2) {\n      const renameDestination = `/${destinationFileSystem}/${split[0]}`;\n      destinationUrl = setURLPath(this.dfsEndpointUrl, renameDestination);\n      destinationUrl = setURLQueries(destinationUrl, split[1]);\n    } else if (split.length === 1) {\n      const renameDestination = `/${destinationFileSystem}/${destinationPath}`;\n      destinationUrl = setURLPath(this.dfsEndpointUrl, renameDestination);\n    } else {\n      throw new RangeError(\"Destination path should not contain more than one query string\");\n    }\n\n    const destPathClient = new DataLakePathClient(destinationUrl, this.pipeline);\n\n    try {\n      return await destPathClient.pathContext.create({\n        mode: \"legacy\", // By default\n        renameSource,\n        sourceLeaseId: options.conditions.leaseId,\n        leaseAccessConditions: options.destinationConditions,\n        sourceModifiedAccessConditions: {\n          sourceIfMatch: options.conditions.ifMatch,\n          sourceIfNoneMatch: options.conditions.ifNoneMatch,\n          sourceIfModifiedSince: options.conditions.ifModifiedSince,\n          sourceIfUnmodifiedSince: options.conditions.ifUnmodifiedSince\n        },\n        modifiedAccessConditions: options.destinationConditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n        abortSignal: options.abortSignal\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n\n/**\n * A DataLakeDirectoryClient represents a URL to the Azure Storage directory.\n */\nexport class DataLakeDirectoryClient extends DataLakePathClient {\n  // https://stackoverflow.com/questions/50729485/override-method-with-different-argument-types-in-extended-class-typescript\n  /**\n   * Create a directory.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param resourceType - Resource type, must be \"directory\" for DataLakeDirectoryClient.\n   * @param options - Optional. Options when creating directory.\n   */\n  public async create(\n    resourceType: PathResourceTypeModel,\n    options?: PathCreateOptions\n  ): Promise<PathCreateResponse>;\n\n  /**\n   * Create a directory.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param options - Optional. Options when creating directory.\n   */\n  public async create(options?: DirectoryCreateOptions): Promise<DirectoryCreateResponse>;\n\n  public async create(\n    resourceTypeOrOptions?: PathResourceTypeModel | PathCreateOptions,\n    options: PathCreateOptions = {}\n  ): Promise<PathCreateResponse> {\n    if (resourceTypeOrOptions === \"directory\") {\n      return super.create(resourceTypeOrOptions as PathResourceTypeModel, options);\n    }\n\n    if (resourceTypeOrOptions === \"file\") {\n      throw TypeError(\n        `DataLakeDirectoryClient:create() resourceType cannot be ${resourceTypeOrOptions}. Refer to DataLakeFileClient for file creation.`\n      );\n    }\n\n    options = resourceTypeOrOptions || {};\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"DataLakeDirectoryClient-create\", options);\n    try {\n      return await super.create(\"directory\", {\n        ...options,\n        tracingOptions: {\n          ...options.tracingOptions,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Create a directory if it doesn't already exists.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param resourceType - Resource type, must be \"directory\" for DataLakeDirectoryClient.\n   * @param options -\n   */\n  public async createIfNotExists(\n    resourceType: PathResourceTypeModel,\n    options?: PathCreateIfNotExistsOptions\n  ): Promise<PathCreateIfNotExistsResponse>;\n\n  /**\n   * Create a directory if it doesn't already exists.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param options -\n   */\n  public async createIfNotExists(\n    options?: DirectoryCreateIfNotExistsOptions\n  ): Promise<DirectoryCreateIfNotExistsResponse>;\n\n  public async createIfNotExists(\n    resourceTypeOrOptions?: PathResourceTypeModel | PathCreateIfNotExistsOptions,\n    options: PathCreateIfNotExistsOptions = {}\n  ): Promise<PathCreateIfNotExistsResponse> {\n    if (resourceTypeOrOptions === \"file\") {\n      throw TypeError(\n        `DataLakeDirectoryClient:createIfNotExists() resourceType cannot be ${resourceTypeOrOptions}. Refer to DataLakeFileClient for file creation.`\n      );\n    }\n\n    if (resourceTypeOrOptions !== \"directory\") {\n      options = resourceTypeOrOptions || {};\n    }\n\n    const { span, updatedOptions } = createSpan(\n      \"DataLakeDirectoryClient-createIfNotExists\",\n      options\n    );\n    try {\n      return await super.createIfNotExists(\"directory\", {\n        ...options,\n        tracingOptions: {\n          ...options.tracingOptions,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a {@link DataLakeDirectoryClient} object under current directory.\n   *\n   * @param subdirectoryName - Subdirectory name.\n   */\n  public getSubdirectoryClient(subdirectoryName: string): DataLakeDirectoryClient {\n    return new DataLakeDirectoryClient(\n      appendToURLPath(this.url, encodeURIComponent(subdirectoryName)),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Creates a {@link DataLakeFileClient} object under current directory.\n   *\n   * @param fileName -\n   */\n  // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */\n  public getFileClient(fileName: string): DataLakeFileClient {\n    return new DataLakeFileClient(\n      appendToURLPath(this.url, encodeURIComponent(fileName)),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Only available for clients constructed with a shared key credential.\n   *\n   * Generates a Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateSasUrl(options: DirectoryGenerateSasUrlOptions): Promise<string> {\n    return new Promise((resolve) => {\n      if (!(this.credential instanceof StorageSharedKeyCredential)) {\n        throw RangeError(\n          \"Can only generate the SAS when the client is initialized with a shared key credential\"\n        );\n      }\n\n      const sas = generateDataLakeSASQueryParameters(\n        {\n          fileSystemName: this.fileSystemName,\n          pathName: this.name,\n          isDirectory: true,\n          ...options\n        },\n        this.credential\n      ).toString();\n\n      resolve(appendToURLQuery(this.url, sas));\n    });\n  }\n}\n\n/**\n * A DataLakeFileClient represents a URL to the Azure Storage file.\n */\nexport class DataLakeFileClient extends DataLakePathClient {\n  /**\n   * pathContextInternal provided by protocol layer.\n   */\n  private pathContextInternal: Path;\n\n  /**\n   * pathContextInternal provided by protocol layer, with its url pointing to the Blob endpoint.\n   */\n  private pathContextInternalToBlobEndpoint: Path;\n\n  /**\n   * blockBlobClientInternal provided by `@azure/storage-blob` package.\n   */\n  private blockBlobClientInternal: BlockBlobClient;\n\n  /**\n   * Creates an instance of DataLakeFileClient from url and credential.\n   *\n   * @param url - A Client string pointing to Azure Storage data lake file, such as\n   *                     \"https://myaccount.dfs.core.windows.net/filesystem/file\".\n   *                     You can append a SAS if using AnonymousCredential, such as \"https://myaccount.dfs.core.windows.net/filesystem/directory/file?sasString\".\n   * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  public constructor(\n    url: string,\n    credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: StoragePipelineOptions\n  );\n\n  /**\n   * Creates an instance of DataLakeFileClient from url and pipeline.\n   *\n   * @param url - A Client string pointing to Azure Storage data lake file, such as\n   *                     \"https://myaccount.dfs.core.windows.net/filesystem/file\".\n   *                     You can append a SAS if using AnonymousCredential, such as \"https://myaccount.dfs.core.windows.net/filesystem/directory/file?sasString\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  public constructor(url: string, pipeline: Pipeline);\n\n  public constructor(\n    url: string,\n    credentialOrPipeline?:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | Pipeline,\n    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: StoragePipelineOptions\n  ) {\n    if (credentialOrPipeline instanceof Pipeline) {\n      super(url, credentialOrPipeline);\n    } else {\n      let credential;\n      if (credentialOrPipeline === undefined) {\n        credential = new AnonymousCredential();\n      } else {\n        credential = credentialOrPipeline;\n      }\n\n      const pipeline = newPipeline(credential, options);\n      super(url, pipeline);\n    }\n\n    this.pathContextInternal = new Path(this.storageClientContext);\n    this.blockBlobClientInternal = new BlockBlobClient(this.blobEndpointUrl, this.pipeline);\n    this.pathContextInternalToBlobEndpoint = new Path(this.storageClientContextToBlobEndpoint);\n  }\n\n  /**\n   * Create a file.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param resourceType - Resource type, must be \"file\" for DataLakeFileClient.\n   * @param options - Optional. Options when creating file.\n   */\n  public async create(\n    resourceType: PathResourceTypeModel,\n    options?: PathCreateOptions\n  ): Promise<PathCreateResponse>;\n\n  /**\n   * Create a file.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param options - Optional. Options when creating file.\n   */\n  public async create(options?: FileCreateOptions): Promise<FileCreateResponse>;\n\n  public async create(\n    resourceTypeOrOptions?: PathResourceTypeModel | PathCreateOptions,\n    options: PathCreateOptions = {}\n  ): Promise<PathCreateResponse> {\n    if (resourceTypeOrOptions === \"file\") {\n      return super.create(resourceTypeOrOptions as PathResourceTypeModel, options);\n    }\n\n    if (resourceTypeOrOptions === \"directory\") {\n      throw TypeError(\n        `DataLakeFileClient:create() resourceType cannot be ${resourceTypeOrOptions}. Refer to DataLakeDirectoryClient for directory creation.`\n      );\n    }\n\n    options = resourceTypeOrOptions || {};\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-create\", options);\n    try {\n      return await super.create(\"file\", {\n        ...options,\n        tracingOptions: {\n          ...options.tracingOptions,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Create a file if it doesn't already exists.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param resourceType - Resource type, must be \"file\" for DataLakeFileClient.\n   * @param options -\n   */\n  public async createIfNotExists(\n    resourceType: PathResourceTypeModel,\n    options?: PathCreateIfNotExistsOptions\n  ): Promise<PathCreateIfNotExistsResponse>;\n\n  /**\n   * Create a file if it doesn't already exists.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/create\n   *\n   * @param options - Optional. Options when creating file.\n   */\n  public async createIfNotExists(\n    options?: FileCreateIfNotExistsOptions\n  ): Promise<FileCreateIfNotExistsResponse>;\n\n  public async createIfNotExists(\n    resourceTypeOrOptions?: PathResourceTypeModel | PathCreateOptions,\n    options: PathCreateIfNotExistsOptions = {}\n  ): Promise<PathCreateIfNotExistsResponse> {\n    if (resourceTypeOrOptions === \"directory\") {\n      throw TypeError(\n        `DataLakeFileClient:createIfNotExists() resourceType cannot be ${resourceTypeOrOptions}. Refer to DataLakeDirectoryClient for directory creation.`\n      );\n    }\n\n    if (resourceTypeOrOptions !== \"file\") {\n      options = resourceTypeOrOptions || {};\n    }\n\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-createIfNotExists\", options);\n    try {\n      return await super.createIfNotExists(\"file\", {\n        ...options,\n        tracingOptions: {\n          ...options.tracingOptions,\n          ...convertTracingToRequestOptionsBase(updatedOptions)\n        }\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Downloads a file from the service, including its metadata and properties.\n   *\n   * * In Node.js, data returns in a Readable stream readableStreamBody\n   * * In browsers, data returns in a promise contentAsBlob\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob\n   *\n   * * Example usage (Node.js):\n   *\n   * ```js\n   * // Download and convert a file to a string\n   * const downloadResponse = await fileClient.read();\n   * const downloaded = await streamToBuffer(downloadResponse.readableStreamBody);\n   * console.log(\"Downloaded file content:\", downloaded.toString());\n   *\n   * async function streamToBuffer(readableStream) {\n   *   return new Promise((resolve, reject) => {\n   *     const chunks = [];\n   *     readableStream.on(\"data\", (data) => {\n   *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n   *     });\n   *     readableStream.on(\"end\", () => {\n   *       resolve(Buffer.concat(chunks));\n   *     });\n   *     readableStream.on(\"error\", reject);\n   *   });\n   * }\n   * ```\n   *\n   * Example usage (browser):\n   *\n   * ```js\n   * // Download and convert a file to a string\n   * const downloadResponse = await fileClient.read();\n   * const downloaded = await blobToString(await downloadResponse.contentAsBlob);\n   * console.log(\"Downloaded file content\", downloaded);\n   *\n   * async function blobToString(blob: Blob): Promise<string> {\n   *   const fileReader = new FileReader();\n   *   return new Promise<string>((resolve, reject) => {\n   *     fileReader.onloadend = (ev: any) => {\n   *       resolve(ev.target!.result);\n   *     };\n   *     fileReader.onerror = reject;\n   *     fileReader.readAsText(blob);\n   *   });\n   * }\n   * ```\n   *\n   * @param offset - Optional. Offset to read file, default value is 0.\n   * @param count - Optional. How many bytes to read, default will read from offset to the end.\n   * @param options - Optional. Options when reading file.\n   */\n  public async read(\n    offset: number = 0,\n    count?: number,\n    options: FileReadOptions = {}\n  ): Promise<FileReadResponse> {\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-read\", options);\n    try {\n      const rawResponse = await this.blockBlobClientInternal.download(\n        offset,\n        count,\n        updatedOptions\n      );\n\n      const response = rawResponse as FileReadResponse;\n      if (!isNode && !response.contentAsBlob) {\n        response.contentAsBlob = rawResponse.blobBody;\n      }\n      response.fileContentMD5 = rawResponse.blobContentMD5;\n      response._response.parsedHeaders.fileContentMD5 =\n        rawResponse._response.parsedHeaders.blobContentMD5;\n      delete rawResponse.blobContentMD5;\n      delete rawResponse._response.parsedHeaders.blobContentMD5;\n\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Uploads data to be appended to a file. Data can only be appended to a file.\n   * To apply perviously uploaded data to a file, call flush.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update\n   *\n   * @param body - Content to be uploaded.\n   * @param offset - Append offset in bytes.\n   * @param length - Length of content to append in bytes.\n   * @param options - Optional. Options when appending data.\n   */\n  public async append(\n    body: HttpRequestBody,\n    offset: number,\n    length: number,\n    options: FileAppendOptions = {}\n  ): Promise<FileAppendResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-append\", options);\n    try {\n      return await this.pathContextInternal.appendData(body, {\n        pathHttpHeaders: {\n          contentMD5: options.transactionalContentMD5\n        },\n        abortSignal: options.abortSignal,\n        position: offset,\n        contentLength: length,\n        leaseAccessConditions: options.conditions,\n        requestOptions: {\n          onUploadProgress: options.onProgress\n        },\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Flushes (writes) previously appended data to a file.\n   *\n   * @param position - File position to flush.\n   *                          This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.\n   *                          It is required when uploading data to be appended to the file and when flushing previously uploaded data to the file.\n   *                          The value must be the position where the data is to be appended. Uploaded data is not immediately flushed, or written,\n   *                          to the file. To flush, the previously uploaded data must be contiguous, the position parameter must be specified and\n   *                          equal to the length of the file after all data has been written, and there must not be a request entity body included\n   *                          with the request.\n   * @param options - Optional. Options when flushing data.\n   */\n  public async flush(position: number, options: FileFlushOptions = {}): Promise<FileFlushResponse> {\n    options.conditions = options.conditions || {};\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-flush\", options);\n    try {\n      return await this.pathContextInternal.flushData({\n        ...options,\n        position,\n        contentLength: 0,\n        leaseAccessConditions: options.conditions,\n        modifiedAccessConditions: options.conditions,\n        ...convertTracingToRequestOptionsBase(updatedOptions)\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  // high level functions\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Uploads a local file to a Data Lake file.\n   *\n   * @param filePath - Full path of the local file\n   * @param options -\n   */\n  public async uploadFile(\n    filePath: string,\n    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options: FileParallelUploadOptions = {}\n  ): Promise<FileUploadResponse> {\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-uploadFile\", options);\n    try {\n      const size = (await fsStat(filePath)).size;\n      return await this.uploadSeekableInternal(\n        (offset: number, contentSize: number) => {\n          return () =>\n            fsCreateReadStream(filePath, {\n              autoClose: true,\n              end: offset + contentSize - 1,\n              start: offset\n            });\n        },\n        size,\n        updatedOptions\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Uploads a Buffer(Node.js)/Blob/ArrayBuffer/ArrayBufferView to a File.\n   *\n   * @param data - Buffer(Node), Blob, ArrayBuffer or ArrayBufferView\n   * @param options -\n   */\n  public async upload(\n    data: Buffer | Blob | ArrayBuffer | ArrayBufferView,\n    options: FileParallelUploadOptions = {}\n  ): Promise<FileUploadResponse> {\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-upload\", options);\n    try {\n      if (isNode) {\n        let buffer: Buffer;\n        if (data instanceof Buffer) {\n          buffer = data;\n        } else if (data instanceof ArrayBuffer) {\n          buffer = Buffer.from(data);\n        } else {\n          data = data as ArrayBufferView;\n          buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n        }\n\n        return this.uploadSeekableInternal(\n          (offset: number, size: number): Buffer => buffer.slice(offset, offset + size),\n          buffer.length,\n          updatedOptions\n        );\n      } else {\n        const browserBlob = new Blob([data]);\n        return this.uploadSeekableInternal(\n          (offset: number, size: number): Blob => browserBlob.slice(offset, offset + size),\n          browserBlob.size,\n          updatedOptions\n        );\n      }\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async uploadSeekableInternal(\n    bodyFactory: (offset: number, count: number) => HttpRequestBody,\n    size: number,\n    options: FileParallelUploadOptions = {}\n  ): Promise<FileUploadResponse> {\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-uploadData\", options);\n    try {\n      if (size > FILE_MAX_SIZE_BYTES) {\n        throw new RangeError(`size must be <= ${FILE_MAX_SIZE_BYTES}.`);\n      }\n\n      // Create the file.\n      const createRes = this.create({\n        abortSignal: options.abortSignal,\n        metadata: options.metadata,\n        permissions: options.permissions,\n        umask: options.umask,\n        conditions: options.conditions,\n        pathHttpHeaders: options.pathHttpHeaders,\n        tracingOptions: updatedOptions.tracingOptions\n      });\n      // append() with empty data would return error, so do not continue\n      if (size === 0) {\n        return await createRes;\n      } else {\n        await createRes;\n      }\n\n      // After the File is Create, Lease ID is the only valid request parameter.\n      options.conditions = { leaseId: options.conditions?.leaseId };\n\n      if (!options.chunkSize) {\n        options.chunkSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);\n        if (options.chunkSize < FILE_UPLOAD_DEFAULT_CHUNK_SIZE) {\n          options.chunkSize = FILE_UPLOAD_DEFAULT_CHUNK_SIZE;\n        }\n      }\n      if (options.chunkSize < 1 || options.chunkSize > FILE_UPLOAD_MAX_CHUNK_SIZE) {\n        throw new RangeError(`chunkSize option must be >= 1 and <= ${FILE_UPLOAD_MAX_CHUNK_SIZE}`);\n      }\n\n      if (!options.maxConcurrency) {\n        options.maxConcurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;\n      }\n      if (options.maxConcurrency <= 0) {\n        throw new RangeError(`maxConcurrency must be > 0.`);\n      }\n\n      if (!options.singleUploadThreshold) {\n        options.singleUploadThreshold = FILE_MAX_SINGLE_UPLOAD_THRESHOLD;\n      }\n      if (\n        options.singleUploadThreshold < 1 ||\n        options.singleUploadThreshold > FILE_MAX_SINGLE_UPLOAD_THRESHOLD\n      ) {\n        throw new RangeError(\n          `singleUploadThreshold option must be >= 1 and <= ${FILE_MAX_SINGLE_UPLOAD_THRESHOLD}`\n        );\n      }\n\n      // When buffer length <= singleUploadThreshold, this method will use one append/flush call to finish the upload.\n      if (size <= options.singleUploadThreshold) {\n        await this.append(bodyFactory(0, size), 0, size, {\n          abortSignal: options.abortSignal,\n          conditions: options.conditions,\n          onProgress: options.onProgress,\n          tracingOptions: updatedOptions.tracingOptions\n        });\n\n        return await this.flush(size, {\n          abortSignal: options.abortSignal,\n          conditions: options.conditions,\n          close: options.close,\n          pathHttpHeaders: options.pathHttpHeaders,\n          tracingOptions: updatedOptions.tracingOptions\n        });\n      }\n\n      const numBlocks: number = Math.floor((size - 1) / options.chunkSize) + 1;\n      if (numBlocks > BLOCK_BLOB_MAX_BLOCKS) {\n        throw new RangeError(\n          `The data's size is too big or the chunkSize is too small;` +\n            `the number of chunks must be <= ${BLOCK_BLOB_MAX_BLOCKS}`\n        );\n      }\n\n      let transferProgress: number = 0;\n      const batch = new Batch(options.maxConcurrency);\n\n      for (let i = 0; i < numBlocks; i++) {\n        batch.addOperation(\n          async (): Promise<any> => {\n            const start = options.chunkSize! * i;\n            const end = i === numBlocks - 1 ? size : start + options.chunkSize!;\n            const contentLength = end - start;\n            await this.append(bodyFactory(start, contentLength), start, contentLength, {\n              abortSignal: options.abortSignal,\n              conditions: options.conditions,\n              tracingOptions: updatedOptions.tracingOptions\n            });\n\n            transferProgress += contentLength;\n            if (options.onProgress) {\n              options.onProgress({ loadedBytes: transferProgress });\n            }\n          }\n        );\n      }\n      await batch.do();\n\n      return await this.flush(size, {\n        abortSignal: options.abortSignal,\n        conditions: options.conditions,\n        close: options.close,\n        pathHttpHeaders: options.pathHttpHeaders,\n        tracingOptions: updatedOptions.tracingOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Uploads a Node.js Readable stream into a Data Lake file.\n   * This method will try to create a file, then starts uploading chunk by chunk.\n   * Please make sure potential size of stream doesn't exceed FILE_MAX_SIZE_BYTES and\n   * potential number of chunks doesn't exceed BLOCK_BLOB_MAX_BLOCKS.\n   *\n   * PERFORMANCE IMPROVEMENT TIPS:\n   * * Input stream highWaterMark is better to set a same value with options.chunkSize\n   *   parameter, which will avoid Buffer.concat() operations.\n   *\n   * @param stream - Node.js Readable stream.\n   * @param options -\n   */\n  public async uploadStream(\n    stream: Readable,\n    options: FileParallelUploadOptions = {}\n  ): Promise<FileUploadResponse> {\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-uploadStream\", options);\n    try {\n      // Create the file\n      await this.create({\n        abortSignal: options.abortSignal,\n        metadata: options.metadata,\n        permissions: options.permissions,\n        umask: options.umask,\n        conditions: options.conditions,\n        pathHttpHeaders: options.pathHttpHeaders,\n        tracingOptions: updatedOptions.tracingOptions\n      });\n\n      // After the File is Create, Lease ID is the only valid request parameter.\n      options.conditions = { leaseId: options.conditions?.leaseId };\n\n      if (!options.chunkSize) {\n        options.chunkSize = FILE_UPLOAD_DEFAULT_CHUNK_SIZE;\n      }\n      if (options.chunkSize < 1 || options.chunkSize > FILE_UPLOAD_MAX_CHUNK_SIZE) {\n        throw new RangeError(`chunkSize option must be >= 1 and <= ${FILE_UPLOAD_MAX_CHUNK_SIZE}`);\n      }\n      if (!options.maxConcurrency) {\n        options.maxConcurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;\n      }\n      if (options.maxConcurrency <= 0) {\n        throw new RangeError(`maxConcurrency must be > 0.`);\n      }\n\n      let transferProgress: number = 0;\n      const scheduler = new BufferScheduler(\n        stream,\n        options.chunkSize,\n        options.maxConcurrency,\n        async (body, length, offset) => {\n          await this.append(body, offset!, length, {\n            abortSignal: options.abortSignal,\n            conditions: options.conditions,\n            tracingOptions: updatedOptions.tracingOptions\n          });\n\n          // Update progress after block is successfully uploaded to server, in case of block trying\n          transferProgress += length;\n          if (options.onProgress) {\n            options.onProgress({ loadedBytes: transferProgress });\n          }\n        },\n        // concurrency should set a smaller value than maxConcurrency, which is helpful to\n        // reduce the possibility when a outgoing handler waits for stream data, in\n        // this situation, outgoing handlers are blocked.\n        // Outgoing queue shouldn't be empty.\n        Math.ceil((options.maxConcurrency / 4) * 3)\n      );\n      await scheduler.do();\n\n      return await this.flush(transferProgress, {\n        abortSignal: options.abortSignal,\n        conditions: options.conditions,\n        close: options.close,\n        pathHttpHeaders: options.pathHttpHeaders,\n        tracingOptions: updatedOptions.tracingOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Reads a Data Lake file in parallel to a buffer.\n   * Offset and count are optional, pass 0 for both to read the entire file.\n   *\n   * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two\n   * gigabytes on 64-bit systems due to limitations of Node.js/V8. For files larger than this size,\n   * consider {@link readToFile}.\n   *\n   * @param buffer - Buffer to be fill, must have length larger than count\n   * @param offset - From which position of the Data Lake file to read\n   * @param count - How much data to be read. Will read to the end when passing undefined\n   * @param options -\n   */\n  public async readToBuffer(\n    buffer: Buffer,\n    offset?: number,\n    count?: number,\n    options?: FileReadToBufferOptions\n  ): Promise<Buffer>;\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME\n   *\n   * Reads a Data Lake file in parallel to a buffer.\n   * Offset and count are optional, pass 0 for both to read the entire file\n   *\n   * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two\n   * gigabytes on 64-bit systems due to limitations of Node.js/V8. For files larger than this size,\n   * consider {@link readToFile}.\n   *\n   * @param offset - From which position of the Data Lake file to read(in bytes)\n   * @param count - How much data(in bytes) to be read. Will read to the end when passing undefined\n   * @param options -\n   */\n  public async readToBuffer(\n    offset?: number,\n    count?: number,\n    options?: FileReadToBufferOptions\n  ): Promise<Buffer>;\n\n  public async readToBuffer(\n    bufferOrOffset?: Buffer | number,\n    offsetOrCount?: number,\n    countOrOptions?: FileReadToBufferOptions | number,\n    optOptions: FileReadToBufferOptions = {}\n  ): Promise<Buffer> {\n    let buffer: Buffer | undefined = undefined;\n    let offset = 0;\n    let count = 0;\n    let options = optOptions;\n    if (bufferOrOffset instanceof Buffer) {\n      buffer = bufferOrOffset;\n      offset = offsetOrCount || 0;\n      count = typeof countOrOptions === \"number\" ? countOrOptions : 0;\n    } else {\n      offset = typeof bufferOrOffset === \"number\" ? bufferOrOffset : 0;\n      count = typeof offsetOrCount === \"number\" ? offsetOrCount : 0;\n      options = (countOrOptions as FileReadToBufferOptions) || {};\n    }\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-readToBuffer\", options);\n    try {\n      if (buffer) {\n        return await this.blockBlobClientInternal.downloadToBuffer(buffer, offset, count, {\n          ...options,\n          maxRetryRequestsPerBlock: options.maxRetryRequestsPerChunk,\n          blockSize: options.chunkSize,\n          tracingOptions: updatedOptions.tracingOptions\n        });\n      } else {\n        return await this.blockBlobClientInternal.downloadToBuffer(offset, count, {\n          ...options,\n          maxRetryRequestsPerBlock: options.maxRetryRequestsPerChunk,\n          blockSize: options.chunkSize,\n          tracingOptions: updatedOptions.tracingOptions\n        });\n      }\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Downloads a Data Lake file to a local file.\n   * Fails if the the given file path already exits.\n   * Offset and count are optional, pass 0 and undefined respectively to download the entire file.\n   *\n   * @param filePath -\n   * @param offset - From which position of the file to download.\n   * @param count - How much data to be downloaded. Will download to the end when passing undefined.\n   * @param options - Options to read Data Lake file.\n   * @returns The response data for file read operation,\n   *                                      but with readableStreamBody set to undefined since its\n   *                                      content is already read and written into a local file\n   *                                      at the specified path.\n   */\n  public async readToFile(\n    filePath: string,\n    offset: number = 0,\n    count?: number,\n    options: FileReadOptions = {}\n  ): Promise<FileReadResponse> {\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-readToFile\", options);\n    try {\n      return await this.blockBlobClientInternal.downloadToFile(\n        filePath,\n        offset,\n        count,\n        updatedOptions\n      );\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Quick query for a JSON or CSV formatted file.\n   *\n   * Example usage (Node.js):\n   *\n   * ```js\n   * // Query and convert a file to a string\n   * const queryResponse = await fileClient.query(\"select * from BlobStorage\");\n   * const downloaded = (await streamToBuffer(queryResponse.readableStreamBody)).toString();\n   * console.log(\"Query file content:\", downloaded);\n   *\n   * async function streamToBuffer(readableStream) {\n   *   return new Promise((resolve, reject) => {\n   *     const chunks = [];\n   *     readableStream.on(\"data\", (data) => {\n   *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n   *     });\n   *     readableStream.on(\"end\", () => {\n   *       resolve(Buffer.concat(chunks));\n   *     });\n   *     readableStream.on(\"error\", reject);\n   *   });\n   * }\n   * ```\n   *\n   * @param query -\n   * @param options -\n   */\n  public async query(query: string, options: FileQueryOptions = {}): Promise<FileReadResponse> {\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-query\", options);\n\n    try {\n      const rawResponse = await this.blockBlobClientInternal.query(query, updatedOptions);\n      const response = rawResponse as FileReadResponse;\n      if (!isNode && !response.contentAsBlob) {\n        response.contentAsBlob = rawResponse.blobBody;\n      }\n      response.fileContentMD5 = rawResponse.blobContentMD5;\n      response._response.parsedHeaders.fileContentMD5 =\n        rawResponse._response.parsedHeaders.blobContentMD5;\n      delete rawResponse.blobContentMD5;\n      delete rawResponse._response.parsedHeaders.blobContentMD5;\n      return response;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets an expiry time on a file, once that time is met the file is deleted.\n   *\n   * @param mode -\n   * @param options -\n   */\n  public async setExpiry(\n    mode: FileExpiryMode,\n    options: FileSetExpiryOptions = {}\n  ): Promise<FileSetExpiryResponse> {\n    const { span, updatedOptions } = createSpan(\"DataLakeFileClient-setExpiry\", options);\n    try {\n      let expiresOn: string | undefined = undefined;\n      if (mode === \"RelativeToNow\" || mode === \"RelativeToCreation\") {\n        if (!options.timeToExpireInMs) {\n          throw new Error(`Should specify options.timeToExpireInMs when using mode ${mode}.`);\n        }\n        // MINOR: need check against <= 2**64, but JS number has the precision problem.\n        expiresOn = Math.round(options.timeToExpireInMs).toString();\n      }\n\n      if (mode === \"Absolute\") {\n        if (!options.expiresOn) {\n          throw new Error(`Should specify options.expiresOn when using mode ${mode}.`);\n        }\n        const now = new Date();\n        if (!(options.expiresOn!.getTime() > now.getTime())) {\n          throw new Error(\n            `options.expiresOn should be later than now: ${now.toUTCString()} when using mode ${mode}, but is ${options.expiresOn?.toUTCString()}`\n          );\n        }\n        expiresOn = options.expiresOn!.toUTCString();\n      }\n\n      const adaptedOptions = { ...options, expiresOn };\n      return await this.pathContextInternalToBlobEndpoint.setExpiry(mode, {\n        ...adaptedOptions,\n        tracingOptions: updatedOptions.tracingOptions\n      });\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Only available for clients constructed with a shared key credential.\n   *\n   * Generates a Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateSasUrl(options: FileGenerateSasUrlOptions): Promise<string> {\n    return new Promise((resolve) => {\n      if (!(this.credential instanceof StorageSharedKeyCredential)) {\n        throw RangeError(\n          \"Can only generate the SAS when the client is initialized with a shared key credential\"\n        );\n      }\n\n      const sas = generateDataLakeSASQueryParameters(\n        {\n          fileSystemName: this.fileSystemName,\n          pathName: this.name,\n          ...options\n        },\n        this.credential\n      ).toString();\n\n      resolve(appendToURLQuery(this.url, sas));\n    });\n  }\n}\n"]}