import { __awaiter } from 'tslib';
import { Injectable, Optional } from '@angular/core';

/**
 * No easing, no acceleration
 */
function linear(t) {
    return t;
}
/**
 * Accelerating from zero velocity
 */
function easeInQuad(t) {
    return t * t;
}
/**
 * Decelerating to zero velocity
 */
function easeOutQuad(t) {
    return t * (2 - t);
}
/**
 * Acceleration until halfway, then deceleration
 */
function easeInOutQuad(t) {
    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}
/**
 * Accelerating from zero velocity
 */
function easeInCubic(t) {
    return t * t * t;
}
/**
 * Decelerating to zero velocity
 */
function easeOutCubic(t) {
    return (--t) * t * t + 1;
}
/**
 * Acceleration until halfway, then deceleration
 */
function easeInOutCubic(t) {
    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
}
/**
 * Accelerating from zero velocity
 */
function easeInQuart(t) {
    return t * t * t * t;
}
/**
 * Decelerating to zero velocity
 */
function easeOutQuart(t) {
    return 1 - (--t) * t * t * t;
}
/**
 * Acceleration until halfway, then deceleration
 */
function easeInOutQuart(t) {
    return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t;
}
/**
 * Accelerating from zero velocity
 */
function easeInQuint(t) {
    return t * t * t * t * t;
}
/**
 * Decelerating to zero velocity
 */
function easeOutQuint(t) {
    return 1 + (--t) * t * t * t * t;
}
/**
 * Acceleration until halfway, then deceleration
 */
function easeInOutQuint(t) {
    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;
}

var easing_function = /*#__PURE__*/Object.freeze({
    __proto__: null,
    linear: linear,
    easeInQuad: easeInQuad,
    easeOutQuad: easeOutQuad,
    easeInOutQuad: easeInOutQuad,
    easeInCubic: easeInCubic,
    easeOutCubic: easeOutCubic,
    easeInOutCubic: easeInOutCubic,
    easeInQuart: easeInQuart,
    easeOutQuart: easeOutQuart,
    easeInOutQuart: easeInOutQuart,
    easeInQuint: easeInQuint,
    easeOutQuint: easeOutQuint,
    easeInOutQuint: easeInOutQuint
});

class InvalidTriggerRegisterError extends Error {
    constructor() {
        super('Could not find triggers registered in the transition.');
    }
}
class TransitionService {
    constructor(triggers) {
        this.triggers = triggers;
    }
    /**
     * animate
     */
    animate(triggerName, from, to, param) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!Array.isArray(this.triggers)) {
                return Promise.reject(new InvalidTriggerRegisterError());
            }
            const trigger = this.triggers.find(trig => trig.name === triggerName);
            if (!trigger) {
                console.warn(`Trigger ${triggerName} is not defined.`);
                return Promise.resolve();
            }
            const transition = trigger.transitions.find(trans => trans.validate(from, to));
            if (!transition) {
                console.warn(`Transition ${from} => ${to} is not defined`);
                return Promise.resolve();
            }
            if (!requestAnimationFrame) {
                // requestAnimationFrame API is not available in current browser.
                // https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
                transition.steps.forEach(step => step(1, param));
                return Promise.resolve();
            }
            return Promise.all(transition.steps.map(render => new Promise((resolve) => {
                const start = Date.now();
                (function loop() {
                    const p = (Date.now() - start) / transition.duration;
                    if (p > 1) {
                        render(1, param);
                        resolve(render);
                    }
                    else {
                        requestAnimationFrame(loop);
                        render(transition.easing(p), param);
                    }
                })();
            })));
        });
    }
}
TransitionService.decorators = [
    { type: Injectable }
];
TransitionService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }] }
];

class Transition {
    constructor(validate) {
        this.validate = validate;
        this.steps = [];
        this.duration = 1;
        this.easing = () => null;
    }
}

class Trigger {
    constructor(name) {
        this.name = name;
        this.transitions = [];
    }
}

function trigger(name, definition) {
    const result = new Trigger(name);
    definition.forEach(def => def(result));
    return result;
}
function transition(stateChangeExpr, steps) {
    const transResult = new Transition(stateChangeExpr);
    steps.forEach(stepDef => stepDef(transResult));
    return (trig) => {
        trig.transitions.push(transResult);
    };
}
function render(state) {
    return (trans) => {
        trans.steps.push(state);
    };
}
function animate(duration, easing) {
    return (trans) => {
        trans.duration = duration;
        trans.easing = easing;
    };
}

/*
 * Public API Surface of transition
 */

/**
 * Generated bundle index. Do not edit.
 */

export { easing_function as Easing, InvalidTriggerRegisterError, TransitionService, animate, render, transition, trigger, Trigger as Éµa };
//# sourceMappingURL=ngld-transition.js.map
