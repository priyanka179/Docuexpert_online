import { EventEmitter, Directive, ElementRef, Inject, Input, Output, HostListener, NgModule } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { normalizePassiveListenerOptions } from '@angular/cdk/platform';

const activeCapturingEventOptions = normalizePassiveListenerOptions({
    passive: false,
    capture: true,
});
function isTouch(event) {
    return !!event.targetTouches;
}
function getCoordinate(event, clientRect) {
    if (isTouch(event)) {
        return {
            x: event.targetTouches[0].clientX,
            y: event.targetTouches[1].clientY,
        };
    }
    return {
        x: event.clientX - clientRect.left,
        y: event.clientY - clientRect.top,
    };
}
class PanZoomDirective {
    constructor(el, 
    // Avoid ngcc error:
    // https://github.com/angular/components/blob/2b1d84e2bc1d7295e53a753211e99a0e73110b45/src/cdk/drag-drop/drag-drop-registry.ts#L64
    $document) {
        this.el = el;
        this.pointerOrigin = { x: 0, y: 0 };
        this.isPointerDown = false;
        this.previousViewBox = {
            minX: 0, minY: 0, width: 500, height: 500,
        };
        this.excludeChildrenElements = [];
        this.viewBox = {
            minX: 0, minY: 0, width: 500, height: 500,
        };
        this.scaleFactor = 1.3;
        this.viewBoxChanged = new EventEmitter();
        this.pointerDownListener = (event) => {
            if (!this.el.nativeElement.contains(event.target)) {
                return;
            }
            if (this.excludeChildrenElements.find(c => c.checkExclusion(event.target))) {
                this.isPointerDown = false;
                return;
            }
            this.isPointerDown = true;
            this.pointerOrigin = getCoordinate(event, { top: 0, left: 0 });
            this.previousViewBox = Object.assign({}, this.viewBox);
            this.boundingSize = undefined;
        };
        this.pointerUpListener = (event) => {
            this.isPointerDown = false;
            this.previousViewBox = undefined;
        };
        this.pointerMoveListener = (event) => {
            if (!this.isPointerDown) {
                return;
            }
            if (!this.boundingSize) {
                this.boundingSize = this.el.nativeElement.getBoundingClientRect();
            }
            // Prevent user to do a selection on the page
            event.preventDefault();
            // Get the current pointer position
            const pointerPosition = getCoordinate(event, { top: 0, left: 0 });
            const ratio = this.previousViewBox.width / this.boundingSize.width;
            const newViewBox = {
                minX: this.previousViewBox.minX - ((pointerPosition.x - this.pointerOrigin.x) * ratio),
                minY: this.previousViewBox.minY - ((pointerPosition.y - this.pointerOrigin.y) * ratio)
            };
            this.viewBoxChanged.emit(Object.assign(Object.assign({}, this.viewBox), newViewBox));
        };
        this.document = $document;
    }
    ngOnInit() {
        this.document.addEventListener('touchstart', this.pointerDownListener, activeCapturingEventOptions);
        this.document.addEventListener('mousedown', this.pointerDownListener, activeCapturingEventOptions);
        this.document.addEventListener('pointerdown', this.pointerDownListener, activeCapturingEventOptions);
        this.document.addEventListener('touchend', this.pointerUpListener, activeCapturingEventOptions);
        this.document.addEventListener('mouseup', this.pointerUpListener, activeCapturingEventOptions);
        this.document.addEventListener('pointerup', this.pointerUpListener, activeCapturingEventOptions);
        this.document.addEventListener('touchmove', this.pointerMoveListener, activeCapturingEventOptions);
        this.document.addEventListener('mousemove', this.pointerMoveListener, activeCapturingEventOptions);
        this.document.addEventListener('pointermove', this.pointerMoveListener, activeCapturingEventOptions);
    }
    ngOnDestroy() {
        this.document.removeEventListener('touchstart', this.pointerDownListener, activeCapturingEventOptions);
        this.document.removeEventListener('mousedown', this.pointerDownListener, activeCapturingEventOptions);
        this.document.removeEventListener('pointerdown', this.pointerDownListener, activeCapturingEventOptions);
        this.document.removeEventListener('touchend', this.pointerUpListener, activeCapturingEventOptions);
        this.document.removeEventListener('mouseup', this.pointerUpListener, activeCapturingEventOptions);
        this.document.removeEventListener('pointerup', this.pointerUpListener, activeCapturingEventOptions);
        this.document.removeEventListener('touchmove', this.pointerMoveListener, activeCapturingEventOptions);
        this.document.removeEventListener('mousemove', this.pointerMoveListener, activeCapturingEventOptions);
        this.document.removeEventListener('pointermove', this.pointerMoveListener, activeCapturingEventOptions);
    }
    /**
     * excludeChild
     */
    excludeChild(component) {
        this.excludeChildrenElements.push(component);
    }
    /**
     * onExcludeDestroyed
     */
    onExcludeDestroyed(component) {
        this.excludeChildrenElements = this.excludeChildrenElements
            .filter(c => c !== component);
    }
    onZoom(e) {
        e.preventDefault();
        const position = getCoordinate(e, this.el.nativeElement.getBoundingClientRect());
        const scale = Math.pow(this.scaleFactor, e.deltaY < 0 ? 1 : -1);
        const sx = position.x / this.el.nativeElement.clientWidth;
        const sy = position.y / this.el.nativeElement.clientHeight;
        const x = this.viewBox.minX + this.viewBox.width * sx;
        const y = this.viewBox.minY + this.viewBox.height * sy;
        this.viewBoxChanged.emit({
            minX: x + scale * (this.viewBox.minX - x),
            minY: y + scale * (this.viewBox.minY - y),
            width: this.viewBox.width * scale,
            height: this.viewBox.height * scale,
        });
    }
}
PanZoomDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngldPanZoom]'
            },] }
];
PanZoomDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
PanZoomDirective.propDecorators = {
    viewBox: [{ type: Input }],
    scaleFactor: [{ type: Input }],
    viewBoxChanged: [{ type: Output }],
    onZoom: [{ type: HostListener, args: ['wheel', ['$event'],] }]
};

class PanZoomExcludeDirective {
    constructor(el, parentCanvas) {
        this.el = el;
        this.parentCanvas = parentCanvas;
    }
    /**
     * checkExclusion
     */
    checkExclusion(target) {
        return this.el.nativeElement.contains(target);
    }
    ngOnDestroy() {
        this.parentCanvas.onExcludeDestroyed(this);
    }
    ngOnInit() {
        this.parentCanvas.excludeChild(this);
    }
}
PanZoomExcludeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngldPanZoomExclude]'
            },] }
];
PanZoomExcludeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: PanZoomDirective }
];

class PanZoomDirectiveModule {
}
PanZoomDirectiveModule.decorators = [
    { type: NgModule, args: [{
                declarations: [PanZoomDirective, PanZoomExcludeDirective],
                imports: [],
                exports: [PanZoomDirective, PanZoomExcludeDirective]
            },] }
];

/*
 * Public API Surface of pan-zoom-directive
 */

/**
 * Generated bundle index. Do not edit.
 */

export { PanZoomDirective, PanZoomDirectiveModule, PanZoomExcludeDirective };
//# sourceMappingURL=ngld-pan-zoom.js.map
