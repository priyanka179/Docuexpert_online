import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Optional, Inject, ErrorHandler, Component, ElementRef, Attribute, Input, NgModule } from '@angular/core';
import { MatIconRegistry, MAT_ICON_LOCATION } from '@angular/material/icon';
import { of, Subscription } from 'rxjs';
import { take } from 'rxjs/operators';
import * as i3 from '@angular/common';
import { DOCUMENT } from '@angular/common';
import * as i1 from '@angular/common/http';
import { HttpClient } from '@angular/common/http';
import * as i2 from '@angular/platform-browser';
import { DomSanitizer } from '@angular/platform-browser';

const SVG_ICONS = new InjectionToken('SvgIcons');
/**
 * An exception to be thrown when the consumer attempts to use `<ngld-icon>`
 * without including @angular/common/http.
 */
class SvgIconNoHttpProviderError extends Error {
    constructor() {
        super('Could not find HttpClient provider for use with Angular Material icons.'
            + 'Please include the HttpClientModule from @angular/common/http in your '
            + 'app imports.');
    }
}
const DEFAULT_NS = '$$default';
/**
 * https://github.com/angular/angular/blob/f8096d499324cf0961f092944bbaedd05364eea1/aio/src/app/shared/custom-icon-registry.ts
 */
class SvgIconRegistry extends MatIconRegistry {
    constructor(http, sanitizer, document, errorHandler, svgIcons) {
        super(http, sanitizer, document, errorHandler);
        this.http = http;
        this.svgIcons = svgIcons;
        this.cachedSvgElements = { [DEFAULT_NS]: {} };
        if (svgIcons == null) {
            this.svgIcons = [];
        }
    }
    /**
     * Returns an Observable that produces the icon (as an `<svg>` DOM element)
     * with the given name and namespace.
     * The icon must have been previously registered with addIcon or addIconSet;
     * if not, the observable will throw an error.
     */
    getNamedSvgIcon(iconName, namespace) {
        if (!this.http) {
            throw new SvgIconNoHttpProviderError();
        }
        const nsIconMap = this.cachedSvgElements[namespace || DEFAULT_NS];
        let preloadedElement = nsIconMap && nsIconMap[iconName];
        if (!preloadedElement) {
            preloadedElement = this.loadSvgElement(iconName, namespace);
        }
        return preloadedElement
            ? of(preloadedElement.cloneNode(true))
            : super.getNamedSvgIcon(iconName, namespace);
    }
    loadSvgElement(iconName, namespace) {
        const svgIcon = this.svgIcons.find(icon => {
            return namespace
                ? icon.name === iconName && icon.namespace === namespace
                : icon.name === iconName;
        });
        if (!svgIcon) {
            return;
        }
        const ns = svgIcon.namespace || DEFAULT_NS;
        const nsIconMap = this.cachedSvgElements[ns] || (this.cachedSvgElements[ns] = {});
        // Creating a new `<div>` per icon is necessary for the SVGs to work correctly in IE11.
        const div = document.createElement('DIV');
        // SECURITY: the source for the SVG icons is provided in code by trusted developers
        div.innerHTML = svgIcon.svgSource;
        const svgElement = div.querySelector('svg');
        nsIconMap[svgIcon.name] = svgElement;
        return svgElement;
    }
}
SvgIconRegistry.ɵprov = i0.ɵɵdefineInjectable({ factory: function SvgIconRegistry_Factory() { return new SvgIconRegistry(i0.ɵɵinject(i1.HttpClient, 8), i0.ɵɵinject(i2.DomSanitizer), i0.ɵɵinject(i3.DOCUMENT, 8), i0.ɵɵinject(i0.ErrorHandler), i0.ɵɵinject(SVG_ICONS, 8)); }, token: SvgIconRegistry, providedIn: "root" });
SvgIconRegistry.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
SvgIconRegistry.ctorParameters = () => [
    { type: HttpClient, decorators: [{ type: Optional }] },
    { type: DomSanitizer },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: ErrorHandler },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [SVG_ICONS,] }] }
];

/** SVG attributes that accept a FuncIRI (e.g. `url(<something>)`). */
const funcIriAttributes = [
    'clip-path',
    'color-profile',
    'src',
    'cursor',
    'fill',
    'filter',
    'marker',
    'marker-start',
    'marker-mid',
    'marker-end',
    'mask',
    'stroke'
];
const ɵ0 = attr => `[${attr}]`;
/** Selector that can be used to find all elements that are using a `FuncIRI`. */
const funcIriAttributeSelector = funcIriAttributes.map(ɵ0).join(', ');
/** Regex that can be used to extract the id out of a FuncIRI. */
const funcIriPattern = /^url\(['"]?#(.*?)['"]?\)$/;
/**
 * ngld-icon component
 * Greatly inspired by @angular/material icon component:
 * https://github.com/angular/components/blob/master/src/material/icon/icon.ts
 */
class IconComponent {
    constructor(elementRef, iconRegistry, ariaHidden, location, errorHandler) {
        this.elementRef = elementRef;
        this.iconRegistry = iconRegistry;
        this.location = location;
        this.errorHandler = errorHandler;
        /**
         * Subscription to the current in-progress SVG icon request.
         */
        this.currentIconFetch = Subscription.EMPTY;
        this.svgIcon = 'expand_node';
        // If the user has not explicitly set aria-hidden, mark the icon as hidden,
        // as this is the right thing to do for the majority of icon use-cases.
        if (!ariaHidden) {
            elementRef.nativeElement.setAttribute('aria-hidden', 'true');
        }
    }
    /**
     * the value given on svgIcon property is obtained from SimpleChanges event.
     */
    ngOnChanges(changes) {
        // Only update the inline SVG icon if the inputs changed,
        // to avoid unnecessary DOM operations.
        const svgIconChanges = changes.svgIcon;
        this.svgNamespace = null;
        this.svgName = null;
        if (svgIconChanges) {
            this.currentIconFetch.unsubscribe();
            if (this.svgIcon) {
                const [namespace, iconName] = this.splitIconName(this.svgIcon);
                if (namespace) {
                    this.svgNamespace = namespace;
                }
                if (iconName) {
                    this.svgName = iconName;
                }
                this.currentIconFetch = this.iconRegistry.getNamedSvgIcon(iconName, namespace)
                    .pipe(take(1))
                    .subscribe(svg => this.setSvgElement(svg), (err) => {
                    const errorMessage = `Error retrieving icon ${namespace}:${iconName} ! ${err.message}`;
                    this.errorHandler.handleError(new Error(errorMessage));
                });
            }
            else if (changes.previousValue) {
                this.clearSvgElement();
            }
        }
        // updateFontIconClasses when usingFontIcon
    }
    ngOnDestroy() {
        this.currentIconFetch.unsubscribe();
        if (this.elementsWithExternalReferences) {
            this.elementsWithExternalReferences.clear();
        }
    }
    splitIconName(iconName) {
        if (!iconName) {
            return ['', ''];
        }
        const parts = iconName.split(':');
        switch (parts.length) {
            case 1:
                return ['', parts[0]]; // Use default namespace.
            case 2:
                return parts;
            default:
                throw Error(`Invalid icon name: "${iconName}"`);
        }
    }
    setSvgElement(svg) {
        this.clearSvgElement();
        // Workaround for IE11 and Edge ignoring `style` tags inside dynamically-created SVGs.
        // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10898469/
        // Do this before inserting the element into the DOM,
        // in order to avoid a style recalculation.
        const styleTags = svg.querySelectorAll('style');
        styleTags.forEach(styleTag => styleTag.textContent += ' ');
        // Note: we do this fix here, rather than the icon registry,
        // because the references have to point to the URL at the time
        // that the icon was created.
        const path = this.location.getPathname();
        this.cacheChildrenWithExternalReferences(svg);
        this.elementRef.nativeElement.appendChild(svg);
    }
    clearSvgElement() {
        const layoutElement = this.elementRef.nativeElement;
        let childCount = layoutElement.childNodes.length;
        if (this.elementsWithExternalReferences) {
            this.elementsWithExternalReferences.clear();
        }
        // Remove existing non-element child nodes and SVGs,
        // and add the new SVG element. Note that we can't use innerHTML,
        // because IE will throw if the element has a data binding.
        // --> I'm not caring IE at present...
        while (childCount--) {
            const child = layoutElement.childNodes[childCount];
            // 1 corresponds to Node.ELEMENT_NODE.
            // We remove all non-element nodes in order to get rid of any loose text nodes,
            // as well as any SVG elements in order to remove any old icons.
            if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {
                layoutElement.removeChild(child);
            }
        }
    }
    /**
     * Caches the children of an SVG element that have `url()`
     * references that we need to prefix with the current path.
     */
    cacheChildrenWithExternalReferences(element) {
        const elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);
        const elements = this.elementsWithExternalReferences
            = this.elementsWithExternalReferences || new Map();
        elementsWithFuncIri.forEach(elementWithReference => {
            funcIriAttributes.forEach(attr => {
                const value = elementWithReference.getAttribute(attr);
                const match = value ? value.match(funcIriPattern) : null;
                if (match) {
                    let attributes = elements.get(elementWithReference);
                    if (!attributes) {
                        attributes = [];
                        elements.set(elementWithReference, attributes);
                    }
                    attributes.push({ name: attr, value: match[1] });
                }
            });
        });
    }
}
IconComponent.decorators = [
    { type: Component, args: [{
                selector: 'g[ngld-icon]',
                template: '<svg><text> Empty Icon </text></svg>'
            },] }
];
IconComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: SvgIconRegistry },
    { type: String, decorators: [{ type: Attribute, args: ['aria-hidden',] }] },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_ICON_LOCATION,] }] },
    { type: ErrorHandler }
];
IconComponent.propDecorators = {
    svgIcon: [{ type: Input }]
};

class SvgIconModule {
}
SvgIconModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IconComponent],
                imports: [],
                exports: [IconComponent]
            },] }
];

/*
 * Public API Surface of icon
 */

/**
 * Generated bundle index. Do not edit.
 */

export { IconComponent, SVG_ICONS, SvgIconModule, SvgIconNoHttpProviderError, SvgIconRegistry, ɵ0 };
//# sourceMappingURL=ngld-icon.js.map
