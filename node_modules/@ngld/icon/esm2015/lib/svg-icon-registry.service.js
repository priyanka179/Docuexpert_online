import { ErrorHandler, Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { HttpClient } from '@angular/common/http';
import { MatIconRegistry } from '@angular/material/icon';
import { DomSanitizer } from '@angular/platform-browser';
import { of } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "@angular/platform-browser";
import * as i3 from "@angular/common";
export const SVG_ICONS = new InjectionToken('SvgIcons');
/**
 * An exception to be thrown when the consumer attempts to use `<ngld-icon>`
 * without including @angular/common/http.
 */
export class SvgIconNoHttpProviderError extends Error {
    constructor() {
        super('Could not find HttpClient provider for use with Angular Material icons.'
            + 'Please include the HttpClientModule from @angular/common/http in your '
            + 'app imports.');
    }
}
const DEFAULT_NS = '$$default';
/**
 * https://github.com/angular/angular/blob/f8096d499324cf0961f092944bbaedd05364eea1/aio/src/app/shared/custom-icon-registry.ts
 */
export class SvgIconRegistry extends MatIconRegistry {
    constructor(http, sanitizer, document, errorHandler, svgIcons) {
        super(http, sanitizer, document, errorHandler);
        this.http = http;
        this.svgIcons = svgIcons;
        this.cachedSvgElements = { [DEFAULT_NS]: {} };
        if (svgIcons == null) {
            this.svgIcons = [];
        }
    }
    /**
     * Returns an Observable that produces the icon (as an `<svg>` DOM element)
     * with the given name and namespace.
     * The icon must have been previously registered with addIcon or addIconSet;
     * if not, the observable will throw an error.
     */
    getNamedSvgIcon(iconName, namespace) {
        if (!this.http) {
            throw new SvgIconNoHttpProviderError();
        }
        const nsIconMap = this.cachedSvgElements[namespace || DEFAULT_NS];
        let preloadedElement = nsIconMap && nsIconMap[iconName];
        if (!preloadedElement) {
            preloadedElement = this.loadSvgElement(iconName, namespace);
        }
        return preloadedElement
            ? of(preloadedElement.cloneNode(true))
            : super.getNamedSvgIcon(iconName, namespace);
    }
    loadSvgElement(iconName, namespace) {
        const svgIcon = this.svgIcons.find(icon => {
            return namespace
                ? icon.name === iconName && icon.namespace === namespace
                : icon.name === iconName;
        });
        if (!svgIcon) {
            return;
        }
        const ns = svgIcon.namespace || DEFAULT_NS;
        const nsIconMap = this.cachedSvgElements[ns] || (this.cachedSvgElements[ns] = {});
        // Creating a new `<div>` per icon is necessary for the SVGs to work correctly in IE11.
        const div = document.createElement('DIV');
        // SECURITY: the source for the SVG icons is provided in code by trusted developers
        div.innerHTML = svgIcon.svgSource;
        const svgElement = div.querySelector('svg');
        nsIconMap[svgIcon.name] = svgElement;
        return svgElement;
    }
}
SvgIconRegistry.ɵprov = i0.ɵɵdefineInjectable({ factory: function SvgIconRegistry_Factory() { return new SvgIconRegistry(i0.ɵɵinject(i1.HttpClient, 8), i0.ɵɵinject(i2.DomSanitizer), i0.ɵɵinject(i3.DOCUMENT, 8), i0.ɵɵinject(i0.ErrorHandler), i0.ɵɵinject(SVG_ICONS, 8)); }, token: SvgIconRegistry, providedIn: "root" });
SvgIconRegistry.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
SvgIconRegistry.ctorParameters = () => [
    { type: HttpClient, decorators: [{ type: Optional }] },
    { type: DomSanitizer },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: ErrorHandler },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [SVG_ICONS,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ZnLWljb24tcmVnaXN0cnkuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvc3ZnLWljb24tcmVnaXN0cnkuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDMUcsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDekQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3pELE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7Ozs7O0FBRXRDLE1BQU0sQ0FBQyxNQUFNLFNBQVMsR0FBRyxJQUFJLGNBQWMsQ0FBcUIsVUFBVSxDQUFDLENBQUM7QUFrQjVFOzs7R0FHRztBQUNILE1BQU0sT0FBTywwQkFBMkIsU0FBUSxLQUFLO0lBRW5EO1FBQ0UsS0FBSyxDQUFDLHlFQUF5RTtjQUMzRSx3RUFBd0U7Y0FDeEUsY0FBYyxDQUFDLENBQUM7SUFDdEIsQ0FBQztDQUNGO0FBRUQsTUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDO0FBRS9COztHQUVHO0FBRUgsTUFBTSxPQUFPLGVBQWdCLFNBQVEsZUFBZTtJQUlsRCxZQUNzQixJQUFnQixFQUNwQyxTQUF1QixFQUNPLFFBQWEsRUFDM0MsWUFBMEIsRUFDYSxRQUF1QjtRQUU5RCxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFOM0IsU0FBSSxHQUFKLElBQUksQ0FBWTtRQUlHLGFBQVEsR0FBUixRQUFRLENBQWU7UUFQeEQsc0JBQWlCLEdBQWUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDO1FBVTNELElBQUksUUFBUSxJQUFJLElBQUksRUFBRTtZQUNwQixJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztTQUNwQjtJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLGVBQWUsQ0FBQyxRQUFnQixFQUFFLFNBQWtCO1FBQ3pELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2QsTUFBTSxJQUFJLDBCQUEwQixFQUFFLENBQUM7U0FDeEM7UUFDRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxJQUFJLFVBQVUsQ0FBQyxDQUFDO1FBQ2xFLElBQUksZ0JBQWdCLEdBQTJCLFNBQVMsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEYsSUFBSSxDQUFDLGdCQUFnQixFQUFFO1lBQ3JCLGdCQUFnQixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1NBQzdEO1FBQ0QsT0FBTyxnQkFBZ0I7WUFDckIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFlLENBQUM7WUFDcEQsQ0FBQyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBRWpELENBQUM7SUFFTyxjQUFjLENBQUMsUUFBZ0IsRUFBRSxTQUFrQjtRQUN6RCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN4QyxPQUFPLFNBQVM7Z0JBQ2QsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssU0FBUztnQkFDeEQsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDO1FBQzdCLENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNaLE9BQU87U0FDUjtRQUVELE1BQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxTQUFTLElBQUksVUFBVSxDQUFDO1FBQzNDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUVsRix1RkFBdUY7UUFDdkYsTUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUUxQyxtRkFBbUY7UUFDbkYsR0FBRyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDO1FBRWxDLE1BQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxVQUFVLENBQUM7UUFFckMsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQzs7OztZQTlERixVQUFVLFNBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFOzs7WUF6Q3pCLFVBQVUsdUJBK0NkLFFBQVE7WUE3Q0osWUFBWTs0Q0ErQ2hCLFFBQVEsWUFBSSxNQUFNLFNBQUMsUUFBUTtZQW5EdkIsWUFBWTt3Q0FxRGhCLFFBQVEsWUFBSSxNQUFNLFNBQUMsU0FBUyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVycm9ySGFuZGxlciwgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgT3B0aW9uYWwsIFZhbHVlUHJvdmlkZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBNYXRJY29uUmVnaXN0cnkgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9pY29uJztcbmltcG9ydCB7IERvbVNhbml0aXplciB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcblxuZXhwb3J0IGNvbnN0IFNWR19JQ09OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxBcnJheTxTdmdJY29uSW5mbz4+KCdTdmdJY29ucycpO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN2Z0ljb25JbmZvUHJvdmlkZXIgZXh0ZW5kcyBWYWx1ZVByb3ZpZGVyIHtcbiAgdXNlVmFsdWU6IFN2Z0ljb25JbmZvO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN2Z0ljb25JbmZvIHtcbiAgbmFtZXNwYWNlPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHN2Z1NvdXJjZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU3ZnSWNvbk1hcCB7XG4gIFtuYW1lc3BhY2U6IHN0cmluZ106IHtcbiAgICBbaWNvbk5hbWU6IHN0cmluZ106IFNWR0VsZW1lbnQ7XG4gIH07XG59XG5cbi8qKlxuICogQW4gZXhjZXB0aW9uIHRvIGJlIHRocm93biB3aGVuIHRoZSBjb25zdW1lciBhdHRlbXB0cyB0byB1c2UgYDxuZ2xkLWljb24+YFxuICogd2l0aG91dCBpbmNsdWRpbmcgQGFuZ3VsYXIvY29tbW9uL2h0dHAuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdmdJY29uTm9IdHRwUHJvdmlkZXJFcnJvciBleHRlbmRzIEVycm9yIHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignQ291bGQgbm90IGZpbmQgSHR0cENsaWVudCBwcm92aWRlciBmb3IgdXNlIHdpdGggQW5ndWxhciBNYXRlcmlhbCBpY29ucy4nXG4gICAgICArICdQbGVhc2UgaW5jbHVkZSB0aGUgSHR0cENsaWVudE1vZHVsZSBmcm9tIEBhbmd1bGFyL2NvbW1vbi9odHRwIGluIHlvdXIgJ1xuICAgICAgKyAnYXBwIGltcG9ydHMuJyk7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9OUyA9ICckJGRlZmF1bHQnO1xuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi9mODA5NmQ0OTkzMjRjZjA5NjFmMDkyOTQ0YmJhZWRkMDUzNjRlZWExL2Fpby9zcmMvYXBwL3NoYXJlZC9jdXN0b20taWNvbi1yZWdpc3RyeS50c1xuICovXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIFN2Z0ljb25SZWdpc3RyeSBleHRlbmRzIE1hdEljb25SZWdpc3RyeSB7XG5cbiAgcHJpdmF0ZSBjYWNoZWRTdmdFbGVtZW50czogU3ZnSWNvbk1hcCA9IHsgW0RFRkFVTFRfTlNdOiB7fSB9O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgaHR0cDogSHR0cENsaWVudCxcbiAgICBzYW5pdGl6ZXI6IERvbVNhbml0aXplcixcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERPQ1VNRU5UKSBkb2N1bWVudDogYW55LFxuICAgIGVycm9ySGFuZGxlcjogRXJyb3JIYW5kbGVyLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoU1ZHX0lDT05TKSBwcml2YXRlIHN2Z0ljb25zOiBTdmdJY29uSW5mb1tdLFxuICApIHtcbiAgICBzdXBlcihodHRwLCBzYW5pdGl6ZXIsIGRvY3VtZW50LCBlcnJvckhhbmRsZXIpO1xuICAgIGlmIChzdmdJY29ucyA9PSBudWxsKSB7XG4gICAgICB0aGlzLnN2Z0ljb25zID0gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHByb2R1Y2VzIHRoZSBpY29uIChhcyBhbiBgPHN2Zz5gIERPTSBlbGVtZW50KVxuICAgKiB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCBuYW1lc3BhY2UuXG4gICAqIFRoZSBpY29uIG11c3QgaGF2ZSBiZWVuIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGFkZEljb24gb3IgYWRkSWNvblNldDtcbiAgICogaWYgbm90LCB0aGUgb2JzZXJ2YWJsZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGdldE5hbWVkU3ZnSWNvbihpY29uTmFtZTogc3RyaW5nLCBuYW1lc3BhY2U/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFNWR0VsZW1lbnQ+IHtcbiAgICBpZiAoIXRoaXMuaHR0cCkge1xuICAgICAgdGhyb3cgbmV3IFN2Z0ljb25Ob0h0dHBQcm92aWRlckVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IG5zSWNvbk1hcCA9IHRoaXMuY2FjaGVkU3ZnRWxlbWVudHNbbmFtZXNwYWNlIHx8IERFRkFVTFRfTlNdO1xuICAgIGxldCBwcmVsb2FkZWRFbGVtZW50OiBTVkdFbGVtZW50IHwgdW5kZWZpbmVkID0gbnNJY29uTWFwICYmIG5zSWNvbk1hcFtpY29uTmFtZV07XG4gICAgaWYgKCFwcmVsb2FkZWRFbGVtZW50KSB7XG4gICAgICBwcmVsb2FkZWRFbGVtZW50ID0gdGhpcy5sb2FkU3ZnRWxlbWVudChpY29uTmFtZSwgbmFtZXNwYWNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZWxvYWRlZEVsZW1lbnRcbiAgICAgID8gb2YocHJlbG9hZGVkRWxlbWVudC5jbG9uZU5vZGUodHJ1ZSkgYXMgU1ZHRWxlbWVudClcbiAgICAgIDogc3VwZXIuZ2V0TmFtZWRTdmdJY29uKGljb25OYW1lLCBuYW1lc3BhY2UpO1xuXG4gIH1cblxuICBwcml2YXRlIGxvYWRTdmdFbGVtZW50KGljb25OYW1lOiBzdHJpbmcsIG5hbWVzcGFjZT86IHN0cmluZyk6IFNWR0VsZW1lbnQgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHN2Z0ljb24gPSB0aGlzLnN2Z0ljb25zLmZpbmQoaWNvbiA9PiB7XG4gICAgICByZXR1cm4gbmFtZXNwYWNlXG4gICAgICAgID8gaWNvbi5uYW1lID09PSBpY29uTmFtZSAmJiBpY29uLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlXG4gICAgICAgIDogaWNvbi5uYW1lID09PSBpY29uTmFtZTtcbiAgICB9KTtcbiAgICBpZiAoIXN2Z0ljb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBucyA9IHN2Z0ljb24ubmFtZXNwYWNlIHx8IERFRkFVTFRfTlM7XG4gICAgY29uc3QgbnNJY29uTWFwID0gdGhpcy5jYWNoZWRTdmdFbGVtZW50c1tuc10gfHwgKHRoaXMuY2FjaGVkU3ZnRWxlbWVudHNbbnNdID0ge30pO1xuXG4gICAgLy8gQ3JlYXRpbmcgYSBuZXcgYDxkaXY+YCBwZXIgaWNvbiBpcyBuZWNlc3NhcnkgZm9yIHRoZSBTVkdzIHRvIHdvcmsgY29ycmVjdGx5IGluIElFMTEuXG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG5cbiAgICAvLyBTRUNVUklUWTogdGhlIHNvdXJjZSBmb3IgdGhlIFNWRyBpY29ucyBpcyBwcm92aWRlZCBpbiBjb2RlIGJ5IHRydXN0ZWQgZGV2ZWxvcGVyc1xuICAgIGRpdi5pbm5lckhUTUwgPSBzdmdJY29uLnN2Z1NvdXJjZTtcblxuICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSBkaXYucXVlcnlTZWxlY3Rvcignc3ZnJyk7XG4gICAgbnNJY29uTWFwW3N2Z0ljb24ubmFtZV0gPSBzdmdFbGVtZW50O1xuXG4gICAgcmV0dXJuIHN2Z0VsZW1lbnQ7XG4gIH1cbn1cbiJdfQ==