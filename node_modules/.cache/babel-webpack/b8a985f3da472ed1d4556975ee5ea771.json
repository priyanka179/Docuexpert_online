{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { logger } from \"./logger\";\nimport { getPollingUrl } from \"./requestUtils\";\nimport { createGetLroStatusFromResponse, createInitializeState, createPoll } from \"./stateMachine\";\nexport class GenericPollOperation {\n  constructor(state, lro, lroResourceLocationConfig, processResult, updateState, isDone) {\n    this.state = state;\n    this.lro = lro;\n    this.lroResourceLocationConfig = lroResourceLocationConfig;\n    this.processResult = processResult;\n    this.updateState = updateState;\n    this.isDone = isDone;\n  }\n\n  setPollerConfig(pollerConfig) {\n    this.pollerConfig = pollerConfig;\n  }\n  /**\n   * General update function for LROPoller, the general process is as follows\n   * 1. Check initial operation result to determine the strategy to use\n   *  - Strategies: Location, Azure-AsyncOperation, Original Uri\n   * 2. Check if the operation result has a terminal state\n   *  - Terminal state will be determined by each strategy\n   *  2.1 If it is terminal state Check if a final GET request is required, if so\n   *      send final GET request and return result from operation. If no final GET\n   *      is required, just return the result from operation.\n   *      - Determining what to call for final request is responsibility of each strategy\n   *  2.2 If it is not terminal state, call the polling operation and go to step 1\n   *      - Determining what to call for polling is responsibility of each strategy\n   *      - Strategies will always use the latest URI for polling if provided otherwise\n   *        the last known one\n   */\n\n\n  update(options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      const state = _this.state;\n      let lastResponse = undefined;\n\n      if (!state.isStarted) {\n        const initializeState = createInitializeState(state, _this.lro.requestPath, _this.lro.requestMethod);\n        lastResponse = yield _this.lro.sendInitialRequest();\n        initializeState(lastResponse);\n      }\n\n      if (!state.isCompleted) {\n        if (!_this.poll || !_this.getLroStatusFromResponse) {\n          if (!state.config) {\n            throw new Error(\"Bad state: LRO mode is undefined. Please check if the serialized state is well-formed.\");\n          }\n\n          const isDone = _this.isDone;\n          _this.getLroStatusFromResponse = isDone ? response => Object.assign(Object.assign({}, response), {\n            done: isDone(response.flatResponse, _this.state)\n          }) : createGetLroStatusFromResponse(_this.lro, state.config, _this.lroResourceLocationConfig);\n          _this.poll = createPoll(_this.lro);\n        }\n\n        if (!state.pollingURL) {\n          throw new Error(\"Bad state: polling URL is undefined. Please check if the serialized state is well-formed.\");\n        }\n\n        const currentState = yield _this.poll(state.pollingURL, _this.pollerConfig, _this.getLroStatusFromResponse);\n        logger.verbose(`LRO: polling response: ${JSON.stringify(currentState.rawResponse)}`);\n\n        if (currentState.done) {\n          state.result = _this.processResult ? _this.processResult(currentState.flatResponse, state) : currentState.flatResponse;\n          state.isCompleted = true;\n        } else {\n          _this.poll = (_a = currentState.next) !== null && _a !== void 0 ? _a : _this.poll;\n          state.pollingURL = getPollingUrl(currentState.rawResponse, state.pollingURL);\n        }\n\n        lastResponse = currentState;\n      }\n\n      logger.verbose(`LRO: current state: ${JSON.stringify(state)}`);\n\n      if (lastResponse) {\n        (_b = _this.updateState) === null || _b === void 0 ? void 0 : _b.call(_this, state, lastResponse === null || lastResponse === void 0 ? void 0 : lastResponse.rawResponse);\n      } else {\n        logger.error(`LRO: no response was received`);\n      }\n\n      (_c = options === null || options === void 0 ? void 0 : options.fireProgress) === null || _c === void 0 ? void 0 : _c.call(options, state);\n      return _this;\n    })();\n  }\n\n  cancel() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2.state.isCancelled = true;\n      return _this2;\n    })();\n  }\n  /**\n   * Serializes the Poller operation.\n   */\n\n\n  toString() {\n    return JSON.stringify({\n      state: this.state\n    });\n  }\n\n} //# sourceMappingURL=operation.js.map","map":{"version":3,"sources":["F:/statvalu/AR_DocuExpert_Test/node_modules/@azure/core-lro/dist-esm/src/lroEngine/operation.js"],"names":["logger","getPollingUrl","createGetLroStatusFromResponse","createInitializeState","createPoll","GenericPollOperation","constructor","state","lro","lroResourceLocationConfig","processResult","updateState","isDone","setPollerConfig","pollerConfig","update","options","_a","_b","_c","lastResponse","undefined","isStarted","initializeState","requestPath","requestMethod","sendInitialRequest","isCompleted","poll","getLroStatusFromResponse","config","Error","response","Object","assign","done","flatResponse","pollingURL","currentState","verbose","JSON","stringify","rawResponse","result","next","call","error","fireProgress","cancel","isCancelled","toString"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { logger } from \"./logger\";\nimport { getPollingUrl } from \"./requestUtils\";\nimport { createGetLroStatusFromResponse, createInitializeState, createPoll } from \"./stateMachine\";\nexport class GenericPollOperation {\n    constructor(state, lro, lroResourceLocationConfig, processResult, updateState, isDone) {\n        this.state = state;\n        this.lro = lro;\n        this.lroResourceLocationConfig = lroResourceLocationConfig;\n        this.processResult = processResult;\n        this.updateState = updateState;\n        this.isDone = isDone;\n    }\n    setPollerConfig(pollerConfig) {\n        this.pollerConfig = pollerConfig;\n    }\n    /**\n     * General update function for LROPoller, the general process is as follows\n     * 1. Check initial operation result to determine the strategy to use\n     *  - Strategies: Location, Azure-AsyncOperation, Original Uri\n     * 2. Check if the operation result has a terminal state\n     *  - Terminal state will be determined by each strategy\n     *  2.1 If it is terminal state Check if a final GET request is required, if so\n     *      send final GET request and return result from operation. If no final GET\n     *      is required, just return the result from operation.\n     *      - Determining what to call for final request is responsibility of each strategy\n     *  2.2 If it is not terminal state, call the polling operation and go to step 1\n     *      - Determining what to call for polling is responsibility of each strategy\n     *      - Strategies will always use the latest URI for polling if provided otherwise\n     *        the last known one\n     */\n    async update(options) {\n        var _a, _b, _c;\n        const state = this.state;\n        let lastResponse = undefined;\n        if (!state.isStarted) {\n            const initializeState = createInitializeState(state, this.lro.requestPath, this.lro.requestMethod);\n            lastResponse = await this.lro.sendInitialRequest();\n            initializeState(lastResponse);\n        }\n        if (!state.isCompleted) {\n            if (!this.poll || !this.getLroStatusFromResponse) {\n                if (!state.config) {\n                    throw new Error(\"Bad state: LRO mode is undefined. Please check if the serialized state is well-formed.\");\n                }\n                const isDone = this.isDone;\n                this.getLroStatusFromResponse = isDone\n                    ? (response) => (Object.assign(Object.assign({}, response), { done: isDone(response.flatResponse, this.state) }))\n                    : createGetLroStatusFromResponse(this.lro, state.config, this.lroResourceLocationConfig);\n                this.poll = createPoll(this.lro);\n            }\n            if (!state.pollingURL) {\n                throw new Error(\"Bad state: polling URL is undefined. Please check if the serialized state is well-formed.\");\n            }\n            const currentState = await this.poll(state.pollingURL, this.pollerConfig, this.getLroStatusFromResponse);\n            logger.verbose(`LRO: polling response: ${JSON.stringify(currentState.rawResponse)}`);\n            if (currentState.done) {\n                state.result = this.processResult\n                    ? this.processResult(currentState.flatResponse, state)\n                    : currentState.flatResponse;\n                state.isCompleted = true;\n            }\n            else {\n                this.poll = (_a = currentState.next) !== null && _a !== void 0 ? _a : this.poll;\n                state.pollingURL = getPollingUrl(currentState.rawResponse, state.pollingURL);\n            }\n            lastResponse = currentState;\n        }\n        logger.verbose(`LRO: current state: ${JSON.stringify(state)}`);\n        if (lastResponse) {\n            (_b = this.updateState) === null || _b === void 0 ? void 0 : _b.call(this, state, lastResponse === null || lastResponse === void 0 ? void 0 : lastResponse.rawResponse);\n        }\n        else {\n            logger.error(`LRO: no response was received`);\n        }\n        (_c = options === null || options === void 0 ? void 0 : options.fireProgress) === null || _c === void 0 ? void 0 : _c.call(options, state);\n        return this;\n    }\n    async cancel() {\n        this.state.isCancelled = true;\n        return this;\n    }\n    /**\n     * Serializes the Poller operation.\n     */\n    toString() {\n        return JSON.stringify({\n            state: this.state\n        });\n    }\n}\n//# sourceMappingURL=operation.js.map"]},"metadata":{},"sourceType":"module"}