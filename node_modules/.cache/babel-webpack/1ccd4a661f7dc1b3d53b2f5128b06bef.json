{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/project/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n/**\n * States for Batch.\n */\n\nvar BatchStates;\n\n(function (BatchStates) {\n  BatchStates[BatchStates[\"Good\"] = 0] = \"Good\";\n  BatchStates[BatchStates[\"Error\"] = 1] = \"Error\";\n})(BatchStates || (BatchStates = {}));\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n */\n\n\nexport class Batch {\n  /**\n   * Creates an instance of Batch.\n   * @param concurrency -\n   */\n  constructor(concurrency = 5) {\n    /**\n     * Number of active operations under execution.\n     */\n    this.actives = 0;\n    /**\n     * Number of completed operations under execution.\n     */\n\n    this.completed = 0;\n    /**\n     * Offset of next operation to be executed.\n     */\n\n    this.offset = 0;\n    /**\n     * Operation array to be executed.\n     */\n\n    this.operations = [];\n    /**\n     * States of Batch. When an error happens, state will turn into error.\n     * Batch will stop execute left operations.\n     */\n\n    this.state = BatchStates.Good;\n\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n  /**\n   * Add a operation into queue.\n   *\n   * @param operation -\n   */\n\n\n  addOperation(operation) {\n    var _this = this;\n\n    this.operations.push( /*#__PURE__*/_asyncToGenerator(function* () {\n      try {\n        _this.actives++;\n        yield operation();\n        _this.actives--;\n        _this.completed++;\n\n        _this.parallelExecute();\n      } catch (error) {\n        _this.emitter.emit(\"error\", error);\n      }\n    }));\n  }\n  /**\n   * Start execute operations in the queue.\n   *\n   */\n\n\n  do() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.operations.length === 0) {\n        return Promise.resolve();\n      }\n\n      _this2.parallelExecute();\n\n      return new Promise((resolve, reject) => {\n        _this2.emitter.on(\"finish\", resolve);\n\n        _this2.emitter.on(\"error\", error => {\n          _this2.state = BatchStates.Error;\n          reject(error);\n        });\n      });\n    })();\n  }\n  /**\n   * Get next operation to be executed. Return null when reaching ends.\n   *\n   */\n\n\n  nextOperation() {\n    if (this.offset < this.operations.length) {\n      return this.operations[this.offset++];\n    }\n\n    return null;\n  }\n  /**\n   * Start execute operations. One one the most important difference between\n   * this method with do() is that do() wraps as an sync method.\n   *\n   */\n\n\n  parallelExecute() {\n    if (this.state === BatchStates.Error) {\n      return;\n    }\n\n    if (this.completed >= this.operations.length) {\n      this.emitter.emit(\"finish\");\n      return;\n    }\n\n    while (this.actives < this.concurrency) {\n      const operation = this.nextOperation();\n\n      if (operation) {\n        operation();\n      } else {\n        return;\n      }\n    }\n  }\n\n} //# sourceMappingURL=Batch.js.map","map":{"version":3,"sources":["F:/statvalu/project/AR_DocuExpert_Test/node_modules/@azure/storage-blob/dist-esm/storage-blob/src/utils/Batch.js"],"names":["EventEmitter","BatchStates","Batch","constructor","concurrency","actives","completed","offset","operations","state","Good","RangeError","emitter","addOperation","operation","push","parallelExecute","error","emit","do","length","Promise","resolve","reject","on","Error","nextOperation"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n/**\n * States for Batch.\n */\nvar BatchStates;\n(function (BatchStates) {\n    BatchStates[BatchStates[\"Good\"] = 0] = \"Good\";\n    BatchStates[BatchStates[\"Error\"] = 1] = \"Error\";\n})(BatchStates || (BatchStates = {}));\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n */\nexport class Batch {\n    /**\n     * Creates an instance of Batch.\n     * @param concurrency -\n     */\n    constructor(concurrency = 5) {\n        /**\n         * Number of active operations under execution.\n         */\n        this.actives = 0;\n        /**\n         * Number of completed operations under execution.\n         */\n        this.completed = 0;\n        /**\n         * Offset of next operation to be executed.\n         */\n        this.offset = 0;\n        /**\n         * Operation array to be executed.\n         */\n        this.operations = [];\n        /**\n         * States of Batch. When an error happens, state will turn into error.\n         * Batch will stop execute left operations.\n         */\n        this.state = BatchStates.Good;\n        if (concurrency < 1) {\n            throw new RangeError(\"concurrency must be larger than 0\");\n        }\n        this.concurrency = concurrency;\n        this.emitter = new EventEmitter();\n    }\n    /**\n     * Add a operation into queue.\n     *\n     * @param operation -\n     */\n    addOperation(operation) {\n        this.operations.push(async () => {\n            try {\n                this.actives++;\n                await operation();\n                this.actives--;\n                this.completed++;\n                this.parallelExecute();\n            }\n            catch (error) {\n                this.emitter.emit(\"error\", error);\n            }\n        });\n    }\n    /**\n     * Start execute operations in the queue.\n     *\n     */\n    async do() {\n        if (this.operations.length === 0) {\n            return Promise.resolve();\n        }\n        this.parallelExecute();\n        return new Promise((resolve, reject) => {\n            this.emitter.on(\"finish\", resolve);\n            this.emitter.on(\"error\", (error) => {\n                this.state = BatchStates.Error;\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Get next operation to be executed. Return null when reaching ends.\n     *\n     */\n    nextOperation() {\n        if (this.offset < this.operations.length) {\n            return this.operations[this.offset++];\n        }\n        return null;\n    }\n    /**\n     * Start execute operations. One one the most important difference between\n     * this method with do() is that do() wraps as an sync method.\n     *\n     */\n    parallelExecute() {\n        if (this.state === BatchStates.Error) {\n            return;\n        }\n        if (this.completed >= this.operations.length) {\n            this.emitter.emit(\"finish\");\n            return;\n        }\n        while (this.actives < this.concurrency) {\n            const operation = this.nextOperation();\n            if (operation) {\n                operation();\n            }\n            else {\n                return;\n            }\n        }\n    }\n}\n//# sourceMappingURL=Batch.js.map"]},"metadata":{},"sourceType":"module"}