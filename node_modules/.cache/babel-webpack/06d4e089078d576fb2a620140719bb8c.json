{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { generateUuid, getDefaultProxySettings, isNode, isTokenCredential, URLBuilder } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { BlobDownloadResponse } from \"./BlobDownloadResponse\";\nimport { BlobQueryResponse } from \"./BlobQueryResponse\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AppendBlob, Blob as StorageBlob, BlockBlob, PageBlob } from \"./generated/src/operations\";\nimport { ensureCpkIfSpecified, toAccessTier } from \"./models\";\nimport { rangeResponseFromModel } from \"./PageBlobRangeResponse\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { BlobBeginCopyFromUrlPoller } from \"./pollers/BlobStartCopyFromUrlPoller\";\nimport { rangeToString } from \"./Range\";\nimport { StorageClient } from \"./StorageClient\";\nimport { Batch } from \"./utils/Batch\";\nimport { BufferScheduler } from \"../../storage-common/src\";\nimport { BLOCK_BLOB_MAX_BLOCKS, BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES, BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES, DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES, DEFAULT_BLOCK_BUFFER_SIZE_BYTES, DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS, ETagAny, URLConstants } from \"./utils/constants\";\nimport { createSpan, convertTracingToRequestOptionsBase } from \"./utils/tracing\";\nimport { appendToURLPath, appendToURLQuery, extractConnectionStringParts, generateBlockID, getURLParameter, httpAuthorizationToString, isIpEndpointStyle, parseObjectReplicationRecord, setURLParameter, toBlobTags, toBlobTagsString, toQuerySerialization, toTags } from \"./utils/utils.common\";\nimport { fsCreateReadStream, fsStat, readStreamToLocalFile, streamToBuffer } from \"./utils/utils.node\";\nimport { generateBlobSASQueryParameters } from \"./sas/BlobSASSignatureValues\";\nimport { BlobLeaseClient } from \"./BlobLeaseClient\";\n/**\n * A BlobClient represents a URL to an Azure Storage blob; the blob may be a block blob,\n * append blob, or page blob.\n */\n\nexport class BlobClient extends StorageClient {\n  constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    options = options || {};\n    let pipeline;\n    let url;\n\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      options = blobNameOrOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\" && blobNameOrOptions && typeof blobNameOrOptions === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const blobName = blobNameOrOptions;\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n          options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n\n    super(url, pipeline);\n    ({\n      blobName: this._name,\n      containerName: this._containerName\n    } = this.getBlobAndContainerNamesFromUrl());\n    this.blobContext = new StorageBlob(this.storageClientContext);\n    this._snapshot = getURLParameter(this.url, URLConstants.Parameters.SNAPSHOT);\n    this._versionId = getURLParameter(this.url, URLConstants.Parameters.VERSIONID);\n  }\n  /**\n   * The name of the blob.\n   */\n\n\n  get name() {\n    return this._name;\n  }\n  /**\n   * The name of the storage container the blob is associated with.\n   */\n\n\n  get containerName() {\n    return this._containerName;\n  }\n  /**\n   * Creates a new BlobClient object identical to the source but with the specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a Client to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new BlobClient object identical to the source but with the specified snapshot timestamp\n   */\n\n\n  withSnapshot(snapshot) {\n    return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n  }\n  /**\n   * Creates a new BlobClient object pointing to a version of this blob.\n   * Provide \"\" will remove the versionId and return a Client to the base blob.\n   *\n   * @param versionId - The versionId.\n   * @returns A new BlobClient object pointing to the version of this blob.\n   */\n\n\n  withVersion(versionId) {\n    return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.VERSIONID, versionId.length === 0 ? undefined : versionId), this.pipeline);\n  }\n  /**\n   * Creates a AppendBlobClient object.\n   *\n   */\n\n\n  getAppendBlobClient() {\n    return new AppendBlobClient(this.url, this.pipeline);\n  }\n  /**\n   * Creates a BlockBlobClient object.\n   *\n   */\n\n\n  getBlockBlobClient() {\n    return new BlockBlobClient(this.url, this.pipeline);\n  }\n  /**\n   * Creates a PageBlobClient object.\n   *\n   */\n\n\n  getPageBlobClient() {\n    return new PageBlobClient(this.url, this.pipeline);\n  }\n  /**\n   * Reads or downloads a blob from the system, including its metadata and properties.\n   * You can also call Get Blob to read a snapshot.\n   *\n   * * In Node.js, data returns in a Readable stream readableStreamBody\n   * * In browsers, data returns in a promise blobBody\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob\n   *\n   * @param offset - From which position of the blob to download, greater than or equal to 0\n   * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined\n   * @param options - Optional options to Blob Download operation.\n   *\n   *\n   * Example usage (Node.js):\n   *\n   * ```js\n   * // Download and convert a blob to a string\n   * const downloadBlockBlobResponse = await blobClient.download();\n   * const downloaded = await streamToBuffer(downloadBlockBlobResponse.readableStreamBody);\n   * console.log(\"Downloaded blob content:\", downloaded.toString());\n   *\n   * async function streamToBuffer(readableStream) {\n   * return new Promise((resolve, reject) => {\n   * const chunks = [];\n   * readableStream.on(\"data\", (data) => {\n   * chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n   * });\n   * readableStream.on(\"end\", () => {\n   * resolve(Buffer.concat(chunks));\n   * });\n   * readableStream.on(\"error\", reject);\n   * });\n   * }\n   * ```\n   *\n   * Example usage (browser):\n   *\n   * ```js\n   * // Download and convert a blob to a string\n   * const downloadBlockBlobResponse = await blobClient.download();\n   * const downloaded = await blobToString(await downloadBlockBlobResponse.blobBody);\n   * console.log(\n   *   \"Downloaded blob content\",\n   *   downloaded\n   * );\n   *\n   * async function blobToString(blob: Blob): Promise<string> {\n   *   const fileReader = new FileReader();\n   *   return new Promise<string>((resolve, reject) => {\n   *     fileReader.onloadend = (ev: any) => {\n   *       resolve(ev.target!.result);\n   *     };\n   *     fileReader.onerror = reject;\n   *     fileReader.readAsText(blob);\n   *   });\n   * }\n   * ```\n   */\n\n\n  download(offset = 0, count, options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      options.conditions = options.conditions || {};\n      ensureCpkIfSpecified(options.customerProvidedKey, _this.isHttps);\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-download\", options);\n\n      try {\n        const res = yield _this.blobContext.download(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          requestOptions: {\n            onDownloadProgress: isNode ? undefined : options.onProgress // for Node.js, progress is reported by RetriableReadableStream\n\n          },\n          range: offset === 0 && !count ? undefined : rangeToString({\n            offset,\n            count\n          }),\n          rangeGetContentMD5: options.rangeGetContentMD5,\n          rangeGetContentCRC64: options.rangeGetContentCrc64,\n          snapshot: options.snapshot,\n          cpkInfo: options.customerProvidedKey\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n        const wrappedRes = Object.assign(Object.assign({}, res), {\n          _response: res._response,\n          objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,\n          objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules)\n        }); // Return browser response immediately\n\n        if (!isNode) {\n          return wrappedRes;\n        } // We support retrying when download stream unexpected ends in Node.js runtime\n        // Following code shouldn't be bundled into browser build, however some\n        // bundlers may try to bundle following code and \"FileReadResponse.ts\".\n        // In this case, \"FileDownloadResponse.browser.ts\" will be used as a shim of \"FileDownloadResponse.ts\"\n        // The config is in package.json \"browser\" field\n\n\n        if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {\n          // TODO: Default value or make it a required parameter?\n          options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;\n        }\n\n        if (res.contentLength === undefined) {\n          throw new RangeError(`File download response doesn't contain valid content length header`);\n        }\n\n        if (!res.etag) {\n          throw new RangeError(`File download response doesn't contain valid etag header`);\n        }\n\n        return new BlobDownloadResponse(wrappedRes, /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (start) {\n            var _a;\n\n            const updatedDownloadOptions = {\n              leaseAccessConditions: options.conditions,\n              modifiedAccessConditions: {\n                ifMatch: options.conditions.ifMatch || res.etag,\n                ifModifiedSince: options.conditions.ifModifiedSince,\n                ifNoneMatch: options.conditions.ifNoneMatch,\n                ifUnmodifiedSince: options.conditions.ifUnmodifiedSince,\n                ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n              },\n              range: rangeToString({\n                count: offset + res.contentLength - start,\n                offset: start\n              }),\n              rangeGetContentMD5: options.rangeGetContentMD5,\n              rangeGetContentCRC64: options.rangeGetContentCrc64,\n              snapshot: options.snapshot,\n              cpkInfo: options.customerProvidedKey\n            }; // Debug purpose only\n            // console.log(\n            //   `Read from internal stream, range: ${\n            //     updatedOptions.range\n            //   }, options: ${JSON.stringify(updatedOptions)}`\n            // );\n\n            return (yield _this.blobContext.download(Object.assign({\n              abortSignal: options.abortSignal\n            }, updatedDownloadOptions))).readableStreamBody;\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }(), offset, res.contentLength, {\n          maxRetryRequests: options.maxRetryRequests,\n          onProgress: options.onProgress\n        });\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns true if the Azure blob resource represented by this client exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing blob might be deleted by other clients or\n   * applications. Vice versa new blobs might be added by other clients or applications after this\n   * function completes.\n   *\n   * @param options - options to Exists operation.\n   */\n\n\n  exists(options = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-exists\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this2.isHttps);\n        yield _this2.getProperties({\n          abortSignal: options.abortSignal,\n          customerProvidedKey: options.customerProvidedKey,\n          conditions: options.conditions,\n          tracingOptions: updatedOptions.tracingOptions\n        });\n        return true;\n      } catch (e) {\n        if (e.statusCode === 404) {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: \"Expected exception when checking blob existence\"\n          });\n          return false;\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns all user-defined metadata, standard HTTP properties, and system properties\n   * for the blob. It does not return the content of the blob.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-properties\n   *\n   * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n   * they originally contained uppercase characters. This differs from the metadata keys returned by\n   * the methods of {@link ContainerClient} that list blobs using the `includeMetadata` option, which\n   * will retain their original casing.\n   *\n   * @param options - Optional options to Get Properties operation.\n   */\n\n\n  getProperties(options = {}) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-getProperties\", options);\n\n      try {\n        options.conditions = options.conditions || {};\n        ensureCpkIfSpecified(options.customerProvidedKey, _this3.isHttps);\n        const res = yield _this3.blobContext.getProperties(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          cpkInfo: options.customerProvidedKey\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n        return Object.assign(Object.assign({}, res), {\n          _response: res._response,\n          objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,\n          objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules)\n        });\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Marks the specified blob or snapshot for deletion. The blob is later deleted\n   * during garbage collection. Note that in order to delete a blob, you must delete\n   * all of its snapshots. You can delete both at the same time with the Delete\n   * Blob operation.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n   *\n   * @param options - Optional options to Blob Delete operation.\n   */\n\n\n  delete(options = {}) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-delete\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        return yield _this4.blobContext.delete(Object.assign({\n          abortSignal: options.abortSignal,\n          deleteSnapshots: options.deleteSnapshots,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Marks the specified blob or snapshot for deletion if it exists. The blob is later deleted\n   * during garbage collection. Note that in order to delete a blob, you must delete\n   * all of its snapshots. You can delete both at the same time with the Delete\n   * Blob operation.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n   *\n   * @param options - Optional options to Blob Delete operation.\n   */\n\n\n  deleteIfExists(options = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-deleteIfExists\", options);\n\n      try {\n        const res = yield _this5.delete(updatedOptions);\n        return Object.assign(Object.assign({\n          succeeded: true\n        }, res), {\n          _response: res._response // _response is made non-enumerable\n\n        });\n      } catch (e) {\n        if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobNotFound\") {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: \"Expected exception when deleting a blob or snapshot only if it exists.\"\n          });\n          return Object.assign(Object.assign({\n            succeeded: false\n          }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n            _response: e.response\n          });\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Restores the contents and metadata of soft deleted blob and any associated\n   * soft deleted snapshots. Undelete Blob is supported only on version 2017-07-29\n   * or later.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/undelete-blob\n   *\n   * @param options - Optional options to Blob Undelete operation.\n   */\n\n\n  undelete(options = {}) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-undelete\", options);\n\n      try {\n        return yield _this6.blobContext.undelete(Object.assign({\n          abortSignal: options.abortSignal\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets system properties on the blob.\n   *\n   * If no value provided, or no value provided for the specified blob HTTP headers,\n   * these blob HTTP headers without a value will be cleared.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n   *\n   * @param blobHTTPHeaders - If no value provided, or no value provided for\n   *                                                   the specified blob HTTP headers, these blob HTTP\n   *                                                   headers without a value will be cleared.\n   *                                                   A common header to set is `blobContentType`\n   *                                                   enabling the browser to provide functionality\n   *                                                   based on file type.\n   * @param options - Optional options to Blob Set HTTP Headers operation.\n   */\n\n\n  setHTTPHeaders(blobHTTPHeaders, options = {}) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-setHTTPHeaders\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this7.isHttps);\n        return yield _this7.blobContext.setHttpHeaders(Object.assign({\n          abortSignal: options.abortSignal,\n          blobHttpHeaders: blobHTTPHeaders,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets user-defined metadata for the specified blob as one or more name-value pairs.\n   *\n   * If no option provided, or no metadata defined in the parameter, the blob\n   * metadata will be removed.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata\n   *\n   * @param metadata - Replace existing metadata with this value.\n   *                               If no value provided the existing metadata will be removed.\n   * @param options - Optional options to Set Metadata operation.\n   */\n\n\n  setMetadata(metadata, options = {}) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-setMetadata\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this8.isHttps);\n        return yield _this8.blobContext.setMetadata(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets tags on the underlying blob.\n   * A blob can have up to 10 tags. Tag keys must be between 1 and 128 characters.  Tag values must be between 0 and 256 characters.\n   * Valid tag key and value characters include lower and upper case letters, digits (0-9),\n   * space (' '), plus ('+'), minus ('-'), period ('.'), foward slash ('/'), colon (':'), equals ('='), and underscore ('_').\n   *\n   * @param tags -\n   * @param options -\n   */\n\n\n  setTags(tags, options = {}) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-setTags\", options);\n\n      try {\n        return yield _this9.blobContext.setTags(Object.assign(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)), {\n          tags: toBlobTags(tags)\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Gets the tags associated with the underlying blob.\n   *\n   * @param options -\n   */\n\n\n  getTags(options = {}) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-getTags\", options);\n\n      try {\n        const response = yield _this10.blobContext.getTags(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n        const wrappedResponse = Object.assign(Object.assign({}, response), {\n          _response: response._response,\n          tags: toTags({\n            blobTagSet: response.blobTagSet\n          }) || {}\n        });\n        return wrappedResponse;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Get a {@link BlobLeaseClient} that manages leases on the blob.\n   *\n   * @param proposeLeaseId - Initial proposed lease Id.\n   * @returns A new BlobLeaseClient object for managing leases on the blob.\n   */\n\n\n  getBlobLeaseClient(proposeLeaseId) {\n    return new BlobLeaseClient(this, proposeLeaseId);\n  }\n  /**\n   * Creates a read-only snapshot of a blob.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/snapshot-blob\n   *\n   * @param options - Optional options to the Blob Create Snapshot operation.\n   */\n\n\n  createSnapshot(options = {}) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-createSnapshot\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this11.isHttps);\n        return yield _this11.blobContext.createSnapshot(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Asynchronously copies a blob to a destination within the storage account.\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the copy is completed.\n   * You can also cancel a copy before it is completed by calling `cancelOperation` on the poller.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * In version 2012-02-12 and later, the source for a Copy Blob operation can be\n   * a committed blob in any Azure storage account.\n   * Beginning with version 2015-02-21, the source for a Copy Blob operation can be\n   * an Azure file in any Azure storage account.\n   * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob\n   * operation to copy from another storage account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob\n   *\n   * Example using automatic polling:\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url');\n   * const result = await copyPoller.pollUntilDone();\n   * ```\n   *\n   * Example using manual polling:\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url');\n   * while (!poller.isDone()) {\n   *    await poller.poll();\n   * }\n   * const result = copyPoller.getResult();\n   * ```\n   *\n   * Example using progress updates:\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url', {\n   *   onProgress(state) {\n   *     console.log(`Progress: ${state.copyProgress}`);\n   *   }\n   * });\n   * const result = await copyPoller.pollUntilDone();\n   * ```\n   *\n   * Example using a changing polling interval (default 15 seconds):\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url', {\n   *   intervalInMs: 1000 // poll blob every 1 second for copy progress\n   * });\n   * const result = await copyPoller.pollUntilDone();\n   * ```\n   *\n   * Example using copy cancellation:\n   *\n   * ```js\n   * const copyPoller = await blobClient.beginCopyFromURL('url');\n   * // cancel operation after starting it.\n   * try {\n   *   await copyPoller.cancelOperation();\n   *   // calls to get the result now throw PollerCancelledError\n   *   await copyPoller.getResult();\n   * } catch (err) {\n   *   if (err.name === 'PollerCancelledError') {\n   *     console.log('The copy was cancelled.');\n   *   }\n   * }\n   * ```\n   *\n   * @param copySource - url to the source Azure Blob/File.\n   * @param options - Optional options to the Blob Start Copy From URL operation.\n   */\n\n\n  beginCopyFromURL(copySource, options = {}) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const client = {\n        abortCopyFromURL: (...args) => _this12.abortCopyFromURL(...args),\n        getProperties: (...args) => _this12.getProperties(...args),\n        startCopyFromURL: (...args) => _this12.startCopyFromURL(...args)\n      };\n      const poller = new BlobBeginCopyFromUrlPoller({\n        blobClient: client,\n        copySource,\n        intervalInMs: options.intervalInMs,\n        onProgress: options.onProgress,\n        resumeFrom: options.resumeFrom,\n        startCopyFromURLOptions: options\n      }); // Trigger the startCopyFromURL call by calling poll.\n      // Any errors from this method should be surfaced to the user.\n\n      yield poller.poll();\n      return poller;\n    })();\n  }\n  /**\n   * Aborts a pending asynchronous Copy Blob operation, and leaves a destination blob with zero\n   * length and full metadata. Version 2012-02-12 and newer.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-blob\n   *\n   * @param copyId - Id of the Copy From URL operation.\n   * @param options - Optional options to the Blob Abort Copy From URL operation.\n   */\n\n\n  abortCopyFromURL(copyId, options = {}) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-abortCopyFromURL\", options);\n\n      try {\n        return yield _this13.blobContext.abortCopyFromURL(copyId, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * The synchronous Copy From URL operation copies a blob or an internet resource to a new blob. It will not\n   * return a response until the copy is complete.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob-from-url\n   *\n   * @param copySource - The source URL to copy from, Shared Access Signature(SAS) maybe needed for authentication\n   * @param options -\n   */\n\n\n  syncCopyFromURL(copySource, options = {}) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-syncCopyFromURL\", options);\n      options.conditions = options.conditions || {};\n      options.sourceConditions = options.sourceConditions || {};\n\n      try {\n        return yield _this14.blobContext.copyFromURL(copySource, Object.assign({\n          abortSignal: options.abortSignal,\n          metadata: options.metadata,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          sourceModifiedAccessConditions: {\n            sourceIfMatch: options.sourceConditions.ifMatch,\n            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince\n          },\n          sourceContentMD5: options.sourceContentMD5,\n          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n          blobTagsString: toBlobTagsString(options.tags),\n          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n          legalHold: options.legalHold\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets the tier on a blob. The operation is allowed on a page blob in a premium\n   * storage account and on a block blob in a blob storage account (locally redundant\n   * storage only). A premium page blob's tier determines the allowed size, IOPS,\n   * and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive\n   * storage type. This operation does not update the blob's ETag.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-tier\n   *\n   * @param tier - The tier to be set on the blob. Valid values are Hot, Cool, or Archive.\n   * @param options - Optional options to the Blob Set Tier operation.\n   */\n\n\n  setAccessTier(tier, options = {}) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-setAccessTier\", options);\n\n      try {\n        return yield _this15.blobContext.setTier(toAccessTier(tier), Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          rehydratePriority: options.rehydratePriority\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n  downloadToBuffer(param1, param2, param3, param4 = {}) {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      let buffer;\n      let offset = 0;\n      let count = 0;\n      let options = param4;\n\n      if (param1 instanceof Buffer) {\n        buffer = param1;\n        offset = param2 || 0;\n        count = typeof param3 === \"number\" ? param3 : 0;\n      } else {\n        offset = typeof param1 === \"number\" ? param1 : 0;\n        count = typeof param2 === \"number\" ? param2 : 0;\n        options = param3 || {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-downloadToBuffer\", options);\n\n      try {\n        if (!options.blockSize) {\n          options.blockSize = 0;\n        }\n\n        if (options.blockSize < 0) {\n          throw new RangeError(\"blockSize option must be >= 0\");\n        }\n\n        if (options.blockSize === 0) {\n          options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;\n        }\n\n        if (offset < 0) {\n          throw new RangeError(\"offset option must be >= 0\");\n        }\n\n        if (count && count <= 0) {\n          throw new RangeError(\"count option must be greater than 0\");\n        }\n\n        if (!options.conditions) {\n          options.conditions = {};\n        } // Customer doesn't specify length, get it\n\n\n        if (!count) {\n          const response = yield _this16.getProperties(Object.assign(Object.assign({}, options), {\n            tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n          }));\n          count = response.contentLength - offset;\n\n          if (count < 0) {\n            throw new RangeError(`offset ${offset} shouldn't be larger than blob size ${response.contentLength}`);\n          }\n        } // Allocate the buffer of size = count if the buffer is not provided\n\n\n        if (!buffer) {\n          try {\n            buffer = Buffer.alloc(count);\n          } catch (error) {\n            throw new Error(`Unable to allocate the buffer of size: ${count}(in bytes). Please try passing your own buffer to the \"downloadToBuffer\" method or try using other methods like \"download\" or \"downloadToFile\".\\t ${error.message}`);\n          }\n        }\n\n        if (buffer.length < count) {\n          throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);\n        }\n\n        let transferProgress = 0;\n        const batch = new Batch(options.concurrency);\n\n        for (let off = offset; off < offset + count; off = off + options.blockSize) {\n          batch.addOperation( /*#__PURE__*/_asyncToGenerator(function* () {\n            // Exclusive chunk end position\n            let chunkEnd = offset + count;\n\n            if (off + options.blockSize < chunkEnd) {\n              chunkEnd = off + options.blockSize;\n            }\n\n            const response = yield _this16.download(off, chunkEnd - off, {\n              abortSignal: options.abortSignal,\n              conditions: options.conditions,\n              maxRetryRequests: options.maxRetryRequestsPerBlock,\n              customerProvidedKey: options.customerProvidedKey,\n              tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n            });\n            const stream = response.readableStreamBody;\n            yield streamToBuffer(stream, buffer, off - offset, chunkEnd - offset); // Update progress after block is downloaded, in case of block trying\n            // Could provide finer grained progress updating inside HTTP requests,\n            // only if convenience layer download try is enabled\n\n            transferProgress += chunkEnd - off;\n\n            if (options.onProgress) {\n              options.onProgress({\n                loadedBytes: transferProgress\n              });\n            }\n          }));\n        }\n\n        yield batch.do();\n        return buffer;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Downloads an Azure Blob to a local file.\n   * Fails if the the given file path already exits.\n   * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.\n   *\n   * @param filePath -\n   * @param offset - From which position of the block blob to download.\n   * @param count - How much data to be downloaded. Will download to the end when passing undefined.\n   * @param options - Options to Blob download options.\n   * @returns The response data for blob download operation,\n   *                                                 but with readableStreamBody set to undefined since its\n   *                                                 content is already read and written into a local file\n   *                                                 at the specified path.\n   */\n\n\n  downloadToFile(filePath, offset = 0, count, options = {}) {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-downloadToFile\", options);\n\n      try {\n        const response = yield _this17.download(offset, count, Object.assign(Object.assign({}, options), {\n          tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n        }));\n\n        if (response.readableStreamBody) {\n          yield readStreamToLocalFile(response.readableStreamBody, filePath);\n        } // The stream is no longer accessible so setting it to undefined.\n\n\n        response.blobDownloadStream = undefined;\n        return response;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n  getBlobAndContainerNamesFromUrl() {\n    let containerName;\n    let blobName;\n\n    try {\n      //  URL may look like the following\n      // \"https://myaccount.blob.core.windows.net/mycontainer/blob?sasString\";\n      // \"https://myaccount.blob.core.windows.net/mycontainer/blob\";\n      // \"https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt?sasString\";\n      // \"https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt\";\n      // IPv4/IPv6 address hosts, Endpoints - `http://127.0.0.1:10000/devstoreaccount1/containername/blob`\n      // http://localhost:10001/devstoreaccount1/containername/blob\n      const parsedUrl = URLBuilder.parse(this.url);\n\n      if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n        // \"https://myaccount.blob.core.windows.net/containername/blob\".\n        // .getPath() -> /containername/blob\n        const pathComponents = parsedUrl.getPath().match(\"/([^/]*)(/(.*))?\");\n        containerName = pathComponents[1];\n        blobName = pathComponents[3];\n      } else if (isIpEndpointStyle(parsedUrl)) {\n        // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/containername/blob\n        // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/containername/blob\n        // .getPath() -> /devstoreaccount1/containername/blob\n        const pathComponents = parsedUrl.getPath().match(\"/([^/]*)/([^/]*)(/(.*))?\");\n        containerName = pathComponents[2];\n        blobName = pathComponents[4];\n      } else {\n        // \"https://customdomain.com/containername/blob\".\n        // .getPath() -> /containername/blob\n        const pathComponents = parsedUrl.getPath().match(\"/([^/]*)(/(.*))?\");\n        containerName = pathComponents[1];\n        blobName = pathComponents[3];\n      } // decode the encoded blobName, containerName - to get all the special characters that might be present in them\n\n\n      containerName = decodeURIComponent(containerName);\n      blobName = decodeURIComponent(blobName); // Azure Storage Server will replace \"\\\" with \"/\" in the blob names\n      //   doing the same in the SDK side so that the user doesn't have to replace \"\\\" instances in the blobName\n\n      blobName = blobName.replace(/\\\\/g, \"/\");\n\n      if (!containerName) {\n        throw new Error(\"Provided containerName is invalid.\");\n      }\n\n      return {\n        blobName,\n        containerName\n      };\n    } catch (error) {\n      throw new Error(\"Unable to extract blobName and containerName with provided information.\");\n    }\n  }\n  /**\n   * Asynchronously copies a blob to a destination within the storage account.\n   * In version 2012-02-12 and later, the source for a Copy Blob operation can be\n   * a committed blob in any Azure storage account.\n   * Beginning with version 2015-02-21, the source for a Copy Blob operation can be\n   * an Azure file in any Azure storage account.\n   * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob\n   * operation to copy from another storage account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob\n   *\n   * @param copySource - url to the source Azure Blob/File.\n   * @param options - Optional options to the Blob Start Copy From URL operation.\n   */\n\n\n  startCopyFromURL(copySource, options = {}) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-startCopyFromURL\", options);\n      options.conditions = options.conditions || {};\n      options.sourceConditions = options.sourceConditions || {};\n\n      try {\n        return yield _this18.blobContext.startCopyFromURL(copySource, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          sourceModifiedAccessConditions: {\n            sourceIfMatch: options.sourceConditions.ifMatch,\n            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,\n            sourceIfTags: options.sourceConditions.tagConditions\n          },\n          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n          legalHold: options.legalHold,\n          rehydratePriority: options.rehydratePriority,\n          tier: toAccessTier(options.tier),\n          blobTagsString: toBlobTagsString(options.tags),\n          sealBlob: options.sealBlob\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Only available for BlobClient constructed with a shared key credential.\n   *\n   * Generates a Blob Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n\n\n  generateSasUrl(options) {\n    return new Promise(resolve => {\n      if (!(this.credential instanceof StorageSharedKeyCredential)) {\n        throw new RangeError(\"Can only generate the SAS when the client is initialized with a shared key credential\");\n      }\n\n      const sas = generateBlobSASQueryParameters(Object.assign({\n        containerName: this._containerName,\n        blobName: this._name,\n        snapshotTime: this._snapshot,\n        versionId: this._versionId\n      }, options), this.credential).toString();\n      resolve(appendToURLQuery(this.url, sas));\n    });\n  }\n  /**\n   * Delete the immutablility policy on the blob.\n   *\n   * @param options - Optional options to delete immutability policy on the blob.\n   */\n\n\n  deleteImmutabilityPolicy(options) {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-deleteImmutabilityPolicy\", options);\n\n      try {\n        return yield _this19.blobContext.deleteImmutabilityPolicy(Object.assign({\n          abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Set immutablility policy on the blob.\n   *\n   * @param options - Optional options to set immutability policy on the blob.\n   */\n\n\n  setImmutabilityPolicy(immutabilityPolicy, options) {\n    var _this20 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-setImmutabilityPolicy\", options);\n\n      try {\n        return yield _this20.blobContext.setImmutabilityPolicy(Object.assign({\n          abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,\n          immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn,\n          immutabilityPolicyMode: immutabilityPolicy.policyMode,\n          modifiedAccessConditions: options === null || options === void 0 ? void 0 : options.modifiedAccessCondition\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Set legal hold on the blob.\n   *\n   * @param options - Optional options to set legal hold on the blob.\n   */\n\n\n  setLegalHold(legalHoldEnabled, options) {\n    var _this21 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobClient-setLegalHold\", options);\n\n      try {\n        return yield _this21.blobContext.setLegalHold(legalHoldEnabled, Object.assign({\n          abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n}\n/**\n * AppendBlobClient defines a set of operations applicable to append blobs.\n */\n\nexport class AppendBlobClient extends BlobClient {\n  constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n    //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n    let pipeline;\n    let url;\n    options = options || {};\n\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)      url = urlOrConnectionString;\n      url = urlOrConnectionString;\n      options = blobNameOrOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString; // The second parameter is undefined. Use anonymous credential.\n\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\" && blobNameOrOptions && typeof blobNameOrOptions === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const blobName = blobNameOrOptions;\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n          options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n\n    super(url, pipeline);\n    this.appendBlobContext = new AppendBlob(this.storageClientContext);\n  }\n  /**\n   * Creates a new AppendBlobClient object identical to the source but with the\n   * specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a Client to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new AppendBlobClient object identical to the source but with the specified snapshot timestamp.\n   */\n\n\n  withSnapshot(snapshot) {\n    return new AppendBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n  }\n  /**\n   * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param options - Options to the Append Block Create operation.\n   *\n   *\n   * Example usage:\n   *\n   * ```js\n   * const appendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n   * await appendBlobClient.create();\n   * ```\n   */\n\n\n  create(options = {}) {\n    var _this22 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"AppendBlobClient-create\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this22.isHttps);\n        return yield _this22.appendBlobContext.create(0, Object.assign({\n          abortSignal: options.abortSignal,\n          blobHttpHeaders: options.blobHTTPHeaders,\n          leaseAccessConditions: options.conditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n          legalHold: options.legalHold,\n          blobTagsString: toBlobTagsString(options.tags)\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.\n   * If the blob with the same name already exists, the content of the existing blob will remain unchanged.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param options -\n   */\n\n\n  createIfNotExists(options = {}) {\n    var _this23 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"AppendBlobClient-createIfNotExists\", options);\n      const conditions = {\n        ifNoneMatch: ETagAny\n      };\n\n      try {\n        const res = yield _this23.create(Object.assign(Object.assign({}, updatedOptions), {\n          conditions\n        }));\n        return Object.assign(Object.assign({\n          succeeded: true\n        }, res), {\n          _response: res._response // _response is made non-enumerable\n\n        });\n      } catch (e) {\n        if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobAlreadyExists\") {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: \"Expected exception when creating a blob only if it does not already exist.\"\n          });\n          return Object.assign(Object.assign({\n            succeeded: false\n          }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n            _response: e.response\n          });\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Seals the append blob, making it read only.\n   *\n   * @param options -\n   */\n\n\n  seal(options = {}) {\n    var _this24 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"AppendBlobClient-seal\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        return yield _this24.appendBlobContext.seal(Object.assign({\n          abortSignal: options.abortSignal,\n          appendPositionAccessConditions: options.conditions,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Commits a new block of data to the end of the existing append blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/append-block\n   *\n   * @param body - Data to be appended.\n   * @param contentLength - Length of the body in bytes.\n   * @param options - Options to the Append Block operation.\n   *\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello World!\";\n   *\n   * // Create a new append blob and append data to the blob.\n   * const newAppendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n   * await newAppendBlobClient.create();\n   * await newAppendBlobClient.appendBlock(content, content.length);\n   *\n   * // Append data to an existing append blob.\n   * const existingAppendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n   * await existingAppendBlobClient.appendBlock(content, content.length);\n   * ```\n   */\n\n\n  appendBlock(body, contentLength, options = {}) {\n    var _this25 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"AppendBlobClient-appendBlock\", options);\n      options.conditions = options.conditions || {};\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this25.isHttps);\n        return yield _this25.appendBlobContext.appendBlock(contentLength, body, Object.assign({\n          abortSignal: options.abortSignal,\n          appendPositionAccessConditions: options.conditions,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          requestOptions: {\n            onUploadProgress: options.onProgress\n          },\n          transactionalContentMD5: options.transactionalContentMD5,\n          transactionalContentCrc64: options.transactionalContentCrc64,\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * The Append Block operation commits a new block of data to the end of an existing append blob\n   * where the contents are read from a source url.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/append-block-from-url\n   *\n   * @param sourceURL -\n   *                 The url to the blob that will be the source of the copy. A source blob in the same storage account can\n   *                 be authenticated via Shared Key. However, if the source is a blob in another account, the source blob\n   *                 must either be public or must be authenticated via a shared access signature. If the source blob is\n   *                 public, no authentication is required to perform the operation.\n   * @param sourceOffset - Offset in source to be appended\n   * @param count - Number of bytes to be appended as a block\n   * @param options -\n   */\n\n\n  appendBlockFromURL(sourceURL, sourceOffset, count, options = {}) {\n    var _this26 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"AppendBlobClient-appendBlockFromURL\", options);\n      options.conditions = options.conditions || {};\n      options.sourceConditions = options.sourceConditions || {};\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this26.isHttps);\n        return yield _this26.appendBlobContext.appendBlockFromUrl(sourceURL, 0, Object.assign({\n          abortSignal: options.abortSignal,\n          sourceRange: rangeToString({\n            offset: sourceOffset,\n            count\n          }),\n          sourceContentMD5: options.sourceContentMD5,\n          sourceContentCrc64: options.sourceContentCrc64,\n          leaseAccessConditions: options.conditions,\n          appendPositionAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          sourceModifiedAccessConditions: {\n            sourceIfMatch: options.sourceConditions.ifMatch,\n            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince\n          },\n          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n}\n/**\n * BlockBlobClient defines a set of operations applicable to block blobs.\n */\n\nexport class BlockBlobClient extends BlobClient {\n  constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n    //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n    let pipeline;\n    let url;\n    options = options || {};\n\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      options = blobNameOrOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\" && blobNameOrOptions && typeof blobNameOrOptions === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const blobName = blobNameOrOptions;\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n          options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n\n    super(url, pipeline);\n    this.blockBlobContext = new BlockBlob(this.storageClientContext);\n    this._blobContext = new StorageBlob(this.storageClientContext);\n  }\n  /**\n   * Creates a new BlockBlobClient object identical to the source but with the\n   * specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a URL to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new BlockBlobClient object identical to the source but with the specified snapshot timestamp.\n   */\n\n\n  withSnapshot(snapshot) {\n    return new BlockBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n  }\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Quick query for a JSON or CSV formatted blob.\n   *\n   * Example usage (Node.js):\n   *\n   * ```js\n   * // Query and convert a blob to a string\n   * const queryBlockBlobResponse = await blockBlobClient.query(\"select * from BlobStorage\");\n   * const downloaded = (await streamToBuffer(queryBlockBlobResponse.readableStreamBody)).toString();\n   * console.log(\"Query blob content:\", downloaded);\n   *\n   * async function streamToBuffer(readableStream) {\n   *   return new Promise((resolve, reject) => {\n   *     const chunks = [];\n   *     readableStream.on(\"data\", (data) => {\n   *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n   *     });\n   *     readableStream.on(\"end\", () => {\n   *       resolve(Buffer.concat(chunks));\n   *     });\n   *     readableStream.on(\"error\", reject);\n   *   });\n   * }\n   * ```\n   *\n   * @param query -\n   * @param options -\n   */\n\n\n  query(query, options = {}) {\n    var _this27 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      ensureCpkIfSpecified(options.customerProvidedKey, _this27.isHttps);\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-query\", options);\n\n      try {\n        if (!isNode) {\n          throw new Error(\"This operation currently is only supported in Node.js.\");\n        }\n\n        const response = yield _this27._blobContext.query(Object.assign({\n          abortSignal: options.abortSignal,\n          queryRequest: {\n            queryType: \"SQL\",\n            expression: query,\n            inputSerialization: toQuerySerialization(options.inputTextConfiguration),\n            outputSerialization: toQuerySerialization(options.outputTextConfiguration)\n          },\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n        return new BlobQueryResponse(response, {\n          abortSignal: options.abortSignal,\n          onProgress: options.onProgress,\n          onError: options.onError\n        });\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a new block blob, or updates the content of an existing block blob.\n   * Updating an existing block blob overwrites any existing metadata on the blob.\n   * Partial updates are not supported; the content of the existing blob is\n   * overwritten with the new content. To perform a partial update of a block blob's,\n   * use {@link stageBlock} and {@link commitBlockList}.\n   *\n   * This is a non-parallel uploading method, please use {@link uploadFile},\n   * {@link uploadStream} or {@link uploadBrowserData} for better performance\n   * with concurrency uploading.\n   *\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function\n   *                               which returns a new Readable stream whose offset is from data source beginning.\n   * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a\n   *                               string including non non-Base64/Hex-encoded characters.\n   * @param options - Options to the Block Blob Upload operation.\n   * @returns Response data for the Block Blob Upload operation.\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello world!\";\n   * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);\n   * ```\n   */\n\n\n  upload(body, contentLength, options = {}) {\n    var _this28 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-upload\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this28.isHttps);\n        return yield _this28.blockBlobContext.upload(contentLength, body, Object.assign({\n          abortSignal: options.abortSignal,\n          blobHttpHeaders: options.blobHTTPHeaders,\n          leaseAccessConditions: options.conditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          requestOptions: {\n            onUploadProgress: options.onProgress\n          },\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n          legalHold: options.legalHold,\n          tier: toAccessTier(options.tier),\n          blobTagsString: toBlobTagsString(options.tags)\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a new Block Blob where the contents of the blob are read from a given URL.\n   * This API is supported beginning with the 2020-04-08 version. Partial updates\n   * are not supported with Put Blob from URL; the content of an existing blob is overwritten with\n   * the content of the new blob.  To perform partial updates to a block blob’s contents using a\n   * source URL, use {@link stageBlockFromURL} and {@link commitBlockList}.\n   *\n   * @param sourceURL - Specifies the URL of the blob. The value\n   *                           may be a URL of up to 2 KB in length that specifies a blob.\n   *                           The value should be URL-encoded as it would appear\n   *                           in a request URI. The source blob must either be public\n   *                           or must be authenticated via a shared access signature.\n   *                           If the source blob is public, no authentication is required\n   *                           to perform the operation. Here are some examples of source object URLs:\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n   * @param options - Optional parameters.\n   */\n\n\n  syncUploadFromURL(sourceURL, options = {}) {\n    var _this29 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c, _d, _e;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-syncUploadFromURL\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this29.isHttps);\n        return yield _this29.blockBlobContext.putBlobFromUrl(0, sourceURL, Object.assign(Object.assign(Object.assign({}, options), {\n          blobHttpHeaders: options.blobHTTPHeaders,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: options.conditions.tagConditions\n          }),\n          sourceModifiedAccessConditions: {\n            sourceIfMatch: (_a = options.sourceConditions) === null || _a === void 0 ? void 0 : _a.ifMatch,\n            sourceIfModifiedSince: (_b = options.sourceConditions) === null || _b === void 0 ? void 0 : _b.ifModifiedSince,\n            sourceIfNoneMatch: (_c = options.sourceConditions) === null || _c === void 0 ? void 0 : _c.ifNoneMatch,\n            sourceIfUnmodifiedSince: (_d = options.sourceConditions) === null || _d === void 0 ? void 0 : _d.ifUnmodifiedSince,\n            sourceIfTags: (_e = options.sourceConditions) === null || _e === void 0 ? void 0 : _e.tagConditions\n          },\n          cpkInfo: options.customerProvidedKey,\n          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),\n          tier: toAccessTier(options.tier),\n          blobTagsString: toBlobTagsString(options.tags)\n        }), convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Uploads the specified block to the block blob's \"staging area\" to be later\n   * committed by a call to commitBlockList.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-block\n   *\n   * @param blockId - A 64-byte value that is base64-encoded\n   * @param body - Data to upload to the staging area.\n   * @param contentLength - Number of bytes to upload.\n   * @param options - Options to the Block Blob Stage Block operation.\n   * @returns Response data for the Block Blob Stage Block operation.\n   */\n\n\n  stageBlock(blockId, body, contentLength, options = {}) {\n    var _this30 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-stageBlock\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this30.isHttps);\n        return yield _this30.blockBlobContext.stageBlock(blockId, contentLength, body, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          requestOptions: {\n            onUploadProgress: options.onProgress\n          },\n          transactionalContentMD5: options.transactionalContentMD5,\n          transactionalContentCrc64: options.transactionalContentCrc64,\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * The Stage Block From URL operation creates a new block to be committed as part\n   * of a blob where the contents are read from a URL.\n   * This API is available starting in version 2018-03-28.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-block-from-url\n   *\n   * @param blockId - A 64-byte value that is base64-encoded\n   * @param sourceURL - Specifies the URL of the blob. The value\n   *                           may be a URL of up to 2 KB in length that specifies a blob.\n   *                           The value should be URL-encoded as it would appear\n   *                           in a request URI. The source blob must either be public\n   *                           or must be authenticated via a shared access signature.\n   *                           If the source blob is public, no authentication is required\n   *                           to perform the operation. Here are some examples of source object URLs:\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n   * @param offset - From which position of the blob to download, greater than or equal to 0\n   * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined\n   * @param options - Options to the Block Blob Stage Block From URL operation.\n   * @returns Response data for the Block Blob Stage Block From URL operation.\n   */\n\n\n  stageBlockFromURL(blockId, sourceURL, offset = 0, count, options = {}) {\n    var _this31 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-stageBlockFromURL\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this31.isHttps);\n        return yield _this31.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          sourceContentMD5: options.sourceContentMD5,\n          sourceContentCrc64: options.sourceContentCrc64,\n          sourceRange: offset === 0 && !count ? undefined : rangeToString({\n            offset,\n            count\n          }),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization)\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Writes a blob by specifying the list of block IDs that make up the blob.\n   * In order to be written as part of a blob, a block must have been successfully written\n   * to the server in a prior {@link stageBlock} operation. You can call {@link commitBlockList} to\n   * update a blob by uploading only those blocks that have changed, then committing the new and existing\n   * blocks together. Any blocks not specified in the block list and permanently deleted.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-block-list\n   *\n   * @param blocks -  Array of 64-byte value that is base64-encoded\n   * @param options - Options to the Block Blob Commit Block List operation.\n   * @returns Response data for the Block Blob Commit Block List operation.\n   */\n\n\n  commitBlockList(blocks, options = {}) {\n    var _this32 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-commitBlockList\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this32.isHttps);\n        return yield _this32.blockBlobContext.commitBlockList({\n          latest: blocks\n        }, Object.assign({\n          abortSignal: options.abortSignal,\n          blobHttpHeaders: options.blobHTTPHeaders,\n          leaseAccessConditions: options.conditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n          legalHold: options.legalHold,\n          tier: toAccessTier(options.tier),\n          blobTagsString: toBlobTagsString(options.tags)\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns the list of blocks that have been uploaded as part of a block blob\n   * using the specified block list filter.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-block-list\n   *\n   * @param listType - Specifies whether to return the list of committed blocks,\n   *                                        the list of uncommitted blocks, or both lists together.\n   * @param options - Options to the Block Blob Get Block List operation.\n   * @returns Response data for the Block Blob Get Block List operation.\n   */\n\n\n  getBlockList(listType, options = {}) {\n    var _this33 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-getBlockList\", options);\n\n      try {\n        const res = yield _this33.blockBlobContext.getBlockList(listType, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n\n        if (!res.committedBlocks) {\n          res.committedBlocks = [];\n        }\n\n        if (!res.uncommittedBlocks) {\n          res.uncommittedBlocks = [];\n        }\n\n        return res;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  } // High level functions\n\n  /**\n   * Uploads a Buffer(Node.js)/Blob(browsers)/ArrayBuffer/ArrayBufferView object to a BlockBlob.\n   *\n   * When data length is no more than the specifiled {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is\n   * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.\n   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}\n   * to commit the block list.\n   *\n   * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is\n   * `blobContentType`, enabling the browser to provide\n   * functionality based on file type.\n   *\n   * @param data - Buffer(Node.js), Blob, ArrayBuffer or ArrayBufferView\n   * @param options -\n   */\n\n\n  uploadData(data, options = {}) {\n    var _this34 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-uploadData\", options);\n\n      try {\n        if (isNode) {\n          let buffer;\n\n          if (data instanceof Buffer) {\n            buffer = data;\n          } else if (data instanceof ArrayBuffer) {\n            buffer = Buffer.from(data);\n          } else {\n            data = data;\n            buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n          }\n\n          return _this34.uploadSeekableInternal((offset, size) => buffer.slice(offset, offset + size), buffer.byteLength, updatedOptions);\n        } else {\n          const browserBlob = new Blob([data]);\n          return _this34.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);\n        }\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * ONLY AVAILABLE IN BROWSERS.\n   *\n   * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to block blob.\n   *\n   * When buffer length lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.\n   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call\n   * {@link commitBlockList} to commit the block list.\n   *\n   * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is\n   * `blobContentType`, enabling the browser to provide\n   * functionality based on file type.\n   *\n   * @deprecated Use {@link uploadData} instead.\n   *\n   * @param browserData - Blob, File, ArrayBuffer or ArrayBufferView\n   * @param options - Options to upload browser data.\n   * @returns Response data for the Blob Upload operation.\n   */\n\n\n  uploadBrowserData(browserData, options = {}) {\n    var _this35 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-uploadBrowserData\", options);\n\n      try {\n        const browserBlob = new Blob([browserData]);\n        return yield _this35.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   *\n   * Uploads data to block blob. Requires a bodyFactory as the data source,\n   * which need to return a {@link HttpRequestBody} object with the offset and size provided.\n   *\n   * When data length is no more than the specifiled {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is\n   * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.\n   * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}\n   * to commit the block list.\n   *\n   * @param bodyFactory -\n   * @param size - size of the data to upload.\n   * @param options - Options to Upload to Block Blob operation.\n   * @returns Response data for the Blob Upload operation.\n   */\n\n\n  uploadSeekableInternal(bodyFactory, size, options = {}) {\n    var _this36 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!options.blockSize) {\n        options.blockSize = 0;\n      }\n\n      if (options.blockSize < 0 || options.blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {\n        throw new RangeError(`blockSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`);\n      }\n\n      if (options.maxSingleShotSize !== 0 && !options.maxSingleShotSize) {\n        options.maxSingleShotSize = BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;\n      }\n\n      if (options.maxSingleShotSize < 0 || options.maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) {\n        throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`);\n      }\n\n      if (options.blockSize === 0) {\n        if (size > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * BLOCK_BLOB_MAX_BLOCKS) {\n          throw new RangeError(`${size} is too larger to upload to a block blob.`);\n        }\n\n        if (size > options.maxSingleShotSize) {\n          options.blockSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);\n\n          if (options.blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {\n            options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;\n          }\n        }\n      }\n\n      if (!options.blobHTTPHeaders) {\n        options.blobHTTPHeaders = {};\n      }\n\n      if (!options.conditions) {\n        options.conditions = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-uploadSeekableInternal\", options);\n\n      try {\n        if (size <= options.maxSingleShotSize) {\n          return yield _this36.upload(bodyFactory(0, size), size, updatedOptions);\n        }\n\n        const numBlocks = Math.floor((size - 1) / options.blockSize) + 1;\n\n        if (numBlocks > BLOCK_BLOB_MAX_BLOCKS) {\n          throw new RangeError(`The buffer's size is too big or the BlockSize is too small;` + `the number of blocks must be <= ${BLOCK_BLOB_MAX_BLOCKS}`);\n        }\n\n        const blockList = [];\n        const blockIDPrefix = generateUuid();\n        let transferProgress = 0;\n        const batch = new Batch(options.concurrency);\n\n        for (let i = 0; i < numBlocks; i++) {\n          batch.addOperation( /*#__PURE__*/_asyncToGenerator(function* () {\n            const blockID = generateBlockID(blockIDPrefix, i);\n            const start = options.blockSize * i;\n            const end = i === numBlocks - 1 ? size : start + options.blockSize;\n            const contentLength = end - start;\n            blockList.push(blockID);\n            yield _this36.stageBlock(blockID, bodyFactory(start, contentLength), contentLength, {\n              abortSignal: options.abortSignal,\n              conditions: options.conditions,\n              encryptionScope: options.encryptionScope,\n              tracingOptions: updatedOptions.tracingOptions\n            }); // Update progress after block is successfully uploaded to server, in case of block trying\n            // TODO: Hook with convenience layer progress event in finer level\n\n            transferProgress += contentLength;\n\n            if (options.onProgress) {\n              options.onProgress({\n                loadedBytes: transferProgress\n              });\n            }\n          }));\n        }\n\n        yield batch.do();\n        return _this36.commitBlockList(blockList, updatedOptions);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Uploads a local file in blocks to a block blob.\n   *\n   * When file size lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.\n   * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList\n   * to commit the block list.\n   *\n   * @param filePath - Full path of local file\n   * @param options - Options to Upload to Block Blob operation.\n   * @returns Response data for the Blob Upload operation.\n   */\n\n\n  uploadFile(filePath, options = {}) {\n    var _this37 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-uploadFile\", options);\n\n      try {\n        const size = (yield fsStat(filePath)).size;\n        return yield _this37.uploadSeekableInternal((offset, count) => {\n          return () => fsCreateReadStream(filePath, {\n            autoClose: true,\n            end: count ? offset + count - 1 : Infinity,\n            start: offset\n          });\n        }, size, Object.assign(Object.assign({}, options), {\n          tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * ONLY AVAILABLE IN NODE.JS RUNTIME.\n   *\n   * Uploads a Node.js Readable stream into block blob.\n   *\n   * PERFORMANCE IMPROVEMENT TIPS:\n   * * Input stream highWaterMark is better to set a same value with bufferSize\n   *    parameter, which will avoid Buffer.concat() operations.\n   *\n   * @param stream - Node.js Readable stream\n   * @param bufferSize - Size of every buffer allocated, also the block size in the uploaded block blob. Default value is 8MB\n   * @param maxConcurrency -  Max concurrency indicates the max number of buffers that can be allocated,\n   *                                 positive correlation with max uploading concurrency. Default value is 5\n   * @param options - Options to Upload Stream to Block Blob operation.\n   * @returns Response data for the Blob Upload operation.\n   */\n\n\n  uploadStream(stream, bufferSize = DEFAULT_BLOCK_BUFFER_SIZE_BYTES, maxConcurrency = 5, options = {}) {\n    var _this38 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!options.blobHTTPHeaders) {\n        options.blobHTTPHeaders = {};\n      }\n\n      if (!options.conditions) {\n        options.conditions = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlockBlobClient-uploadStream\", options);\n\n      try {\n        let blockNum = 0;\n        const blockIDPrefix = generateUuid();\n        let transferProgress = 0;\n        const blockList = [];\n        const scheduler = new BufferScheduler(stream, bufferSize, maxConcurrency, /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator(function* (body, length) {\n            const blockID = generateBlockID(blockIDPrefix, blockNum);\n            blockList.push(blockID);\n            blockNum++;\n            yield _this38.stageBlock(blockID, body, length, {\n              conditions: options.conditions,\n              encryptionScope: options.encryptionScope,\n              tracingOptions: updatedOptions.tracingOptions\n            }); // Update progress after block is successfully uploaded to server, in case of block trying\n\n            transferProgress += length;\n\n            if (options.onProgress) {\n              options.onProgress({\n                loadedBytes: transferProgress\n              });\n            }\n          });\n\n          return function (_x2, _x3) {\n            return _ref4.apply(this, arguments);\n          };\n        }(), // concurrency should set a smaller value than maxConcurrency, which is helpful to\n        // reduce the possibility when a outgoing handler waits for stream data, in\n        // this situation, outgoing handlers are blocked.\n        // Outgoing queue shouldn't be empty.\n        Math.ceil(maxConcurrency / 4 * 3));\n        yield scheduler.do();\n        return yield _this38.commitBlockList(blockList, Object.assign(Object.assign({}, options), {\n          tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n}\n/**\n * PageBlobClient defines a set of operations applicable to page blobs.\n */\n\nexport class PageBlobClient extends BlobClient {\n  constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n    //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n    let pipeline;\n    let url;\n    options = options || {};\n\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      options = blobNameOrOptions;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\" && blobNameOrOptions && typeof blobNameOrOptions === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const blobName = blobNameOrOptions;\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n          options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n    }\n\n    super(url, pipeline);\n    this.pageBlobContext = new PageBlob(this.storageClientContext);\n  }\n  /**\n   * Creates a new PageBlobClient object identical to the source but with the\n   * specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a Client to the base blob.\n   *\n   * @param snapshot - The snapshot timestamp.\n   * @returns A new PageBlobClient object identical to the source but with the specified snapshot timestamp.\n   */\n\n\n  withSnapshot(snapshot) {\n    return new PageBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n  }\n  /**\n   * Creates a page blob of the specified length. Call uploadPages to upload data\n   * data to a page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param size - size of the page blob.\n   * @param options - Options to the Page Blob Create operation.\n   * @returns Response data for the Page Blob Create operation.\n   */\n\n\n  create(size, options = {}) {\n    var _this39 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-create\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this39.isHttps);\n        return yield _this39.pageBlobContext.create(0, size, Object.assign({\n          abortSignal: options.abortSignal,\n          blobHttpHeaders: options.blobHTTPHeaders,\n          blobSequenceNumber: options.blobSequenceNumber,\n          leaseAccessConditions: options.conditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn,\n          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode,\n          legalHold: options.legalHold,\n          tier: toAccessTier(options.tier),\n          blobTagsString: toBlobTagsString(options.tags)\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a page blob of the specified length. Call uploadPages to upload data\n   * data to a page blob. If the blob with the same name already exists, the content\n   * of the existing blob will remain unchanged.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param size - size of the page blob.\n   * @param options -\n   */\n\n\n  createIfNotExists(size, options = {}) {\n    var _this40 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-createIfNotExists\", options);\n\n      try {\n        const conditions = {\n          ifNoneMatch: ETagAny\n        };\n        const res = yield _this40.create(size, Object.assign(Object.assign({}, options), {\n          conditions,\n          tracingOptions: updatedOptions.tracingOptions\n        }));\n        return Object.assign(Object.assign({\n          succeeded: true\n        }, res), {\n          _response: res._response // _response is made non-enumerable\n\n        });\n      } catch (e) {\n        if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobAlreadyExists\") {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: \"Expected exception when creating a blob only if it does not already exist.\"\n          });\n          return Object.assign(Object.assign({\n            succeeded: false\n          }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n            _response: e.response\n          });\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Writes 1 or more pages to the page blob. The start and end offsets must be a multiple of 512.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-page\n   *\n   * @param body - Data to upload\n   * @param offset - Offset of destination page blob\n   * @param count - Content length of the body, also number of bytes to be uploaded\n   * @param options - Options to the Page Blob Upload Pages operation.\n   * @returns Response data for the Page Blob Upload Pages operation.\n   */\n\n\n  uploadPages(body, offset, count, options = {}) {\n    var _this41 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-uploadPages\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this41.isHttps);\n        return yield _this41.pageBlobContext.uploadPages(count, body, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          requestOptions: {\n            onUploadProgress: options.onProgress\n          },\n          range: rangeToString({\n            offset,\n            count\n          }),\n          sequenceNumberAccessConditions: options.conditions,\n          transactionalContentMD5: options.transactionalContentMD5,\n          transactionalContentCrc64: options.transactionalContentCrc64,\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * The Upload Pages operation writes a range of pages to a page blob where the\n   * contents are read from a URL.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-page-from-url\n   *\n   * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication\n   * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source page blob\n   * @param destOffset - Offset of destination page blob\n   * @param count - Number of bytes to be uploaded from source page blob\n   * @param options -\n   */\n\n\n  uploadPagesFromURL(sourceURL, sourceOffset, destOffset, count, options = {}) {\n    var _this42 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      options.sourceConditions = options.sourceConditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-uploadPagesFromURL\", options);\n\n      try {\n        ensureCpkIfSpecified(options.customerProvidedKey, _this42.isHttps);\n        return yield _this42.pageBlobContext.uploadPagesFromURL(sourceURL, rangeToString({\n          offset: sourceOffset,\n          count\n        }), 0, rangeToString({\n          offset: destOffset,\n          count\n        }), Object.assign({\n          abortSignal: options.abortSignal,\n          sourceContentMD5: options.sourceContentMD5,\n          sourceContentCrc64: options.sourceContentCrc64,\n          leaseAccessConditions: options.conditions,\n          sequenceNumberAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          sourceModifiedAccessConditions: {\n            sourceIfMatch: options.sourceConditions.ifMatch,\n            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince\n          },\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope,\n          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization)\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Frees the specified pages from the page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-page\n   *\n   * @param offset - Starting byte position of the pages to clear.\n   * @param count - Number of bytes to clear.\n   * @param options - Options to the Page Blob Clear Pages operation.\n   * @returns Response data for the Page Blob Clear Pages operation.\n   */\n\n\n  clearPages(offset = 0, count, options = {}) {\n    var _this43 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-clearPages\", options);\n\n      try {\n        return yield _this43.pageBlobContext.clearPages(0, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          range: rangeToString({\n            offset,\n            count\n          }),\n          sequenceNumberAccessConditions: options.conditions,\n          cpkInfo: options.customerProvidedKey,\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns the list of valid page ranges for a page blob or snapshot of a page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   * @param offset - Starting byte position of the page ranges.\n   * @param count - Number of bytes to get.\n   * @param options - Options to the Page Blob Get Ranges operation.\n   * @returns Response data for the Page Blob Get Ranges operation.\n   */\n\n\n  getPageRanges(offset = 0, count, options = {}) {\n    var _this44 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-getPageRanges\", options);\n\n      try {\n        return yield _this44.pageBlobContext.getPageRanges(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          range: rangeToString({\n            offset,\n            count\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions))).then(rangeResponseFromModel);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Gets the collection of page ranges that differ between a specified snapshot and this page blob.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   * @param offset - Starting byte position of the page blob\n   * @param count - Number of bytes to get ranges diff.\n   * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.\n   * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n   * @returns Response data for the Page Blob Get Page Range Diff operation.\n   */\n\n\n  getPageRangesDiff(offset, count, prevSnapshot, options = {}) {\n    var _this45 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-getPageRangesDiff\", options);\n\n      try {\n        return yield _this45.pageBlobContext.getPageRangesDiff(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          prevsnapshot: prevSnapshot,\n          range: rangeToString({\n            offset,\n            count\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions))).then(rangeResponseFromModel);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Gets the collection of page ranges that differ between a specified snapshot and this page blob for managed disks.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n   *\n   * @param offset - Starting byte position of the page blob\n   * @param count - Number of bytes to get ranges diff.\n   * @param prevSnapshotUrl - URL of snapshot to retrieve the difference.\n   * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n   * @returns Response data for the Page Blob Get Page Range Diff operation.\n   */\n\n\n  getPageRangesDiffForManagedDisks(offset, count, prevSnapshotUrl, options = {}) {\n    var _this46 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-GetPageRangesDiffForManagedDisks\", options);\n\n      try {\n        return yield _this46.pageBlobContext.getPageRangesDiff(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          prevSnapshotUrl,\n          range: rangeToString({\n            offset,\n            count\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions))).then(rangeResponseFromModel);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Resizes the page blob to the specified size (which must be a multiple of 512).\n   * @see https://docs.microsoft.com/rest/api/storageservices/set-blob-properties\n   *\n   * @param size - Target size\n   * @param options - Options to the Page Blob Resize operation.\n   * @returns Response data for the Page Blob Resize operation.\n   */\n\n\n  resize(size, options = {}) {\n    var _this47 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-resize\", options);\n\n      try {\n        return yield _this47.pageBlobContext.resize(size, Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          }),\n          encryptionScope: options.encryptionScope\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets a page blob's sequence number.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n   *\n   * @param sequenceNumberAction - Indicates how the service should modify the blob's sequence number.\n   * @param sequenceNumber - Required if sequenceNumberAction is max or update\n   * @param options - Options to the Page Blob Update Sequence Number operation.\n   * @returns Response data for the Page Blob Update Sequence Number operation.\n   */\n\n\n  updateSequenceNumber(sequenceNumberAction, sequenceNumber, options = {}) {\n    var _this48 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-updateSequenceNumber\", options);\n\n      try {\n        return yield _this48.pageBlobContext.updateSequenceNumber(sequenceNumberAction, Object.assign({\n          abortSignal: options.abortSignal,\n          blobSequenceNumber: sequenceNumber,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Begins an operation to start an incremental copy from one page blob's snapshot to this page blob.\n   * The snapshot is copied such that only the differential changes between the previously\n   * copied snapshot are transferred to the destination.\n   * The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual.\n   * @see https://docs.microsoft.com/rest/api/storageservices/incremental-copy-blob\n   * @see https://docs.microsoft.com/en-us/azure/virtual-machines/windows/incremental-snapshots\n   *\n   * @param copySource - Specifies the name of the source page blob snapshot. For example,\n   *                            https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n   * @param options - Options to the Page Blob Copy Incremental operation.\n   * @returns Response data for the Page Blob Copy Incremental operation.\n   */\n\n\n  startCopyIncremental(copySource, options = {}) {\n    var _this49 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"PageBlobClient-startCopyIncremental\", options);\n\n      try {\n        return yield _this49.pageBlobContext.copyIncremental(copySource, Object.assign({\n          abortSignal: options.abortSignal,\n          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), {\n            ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n          })\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n} //# sourceMappingURL=Clients.js.map","map":{"version":3,"sources":["F:/statvalu/AR_DocuExpert_Test/node_modules/@azure/storage-blob/dist-esm/storage-blob/src/Clients.js"],"names":["generateUuid","getDefaultProxySettings","isNode","isTokenCredential","URLBuilder","SpanStatusCode","BlobDownloadResponse","BlobQueryResponse","AnonymousCredential","StorageSharedKeyCredential","AppendBlob","Blob","StorageBlob","BlockBlob","PageBlob","ensureCpkIfSpecified","toAccessTier","rangeResponseFromModel","newPipeline","isPipelineLike","BlobBeginCopyFromUrlPoller","rangeToString","StorageClient","Batch","BufferScheduler","BLOCK_BLOB_MAX_BLOCKS","BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES","BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES","DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES","DEFAULT_BLOCK_BUFFER_SIZE_BYTES","DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS","ETagAny","URLConstants","createSpan","convertTracingToRequestOptionsBase","appendToURLPath","appendToURLQuery","extractConnectionStringParts","generateBlockID","getURLParameter","httpAuthorizationToString","isIpEndpointStyle","parseObjectReplicationRecord","setURLParameter","toBlobTags","toBlobTagsString","toQuerySerialization","toTags","fsCreateReadStream","fsStat","readStreamToLocalFile","streamToBuffer","generateBlobSASQueryParameters","BlobLeaseClient","BlobClient","constructor","urlOrConnectionString","credentialOrPipelineOrContainerName","blobNameOrOptions","options","pipeline","url","containerName","blobName","extractedCreds","kind","sharedKeyCredential","accountName","accountKey","encodeURIComponent","proxyOptions","proxyUri","Error","accountSas","_name","_containerName","getBlobAndContainerNamesFromUrl","blobContext","storageClientContext","_snapshot","Parameters","SNAPSHOT","_versionId","VERSIONID","name","withSnapshot","snapshot","length","undefined","withVersion","versionId","getAppendBlobClient","AppendBlobClient","getBlockBlobClient","BlockBlobClient","getPageBlobClient","PageBlobClient","download","offset","count","_a","conditions","customerProvidedKey","isHttps","span","updatedOptions","res","Object","assign","abortSignal","leaseAccessConditions","modifiedAccessConditions","ifTags","tagConditions","requestOptions","onDownloadProgress","onProgress","range","rangeGetContentMD5","rangeGetContentCRC64","rangeGetContentCrc64","cpkInfo","wrappedRes","_response","objectReplicationDestinationPolicyId","objectReplicationPolicyId","objectReplicationSourceProperties","objectReplicationRules","maxRetryRequests","contentLength","RangeError","etag","start","updatedDownloadOptions","ifMatch","ifModifiedSince","ifNoneMatch","ifUnmodifiedSince","readableStreamBody","e","setStatus","code","ERROR","message","end","exists","getProperties","tracingOptions","statusCode","delete","deleteSnapshots","deleteIfExists","_b","succeeded","details","errorCode","response","parsedHeaders","undelete","setHTTPHeaders","blobHTTPHeaders","setHttpHeaders","blobHttpHeaders","setMetadata","metadata","encryptionScope","setTags","tags","getTags","wrappedResponse","blobTagSet","getBlobLeaseClient","proposeLeaseId","createSnapshot","beginCopyFromURL","copySource","client","abortCopyFromURL","args","startCopyFromURL","poller","blobClient","intervalInMs","resumeFrom","startCopyFromURLOptions","poll","copyId","syncCopyFromURL","_c","sourceConditions","copyFromURL","sourceModifiedAccessConditions","sourceIfMatch","sourceIfModifiedSince","sourceIfNoneMatch","sourceIfUnmodifiedSince","sourceContentMD5","copySourceAuthorization","sourceAuthorization","blobTagsString","immutabilityPolicyExpiry","immutabilityPolicy","expiriesOn","immutabilityPolicyMode","policyMode","legalHold","setAccessTier","tier","setTier","rehydratePriority","downloadToBuffer","param1","param2","param3","param4","buffer","Buffer","blockSize","alloc","error","transferProgress","batch","concurrency","off","addOperation","chunkEnd","maxRetryRequestsPerBlock","stream","loadedBytes","do","downloadToFile","filePath","blobDownloadStream","parsedUrl","parse","getHost","split","pathComponents","getPath","match","decodeURIComponent","replace","sourceIfTags","sealBlob","generateSasUrl","Promise","resolve","credential","sas","snapshotTime","toString","deleteImmutabilityPolicy","setImmutabilityPolicy","modifiedAccessCondition","setLegalHold","legalHoldEnabled","appendBlobContext","create","createIfNotExists","seal","appendPositionAccessConditions","appendBlock","body","onUploadProgress","transactionalContentMD5","transactionalContentCrc64","appendBlockFromURL","sourceURL","sourceOffset","appendBlockFromUrl","sourceRange","sourceContentCrc64","blockBlobContext","_blobContext","query","queryRequest","queryType","expression","inputSerialization","inputTextConfiguration","outputSerialization","outputTextConfiguration","onError","upload","syncUploadFromURL","_d","_e","putBlobFromUrl","stageBlock","blockId","stageBlockFromURL","commitBlockList","blocks","latest","getBlockList","listType","committedBlocks","uncommittedBlocks","uploadData","data","ArrayBuffer","from","byteOffset","byteLength","uploadSeekableInternal","size","slice","browserBlob","uploadBrowserData","browserData","bodyFactory","maxSingleShotSize","Math","ceil","numBlocks","floor","blockList","blockIDPrefix","i","blockID","push","uploadFile","autoClose","Infinity","uploadStream","bufferSize","maxConcurrency","blockNum","scheduler","pageBlobContext","blobSequenceNumber","uploadPages","sequenceNumberAccessConditions","uploadPagesFromURL","destOffset","clearPages","getPageRanges","then","getPageRangesDiff","prevSnapshot","prevsnapshot","getPageRangesDiffForManagedDisks","prevSnapshotUrl","resize","updateSequenceNumber","sequenceNumberAction","sequenceNumber","startCopyIncremental","copyIncremental"],"mappings":"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","sourcesContent":["import { generateUuid, getDefaultProxySettings, isNode, isTokenCredential, URLBuilder } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { BlobDownloadResponse } from \"./BlobDownloadResponse\";\nimport { BlobQueryResponse } from \"./BlobQueryResponse\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AppendBlob, Blob as StorageBlob, BlockBlob, PageBlob } from \"./generated/src/operations\";\nimport { ensureCpkIfSpecified, toAccessTier } from \"./models\";\nimport { rangeResponseFromModel } from \"./PageBlobRangeResponse\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { BlobBeginCopyFromUrlPoller } from \"./pollers/BlobStartCopyFromUrlPoller\";\nimport { rangeToString } from \"./Range\";\nimport { StorageClient } from \"./StorageClient\";\nimport { Batch } from \"./utils/Batch\";\nimport { BufferScheduler } from \"../../storage-common/src\";\nimport { BLOCK_BLOB_MAX_BLOCKS, BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES, BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES, DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES, DEFAULT_BLOCK_BUFFER_SIZE_BYTES, DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS, ETagAny, URLConstants } from \"./utils/constants\";\nimport { createSpan, convertTracingToRequestOptionsBase } from \"./utils/tracing\";\nimport { appendToURLPath, appendToURLQuery, extractConnectionStringParts, generateBlockID, getURLParameter, httpAuthorizationToString, isIpEndpointStyle, parseObjectReplicationRecord, setURLParameter, toBlobTags, toBlobTagsString, toQuerySerialization, toTags } from \"./utils/utils.common\";\nimport { fsCreateReadStream, fsStat, readStreamToLocalFile, streamToBuffer } from \"./utils/utils.node\";\nimport { generateBlobSASQueryParameters } from \"./sas/BlobSASSignatureValues\";\nimport { BlobLeaseClient } from \"./BlobLeaseClient\";\n/**\n * A BlobClient represents a URL to an Azure Storage blob; the blob may be a block blob,\n * append blob, or page blob.\n */\nexport class BlobClient extends StorageClient {\n    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, \n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options) {\n        options = options || {};\n        let pipeline;\n        let url;\n        if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n            // (url: string, pipeline: Pipeline)\n            url = urlOrConnectionString;\n            pipeline = credentialOrPipelineOrContainerName;\n        }\n        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n            isTokenCredential(credentialOrPipelineOrContainerName)) {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            url = urlOrConnectionString;\n            options = blobNameOrOptions;\n            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n        }\n        else if (!credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName !== \"string\") {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            // The second parameter is undefined. Use anonymous credential.\n            url = urlOrConnectionString;\n            pipeline = newPipeline(new AnonymousCredential(), options);\n        }\n        else if (credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName === \"string\" &&\n            blobNameOrOptions &&\n            typeof blobNameOrOptions === \"string\") {\n            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n            const containerName = credentialOrPipelineOrContainerName;\n            const blobName = blobNameOrOptions;\n            const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n            if (extractedCreds.kind === \"AccountConnString\") {\n                if (isNode) {\n                    const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n                    url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n                    options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n                    pipeline = newPipeline(sharedKeyCredential, options);\n                }\n                else {\n                    throw new Error(\"Account connection string is only supported in Node.js environment\");\n                }\n            }\n            else if (extractedCreds.kind === \"SASConnString\") {\n                url =\n                    appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) +\n                        \"?\" +\n                        extractedCreds.accountSas;\n                pipeline = newPipeline(new AnonymousCredential(), options);\n            }\n            else {\n                throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n            }\n        }\n        else {\n            throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n        }\n        super(url, pipeline);\n        ({\n            blobName: this._name,\n            containerName: this._containerName\n        } = this.getBlobAndContainerNamesFromUrl());\n        this.blobContext = new StorageBlob(this.storageClientContext);\n        this._snapshot = getURLParameter(this.url, URLConstants.Parameters.SNAPSHOT);\n        this._versionId = getURLParameter(this.url, URLConstants.Parameters.VERSIONID);\n    }\n    /**\n     * The name of the blob.\n     */\n    get name() {\n        return this._name;\n    }\n    /**\n     * The name of the storage container the blob is associated with.\n     */\n    get containerName() {\n        return this._containerName;\n    }\n    /**\n     * Creates a new BlobClient object identical to the source but with the specified snapshot timestamp.\n     * Provide \"\" will remove the snapshot and return a Client to the base blob.\n     *\n     * @param snapshot - The snapshot timestamp.\n     * @returns A new BlobClient object identical to the source but with the specified snapshot timestamp\n     */\n    withSnapshot(snapshot) {\n        return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n    }\n    /**\n     * Creates a new BlobClient object pointing to a version of this blob.\n     * Provide \"\" will remove the versionId and return a Client to the base blob.\n     *\n     * @param versionId - The versionId.\n     * @returns A new BlobClient object pointing to the version of this blob.\n     */\n    withVersion(versionId) {\n        return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.VERSIONID, versionId.length === 0 ? undefined : versionId), this.pipeline);\n    }\n    /**\n     * Creates a AppendBlobClient object.\n     *\n     */\n    getAppendBlobClient() {\n        return new AppendBlobClient(this.url, this.pipeline);\n    }\n    /**\n     * Creates a BlockBlobClient object.\n     *\n     */\n    getBlockBlobClient() {\n        return new BlockBlobClient(this.url, this.pipeline);\n    }\n    /**\n     * Creates a PageBlobClient object.\n     *\n     */\n    getPageBlobClient() {\n        return new PageBlobClient(this.url, this.pipeline);\n    }\n    /**\n     * Reads or downloads a blob from the system, including its metadata and properties.\n     * You can also call Get Blob to read a snapshot.\n     *\n     * * In Node.js, data returns in a Readable stream readableStreamBody\n     * * In browsers, data returns in a promise blobBody\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob\n     *\n     * @param offset - From which position of the blob to download, greater than or equal to 0\n     * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined\n     * @param options - Optional options to Blob Download operation.\n     *\n     *\n     * Example usage (Node.js):\n     *\n     * ```js\n     * // Download and convert a blob to a string\n     * const downloadBlockBlobResponse = await blobClient.download();\n     * const downloaded = await streamToBuffer(downloadBlockBlobResponse.readableStreamBody);\n     * console.log(\"Downloaded blob content:\", downloaded.toString());\n     *\n     * async function streamToBuffer(readableStream) {\n     * return new Promise((resolve, reject) => {\n     * const chunks = [];\n     * readableStream.on(\"data\", (data) => {\n     * chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n     * });\n     * readableStream.on(\"end\", () => {\n     * resolve(Buffer.concat(chunks));\n     * });\n     * readableStream.on(\"error\", reject);\n     * });\n     * }\n     * ```\n     *\n     * Example usage (browser):\n     *\n     * ```js\n     * // Download and convert a blob to a string\n     * const downloadBlockBlobResponse = await blobClient.download();\n     * const downloaded = await blobToString(await downloadBlockBlobResponse.blobBody);\n     * console.log(\n     *   \"Downloaded blob content\",\n     *   downloaded\n     * );\n     *\n     * async function blobToString(blob: Blob): Promise<string> {\n     *   const fileReader = new FileReader();\n     *   return new Promise<string>((resolve, reject) => {\n     *     fileReader.onloadend = (ev: any) => {\n     *       resolve(ev.target!.result);\n     *     };\n     *     fileReader.onerror = reject;\n     *     fileReader.readAsText(blob);\n     *   });\n     * }\n     * ```\n     */\n    async download(offset = 0, count, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        options.conditions = options.conditions || {};\n        ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n        const { span, updatedOptions } = createSpan(\"BlobClient-download\", options);\n        try {\n            const res = await this.blobContext.download(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), requestOptions: {\n                    onDownloadProgress: isNode ? undefined : options.onProgress // for Node.js, progress is reported by RetriableReadableStream\n                }, range: offset === 0 && !count ? undefined : rangeToString({ offset, count }), rangeGetContentMD5: options.rangeGetContentMD5, rangeGetContentCRC64: options.rangeGetContentCrc64, snapshot: options.snapshot, cpkInfo: options.customerProvidedKey }, convertTracingToRequestOptionsBase(updatedOptions)));\n            const wrappedRes = Object.assign(Object.assign({}, res), { _response: res._response, objectReplicationDestinationPolicyId: res.objectReplicationPolicyId, objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules) });\n            // Return browser response immediately\n            if (!isNode) {\n                return wrappedRes;\n            }\n            // We support retrying when download stream unexpected ends in Node.js runtime\n            // Following code shouldn't be bundled into browser build, however some\n            // bundlers may try to bundle following code and \"FileReadResponse.ts\".\n            // In this case, \"FileDownloadResponse.browser.ts\" will be used as a shim of \"FileDownloadResponse.ts\"\n            // The config is in package.json \"browser\" field\n            if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {\n                // TODO: Default value or make it a required parameter?\n                options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;\n            }\n            if (res.contentLength === undefined) {\n                throw new RangeError(`File download response doesn't contain valid content length header`);\n            }\n            if (!res.etag) {\n                throw new RangeError(`File download response doesn't contain valid etag header`);\n            }\n            return new BlobDownloadResponse(wrappedRes, async (start) => {\n                var _a;\n                const updatedDownloadOptions = {\n                    leaseAccessConditions: options.conditions,\n                    modifiedAccessConditions: {\n                        ifMatch: options.conditions.ifMatch || res.etag,\n                        ifModifiedSince: options.conditions.ifModifiedSince,\n                        ifNoneMatch: options.conditions.ifNoneMatch,\n                        ifUnmodifiedSince: options.conditions.ifUnmodifiedSince,\n                        ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions\n                    },\n                    range: rangeToString({\n                        count: offset + res.contentLength - start,\n                        offset: start\n                    }),\n                    rangeGetContentMD5: options.rangeGetContentMD5,\n                    rangeGetContentCRC64: options.rangeGetContentCrc64,\n                    snapshot: options.snapshot,\n                    cpkInfo: options.customerProvidedKey\n                };\n                // Debug purpose only\n                // console.log(\n                //   `Read from internal stream, range: ${\n                //     updatedOptions.range\n                //   }, options: ${JSON.stringify(updatedOptions)}`\n                // );\n                return (await this.blobContext.download(Object.assign({ abortSignal: options.abortSignal }, updatedDownloadOptions))).readableStreamBody;\n            }, offset, res.contentLength, {\n                maxRetryRequests: options.maxRetryRequests,\n                onProgress: options.onProgress\n            });\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns true if the Azure blob resource represented by this client exists; false otherwise.\n     *\n     * NOTE: use this function with care since an existing blob might be deleted by other clients or\n     * applications. Vice versa new blobs might be added by other clients or applications after this\n     * function completes.\n     *\n     * @param options - options to Exists operation.\n     */\n    async exists(options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-exists\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            await this.getProperties({\n                abortSignal: options.abortSignal,\n                customerProvidedKey: options.customerProvidedKey,\n                conditions: options.conditions,\n                tracingOptions: updatedOptions.tracingOptions\n            });\n            return true;\n        }\n        catch (e) {\n            if (e.statusCode === 404) {\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: \"Expected exception when checking blob existence\"\n                });\n                return false;\n            }\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns all user-defined metadata, standard HTTP properties, and system properties\n     * for the blob. It does not return the content of the blob.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-properties\n     *\n     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n     * they originally contained uppercase characters. This differs from the metadata keys returned by\n     * the methods of {@link ContainerClient} that list blobs using the `includeMetadata` option, which\n     * will retain their original casing.\n     *\n     * @param options - Optional options to Get Properties operation.\n     */\n    async getProperties(options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-getProperties\", options);\n        try {\n            options.conditions = options.conditions || {};\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            const res = await this.blobContext.getProperties(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), cpkInfo: options.customerProvidedKey }, convertTracingToRequestOptionsBase(updatedOptions)));\n            return Object.assign(Object.assign({}, res), { _response: res._response, objectReplicationDestinationPolicyId: res.objectReplicationPolicyId, objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules) });\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Marks the specified blob or snapshot for deletion. The blob is later deleted\n     * during garbage collection. Note that in order to delete a blob, you must delete\n     * all of its snapshots. You can delete both at the same time with the Delete\n     * Blob operation.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n     *\n     * @param options - Optional options to Blob Delete operation.\n     */\n    async delete(options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-delete\", options);\n        options.conditions = options.conditions || {};\n        try {\n            return await this.blobContext.delete(Object.assign({ abortSignal: options.abortSignal, deleteSnapshots: options.deleteSnapshots, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Marks the specified blob or snapshot for deletion if it exists. The blob is later deleted\n     * during garbage collection. Note that in order to delete a blob, you must delete\n     * all of its snapshots. You can delete both at the same time with the Delete\n     * Blob operation.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n     *\n     * @param options - Optional options to Blob Delete operation.\n     */\n    async deleteIfExists(options = {}) {\n        var _a, _b;\n        const { span, updatedOptions } = createSpan(\"BlobClient-deleteIfExists\", options);\n        try {\n            const res = await this.delete(updatedOptions);\n            return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response // _response is made non-enumerable\n             });\n        }\n        catch (e) {\n            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobNotFound\") {\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: \"Expected exception when deleting a blob or snapshot only if it exists.\"\n                });\n                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });\n            }\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Restores the contents and metadata of soft deleted blob and any associated\n     * soft deleted snapshots. Undelete Blob is supported only on version 2017-07-29\n     * or later.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/undelete-blob\n     *\n     * @param options - Optional options to Blob Undelete operation.\n     */\n    async undelete(options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-undelete\", options);\n        try {\n            return await this.blobContext.undelete(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets system properties on the blob.\n     *\n     * If no value provided, or no value provided for the specified blob HTTP headers,\n     * these blob HTTP headers without a value will be cleared.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n     *\n     * @param blobHTTPHeaders - If no value provided, or no value provided for\n     *                                                   the specified blob HTTP headers, these blob HTTP\n     *                                                   headers without a value will be cleared.\n     *                                                   A common header to set is `blobContentType`\n     *                                                   enabling the browser to provide functionality\n     *                                                   based on file type.\n     * @param options - Optional options to Blob Set HTTP Headers operation.\n     */\n    async setHTTPHeaders(blobHTTPHeaders, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-setHTTPHeaders\", options);\n        options.conditions = options.conditions || {};\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blobContext.setHttpHeaders(Object.assign({ abortSignal: options.abortSignal, blobHttpHeaders: blobHTTPHeaders, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets user-defined metadata for the specified blob as one or more name-value pairs.\n     *\n     * If no option provided, or no metadata defined in the parameter, the blob\n     * metadata will be removed.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata\n     *\n     * @param metadata - Replace existing metadata with this value.\n     *                               If no value provided the existing metadata will be removed.\n     * @param options - Optional options to Set Metadata operation.\n     */\n    async setMetadata(metadata, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-setMetadata\", options);\n        options.conditions = options.conditions || {};\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blobContext.setMetadata(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets tags on the underlying blob.\n     * A blob can have up to 10 tags. Tag keys must be between 1 and 128 characters.  Tag values must be between 0 and 256 characters.\n     * Valid tag key and value characters include lower and upper case letters, digits (0-9),\n     * space (' '), plus ('+'), minus ('-'), period ('.'), foward slash ('/'), colon (':'), equals ('='), and underscore ('_').\n     *\n     * @param tags -\n     * @param options -\n     */\n    async setTags(tags, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-setTags\", options);\n        try {\n            return await this.blobContext.setTags(Object.assign(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)), { tags: toBlobTags(tags) }));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Gets the tags associated with the underlying blob.\n     *\n     * @param options -\n     */\n    async getTags(options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-getTags\", options);\n        try {\n            const response = await this.blobContext.getTags(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n            const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, tags: toTags({ blobTagSet: response.blobTagSet }) || {} });\n            return wrappedResponse;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Get a {@link BlobLeaseClient} that manages leases on the blob.\n     *\n     * @param proposeLeaseId - Initial proposed lease Id.\n     * @returns A new BlobLeaseClient object for managing leases on the blob.\n     */\n    getBlobLeaseClient(proposeLeaseId) {\n        return new BlobLeaseClient(this, proposeLeaseId);\n    }\n    /**\n     * Creates a read-only snapshot of a blob.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/snapshot-blob\n     *\n     * @param options - Optional options to the Blob Create Snapshot operation.\n     */\n    async createSnapshot(options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-createSnapshot\", options);\n        options.conditions = options.conditions || {};\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blobContext.createSnapshot(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, metadata: options.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Asynchronously copies a blob to a destination within the storage account.\n     * This method returns a long running operation poller that allows you to wait\n     * indefinitely until the copy is completed.\n     * You can also cancel a copy before it is completed by calling `cancelOperation` on the poller.\n     * Note that the onProgress callback will not be invoked if the operation completes in the first\n     * request, and attempting to cancel a completed copy will result in an error being thrown.\n     *\n     * In version 2012-02-12 and later, the source for a Copy Blob operation can be\n     * a committed blob in any Azure storage account.\n     * Beginning with version 2015-02-21, the source for a Copy Blob operation can be\n     * an Azure file in any Azure storage account.\n     * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob\n     * operation to copy from another storage account.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob\n     *\n     * Example using automatic polling:\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url');\n     * const result = await copyPoller.pollUntilDone();\n     * ```\n     *\n     * Example using manual polling:\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url');\n     * while (!poller.isDone()) {\n     *    await poller.poll();\n     * }\n     * const result = copyPoller.getResult();\n     * ```\n     *\n     * Example using progress updates:\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url', {\n     *   onProgress(state) {\n     *     console.log(`Progress: ${state.copyProgress}`);\n     *   }\n     * });\n     * const result = await copyPoller.pollUntilDone();\n     * ```\n     *\n     * Example using a changing polling interval (default 15 seconds):\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url', {\n     *   intervalInMs: 1000 // poll blob every 1 second for copy progress\n     * });\n     * const result = await copyPoller.pollUntilDone();\n     * ```\n     *\n     * Example using copy cancellation:\n     *\n     * ```js\n     * const copyPoller = await blobClient.beginCopyFromURL('url');\n     * // cancel operation after starting it.\n     * try {\n     *   await copyPoller.cancelOperation();\n     *   // calls to get the result now throw PollerCancelledError\n     *   await copyPoller.getResult();\n     * } catch (err) {\n     *   if (err.name === 'PollerCancelledError') {\n     *     console.log('The copy was cancelled.');\n     *   }\n     * }\n     * ```\n     *\n     * @param copySource - url to the source Azure Blob/File.\n     * @param options - Optional options to the Blob Start Copy From URL operation.\n     */\n    async beginCopyFromURL(copySource, options = {}) {\n        const client = {\n            abortCopyFromURL: (...args) => this.abortCopyFromURL(...args),\n            getProperties: (...args) => this.getProperties(...args),\n            startCopyFromURL: (...args) => this.startCopyFromURL(...args)\n        };\n        const poller = new BlobBeginCopyFromUrlPoller({\n            blobClient: client,\n            copySource,\n            intervalInMs: options.intervalInMs,\n            onProgress: options.onProgress,\n            resumeFrom: options.resumeFrom,\n            startCopyFromURLOptions: options\n        });\n        // Trigger the startCopyFromURL call by calling poll.\n        // Any errors from this method should be surfaced to the user.\n        await poller.poll();\n        return poller;\n    }\n    /**\n     * Aborts a pending asynchronous Copy Blob operation, and leaves a destination blob with zero\n     * length and full metadata. Version 2012-02-12 and newer.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-blob\n     *\n     * @param copyId - Id of the Copy From URL operation.\n     * @param options - Optional options to the Blob Abort Copy From URL operation.\n     */\n    async abortCopyFromURL(copyId, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-abortCopyFromURL\", options);\n        try {\n            return await this.blobContext.abortCopyFromURL(copyId, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * The synchronous Copy From URL operation copies a blob or an internet resource to a new blob. It will not\n     * return a response until the copy is complete.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob-from-url\n     *\n     * @param copySource - The source URL to copy from, Shared Access Signature(SAS) maybe needed for authentication\n     * @param options -\n     */\n    async syncCopyFromURL(copySource, options = {}) {\n        var _a, _b, _c;\n        const { span, updatedOptions } = createSpan(\"BlobClient-syncCopyFromURL\", options);\n        options.conditions = options.conditions || {};\n        options.sourceConditions = options.sourceConditions || {};\n        try {\n            return await this.blobContext.copyFromURL(copySource, Object.assign({ abortSignal: options.abortSignal, metadata: options.metadata, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), sourceModifiedAccessConditions: {\n                    sourceIfMatch: options.sourceConditions.ifMatch,\n                    sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n                    sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n                    sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince\n                }, sourceContentMD5: options.sourceContentMD5, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization), blobTagsString: toBlobTagsString(options.tags), immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn, immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode, legalHold: options.legalHold }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets the tier on a blob. The operation is allowed on a page blob in a premium\n     * storage account and on a block blob in a blob storage account (locally redundant\n     * storage only). A premium page blob's tier determines the allowed size, IOPS,\n     * and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive\n     * storage type. This operation does not update the blob's ETag.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-tier\n     *\n     * @param tier - The tier to be set on the blob. Valid values are Hot, Cool, or Archive.\n     * @param options - Optional options to the Blob Set Tier operation.\n     */\n    async setAccessTier(tier, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobClient-setAccessTier\", options);\n        try {\n            return await this.blobContext.setTier(toAccessTier(tier), Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), rehydratePriority: options.rehydratePriority }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    async downloadToBuffer(param1, param2, param3, param4 = {}) {\n        let buffer;\n        let offset = 0;\n        let count = 0;\n        let options = param4;\n        if (param1 instanceof Buffer) {\n            buffer = param1;\n            offset = param2 || 0;\n            count = typeof param3 === \"number\" ? param3 : 0;\n        }\n        else {\n            offset = typeof param1 === \"number\" ? param1 : 0;\n            count = typeof param2 === \"number\" ? param2 : 0;\n            options = param3 || {};\n        }\n        const { span, updatedOptions } = createSpan(\"BlobClient-downloadToBuffer\", options);\n        try {\n            if (!options.blockSize) {\n                options.blockSize = 0;\n            }\n            if (options.blockSize < 0) {\n                throw new RangeError(\"blockSize option must be >= 0\");\n            }\n            if (options.blockSize === 0) {\n                options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;\n            }\n            if (offset < 0) {\n                throw new RangeError(\"offset option must be >= 0\");\n            }\n            if (count && count <= 0) {\n                throw new RangeError(\"count option must be greater than 0\");\n            }\n            if (!options.conditions) {\n                options.conditions = {};\n            }\n            // Customer doesn't specify length, get it\n            if (!count) {\n                const response = await this.getProperties(Object.assign(Object.assign({}, options), { tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions)) }));\n                count = response.contentLength - offset;\n                if (count < 0) {\n                    throw new RangeError(`offset ${offset} shouldn't be larger than blob size ${response.contentLength}`);\n                }\n            }\n            // Allocate the buffer of size = count if the buffer is not provided\n            if (!buffer) {\n                try {\n                    buffer = Buffer.alloc(count);\n                }\n                catch (error) {\n                    throw new Error(`Unable to allocate the buffer of size: ${count}(in bytes). Please try passing your own buffer to the \"downloadToBuffer\" method or try using other methods like \"download\" or \"downloadToFile\".\\t ${error.message}`);\n                }\n            }\n            if (buffer.length < count) {\n                throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);\n            }\n            let transferProgress = 0;\n            const batch = new Batch(options.concurrency);\n            for (let off = offset; off < offset + count; off = off + options.blockSize) {\n                batch.addOperation(async () => {\n                    // Exclusive chunk end position\n                    let chunkEnd = offset + count;\n                    if (off + options.blockSize < chunkEnd) {\n                        chunkEnd = off + options.blockSize;\n                    }\n                    const response = await this.download(off, chunkEnd - off, {\n                        abortSignal: options.abortSignal,\n                        conditions: options.conditions,\n                        maxRetryRequests: options.maxRetryRequestsPerBlock,\n                        customerProvidedKey: options.customerProvidedKey,\n                        tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))\n                    });\n                    const stream = response.readableStreamBody;\n                    await streamToBuffer(stream, buffer, off - offset, chunkEnd - offset);\n                    // Update progress after block is downloaded, in case of block trying\n                    // Could provide finer grained progress updating inside HTTP requests,\n                    // only if convenience layer download try is enabled\n                    transferProgress += chunkEnd - off;\n                    if (options.onProgress) {\n                        options.onProgress({ loadedBytes: transferProgress });\n                    }\n                });\n            }\n            await batch.do();\n            return buffer;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * ONLY AVAILABLE IN NODE.JS RUNTIME.\n     *\n     * Downloads an Azure Blob to a local file.\n     * Fails if the the given file path already exits.\n     * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.\n     *\n     * @param filePath -\n     * @param offset - From which position of the block blob to download.\n     * @param count - How much data to be downloaded. Will download to the end when passing undefined.\n     * @param options - Options to Blob download options.\n     * @returns The response data for blob download operation,\n     *                                                 but with readableStreamBody set to undefined since its\n     *                                                 content is already read and written into a local file\n     *                                                 at the specified path.\n     */\n    async downloadToFile(filePath, offset = 0, count, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-downloadToFile\", options);\n        try {\n            const response = await this.download(offset, count, Object.assign(Object.assign({}, options), { tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions)) }));\n            if (response.readableStreamBody) {\n                await readStreamToLocalFile(response.readableStreamBody, filePath);\n            }\n            // The stream is no longer accessible so setting it to undefined.\n            response.blobDownloadStream = undefined;\n            return response;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    getBlobAndContainerNamesFromUrl() {\n        let containerName;\n        let blobName;\n        try {\n            //  URL may look like the following\n            // \"https://myaccount.blob.core.windows.net/mycontainer/blob?sasString\";\n            // \"https://myaccount.blob.core.windows.net/mycontainer/blob\";\n            // \"https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt?sasString\";\n            // \"https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt\";\n            // IPv4/IPv6 address hosts, Endpoints - `http://127.0.0.1:10000/devstoreaccount1/containername/blob`\n            // http://localhost:10001/devstoreaccount1/containername/blob\n            const parsedUrl = URLBuilder.parse(this.url);\n            if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n                // \"https://myaccount.blob.core.windows.net/containername/blob\".\n                // .getPath() -> /containername/blob\n                const pathComponents = parsedUrl.getPath().match(\"/([^/]*)(/(.*))?\");\n                containerName = pathComponents[1];\n                blobName = pathComponents[3];\n            }\n            else if (isIpEndpointStyle(parsedUrl)) {\n                // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/containername/blob\n                // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/containername/blob\n                // .getPath() -> /devstoreaccount1/containername/blob\n                const pathComponents = parsedUrl.getPath().match(\"/([^/]*)/([^/]*)(/(.*))?\");\n                containerName = pathComponents[2];\n                blobName = pathComponents[4];\n            }\n            else {\n                // \"https://customdomain.com/containername/blob\".\n                // .getPath() -> /containername/blob\n                const pathComponents = parsedUrl.getPath().match(\"/([^/]*)(/(.*))?\");\n                containerName = pathComponents[1];\n                blobName = pathComponents[3];\n            }\n            // decode the encoded blobName, containerName - to get all the special characters that might be present in them\n            containerName = decodeURIComponent(containerName);\n            blobName = decodeURIComponent(blobName);\n            // Azure Storage Server will replace \"\\\" with \"/\" in the blob names\n            //   doing the same in the SDK side so that the user doesn't have to replace \"\\\" instances in the blobName\n            blobName = blobName.replace(/\\\\/g, \"/\");\n            if (!containerName) {\n                throw new Error(\"Provided containerName is invalid.\");\n            }\n            return { blobName, containerName };\n        }\n        catch (error) {\n            throw new Error(\"Unable to extract blobName and containerName with provided information.\");\n        }\n    }\n    /**\n     * Asynchronously copies a blob to a destination within the storage account.\n     * In version 2012-02-12 and later, the source for a Copy Blob operation can be\n     * a committed blob in any Azure storage account.\n     * Beginning with version 2015-02-21, the source for a Copy Blob operation can be\n     * an Azure file in any Azure storage account.\n     * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob\n     * operation to copy from another storage account.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob\n     *\n     * @param copySource - url to the source Azure Blob/File.\n     * @param options - Optional options to the Blob Start Copy From URL operation.\n     */\n    async startCopyFromURL(copySource, options = {}) {\n        var _a, _b, _c;\n        const { span, updatedOptions } = createSpan(\"BlobClient-startCopyFromURL\", options);\n        options.conditions = options.conditions || {};\n        options.sourceConditions = options.sourceConditions || {};\n        try {\n            return await this.blobContext.startCopyFromURL(copySource, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, metadata: options.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), sourceModifiedAccessConditions: {\n                    sourceIfMatch: options.sourceConditions.ifMatch,\n                    sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n                    sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n                    sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,\n                    sourceIfTags: options.sourceConditions.tagConditions\n                }, immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn, immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode, legalHold: options.legalHold, rehydratePriority: options.rehydratePriority, tier: toAccessTier(options.tier), blobTagsString: toBlobTagsString(options.tags), sealBlob: options.sealBlob }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Only available for BlobClient constructed with a shared key credential.\n     *\n     * Generates a Blob Service Shared Access Signature (SAS) URI based on the client properties\n     * and parameters passed in. The SAS is signed by the shared key credential of the client.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n     *\n     * @param options - Optional parameters.\n     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n     */\n    generateSasUrl(options) {\n        return new Promise((resolve) => {\n            if (!(this.credential instanceof StorageSharedKeyCredential)) {\n                throw new RangeError(\"Can only generate the SAS when the client is initialized with a shared key credential\");\n            }\n            const sas = generateBlobSASQueryParameters(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, options), this.credential).toString();\n            resolve(appendToURLQuery(this.url, sas));\n        });\n    }\n    /**\n     * Delete the immutablility policy on the blob.\n     *\n     * @param options - Optional options to delete immutability policy on the blob.\n     */\n    async deleteImmutabilityPolicy(options) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-deleteImmutabilityPolicy\", options);\n        try {\n            return await this.blobContext.deleteImmutabilityPolicy(Object.assign({ abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Set immutablility policy on the blob.\n     *\n     * @param options - Optional options to set immutability policy on the blob.\n     */\n    async setImmutabilityPolicy(immutabilityPolicy, options) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-setImmutabilityPolicy\", options);\n        try {\n            return await this.blobContext.setImmutabilityPolicy(Object.assign({ abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal, immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn, immutabilityPolicyMode: immutabilityPolicy.policyMode, modifiedAccessConditions: options === null || options === void 0 ? void 0 : options.modifiedAccessCondition }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Set legal hold on the blob.\n     *\n     * @param options - Optional options to set legal hold on the blob.\n     */\n    async setLegalHold(legalHoldEnabled, options) {\n        const { span, updatedOptions } = createSpan(\"BlobClient-setLegalHold\", options);\n        try {\n            return await this.blobContext.setLegalHold(legalHoldEnabled, Object.assign({ abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n}\n/**\n * AppendBlobClient defines a set of operations applicable to append blobs.\n */\nexport class AppendBlobClient extends BlobClient {\n    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, \n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options) {\n        // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n        //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n        let pipeline;\n        let url;\n        options = options || {};\n        if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n            // (url: string, pipeline: Pipeline)\n            url = urlOrConnectionString;\n            pipeline = credentialOrPipelineOrContainerName;\n        }\n        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n            isTokenCredential(credentialOrPipelineOrContainerName)) {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)      url = urlOrConnectionString;\n            url = urlOrConnectionString;\n            options = blobNameOrOptions;\n            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n        }\n        else if (!credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName !== \"string\") {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            url = urlOrConnectionString;\n            // The second parameter is undefined. Use anonymous credential.\n            pipeline = newPipeline(new AnonymousCredential(), options);\n        }\n        else if (credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName === \"string\" &&\n            blobNameOrOptions &&\n            typeof blobNameOrOptions === \"string\") {\n            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n            const containerName = credentialOrPipelineOrContainerName;\n            const blobName = blobNameOrOptions;\n            const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n            if (extractedCreds.kind === \"AccountConnString\") {\n                if (isNode) {\n                    const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n                    url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n                    options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n                    pipeline = newPipeline(sharedKeyCredential, options);\n                }\n                else {\n                    throw new Error(\"Account connection string is only supported in Node.js environment\");\n                }\n            }\n            else if (extractedCreds.kind === \"SASConnString\") {\n                url =\n                    appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) +\n                        \"?\" +\n                        extractedCreds.accountSas;\n                pipeline = newPipeline(new AnonymousCredential(), options);\n            }\n            else {\n                throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n            }\n        }\n        else {\n            throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n        }\n        super(url, pipeline);\n        this.appendBlobContext = new AppendBlob(this.storageClientContext);\n    }\n    /**\n     * Creates a new AppendBlobClient object identical to the source but with the\n     * specified snapshot timestamp.\n     * Provide \"\" will remove the snapshot and return a Client to the base blob.\n     *\n     * @param snapshot - The snapshot timestamp.\n     * @returns A new AppendBlobClient object identical to the source but with the specified snapshot timestamp.\n     */\n    withSnapshot(snapshot) {\n        return new AppendBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n    }\n    /**\n     * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param options - Options to the Append Block Create operation.\n     *\n     *\n     * Example usage:\n     *\n     * ```js\n     * const appendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n     * await appendBlobClient.create();\n     * ```\n     */\n    async create(options = {}) {\n        var _a, _b, _c;\n        const { span, updatedOptions } = createSpan(\"AppendBlobClient-create\", options);\n        options.conditions = options.conditions || {};\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.appendBlobContext.create(0, Object.assign({ abortSignal: options.abortSignal, blobHttpHeaders: options.blobHTTPHeaders, leaseAccessConditions: options.conditions, metadata: options.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope, immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn, immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode, legalHold: options.legalHold, blobTagsString: toBlobTagsString(options.tags) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.\n     * If the blob with the same name already exists, the content of the existing blob will remain unchanged.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param options -\n     */\n    async createIfNotExists(options = {}) {\n        var _a, _b;\n        const { span, updatedOptions } = createSpan(\"AppendBlobClient-createIfNotExists\", options);\n        const conditions = { ifNoneMatch: ETagAny };\n        try {\n            const res = await this.create(Object.assign(Object.assign({}, updatedOptions), { conditions }));\n            return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response // _response is made non-enumerable\n             });\n        }\n        catch (e) {\n            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobAlreadyExists\") {\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: \"Expected exception when creating a blob only if it does not already exist.\"\n                });\n                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });\n            }\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Seals the append blob, making it read only.\n     *\n     * @param options -\n     */\n    async seal(options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"AppendBlobClient-seal\", options);\n        options.conditions = options.conditions || {};\n        try {\n            return await this.appendBlobContext.seal(Object.assign({ abortSignal: options.abortSignal, appendPositionAccessConditions: options.conditions, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Commits a new block of data to the end of the existing append blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/append-block\n     *\n     * @param body - Data to be appended.\n     * @param contentLength - Length of the body in bytes.\n     * @param options - Options to the Append Block operation.\n     *\n     *\n     * Example usage:\n     *\n     * ```js\n     * const content = \"Hello World!\";\n     *\n     * // Create a new append blob and append data to the blob.\n     * const newAppendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n     * await newAppendBlobClient.create();\n     * await newAppendBlobClient.appendBlock(content, content.length);\n     *\n     * // Append data to an existing append blob.\n     * const existingAppendBlobClient = containerClient.getAppendBlobClient(\"<blob name>\");\n     * await existingAppendBlobClient.appendBlock(content, content.length);\n     * ```\n     */\n    async appendBlock(body, contentLength, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"AppendBlobClient-appendBlock\", options);\n        options.conditions = options.conditions || {};\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.appendBlobContext.appendBlock(contentLength, body, Object.assign({ abortSignal: options.abortSignal, appendPositionAccessConditions: options.conditions, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), requestOptions: {\n                    onUploadProgress: options.onProgress\n                }, transactionalContentMD5: options.transactionalContentMD5, transactionalContentCrc64: options.transactionalContentCrc64, cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * The Append Block operation commits a new block of data to the end of an existing append blob\n     * where the contents are read from a source url.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/append-block-from-url\n     *\n     * @param sourceURL -\n     *                 The url to the blob that will be the source of the copy. A source blob in the same storage account can\n     *                 be authenticated via Shared Key. However, if the source is a blob in another account, the source blob\n     *                 must either be public or must be authenticated via a shared access signature. If the source blob is\n     *                 public, no authentication is required to perform the operation.\n     * @param sourceOffset - Offset in source to be appended\n     * @param count - Number of bytes to be appended as a block\n     * @param options -\n     */\n    async appendBlockFromURL(sourceURL, sourceOffset, count, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"AppendBlobClient-appendBlockFromURL\", options);\n        options.conditions = options.conditions || {};\n        options.sourceConditions = options.sourceConditions || {};\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, Object.assign({ abortSignal: options.abortSignal, sourceRange: rangeToString({ offset: sourceOffset, count }), sourceContentMD5: options.sourceContentMD5, sourceContentCrc64: options.sourceContentCrc64, leaseAccessConditions: options.conditions, appendPositionAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), sourceModifiedAccessConditions: {\n                    sourceIfMatch: options.sourceConditions.ifMatch,\n                    sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n                    sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n                    sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince\n                }, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n}\n/**\n * BlockBlobClient defines a set of operations applicable to block blobs.\n */\nexport class BlockBlobClient extends BlobClient {\n    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, \n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options) {\n        // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n        //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n        let pipeline;\n        let url;\n        options = options || {};\n        if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n            // (url: string, pipeline: Pipeline)\n            url = urlOrConnectionString;\n            pipeline = credentialOrPipelineOrContainerName;\n        }\n        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n            isTokenCredential(credentialOrPipelineOrContainerName)) {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            url = urlOrConnectionString;\n            options = blobNameOrOptions;\n            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n        }\n        else if (!credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName !== \"string\") {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            // The second parameter is undefined. Use anonymous credential.\n            url = urlOrConnectionString;\n            pipeline = newPipeline(new AnonymousCredential(), options);\n        }\n        else if (credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName === \"string\" &&\n            blobNameOrOptions &&\n            typeof blobNameOrOptions === \"string\") {\n            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n            const containerName = credentialOrPipelineOrContainerName;\n            const blobName = blobNameOrOptions;\n            const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n            if (extractedCreds.kind === \"AccountConnString\") {\n                if (isNode) {\n                    const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n                    url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n                    options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n                    pipeline = newPipeline(sharedKeyCredential, options);\n                }\n                else {\n                    throw new Error(\"Account connection string is only supported in Node.js environment\");\n                }\n            }\n            else if (extractedCreds.kind === \"SASConnString\") {\n                url =\n                    appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) +\n                        \"?\" +\n                        extractedCreds.accountSas;\n                pipeline = newPipeline(new AnonymousCredential(), options);\n            }\n            else {\n                throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n            }\n        }\n        else {\n            throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n        }\n        super(url, pipeline);\n        this.blockBlobContext = new BlockBlob(this.storageClientContext);\n        this._blobContext = new StorageBlob(this.storageClientContext);\n    }\n    /**\n     * Creates a new BlockBlobClient object identical to the source but with the\n     * specified snapshot timestamp.\n     * Provide \"\" will remove the snapshot and return a URL to the base blob.\n     *\n     * @param snapshot - The snapshot timestamp.\n     * @returns A new BlockBlobClient object identical to the source but with the specified snapshot timestamp.\n     */\n    withSnapshot(snapshot) {\n        return new BlockBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n    }\n    /**\n     * ONLY AVAILABLE IN NODE.JS RUNTIME.\n     *\n     * Quick query for a JSON or CSV formatted blob.\n     *\n     * Example usage (Node.js):\n     *\n     * ```js\n     * // Query and convert a blob to a string\n     * const queryBlockBlobResponse = await blockBlobClient.query(\"select * from BlobStorage\");\n     * const downloaded = (await streamToBuffer(queryBlockBlobResponse.readableStreamBody)).toString();\n     * console.log(\"Query blob content:\", downloaded);\n     *\n     * async function streamToBuffer(readableStream) {\n     *   return new Promise((resolve, reject) => {\n     *     const chunks = [];\n     *     readableStream.on(\"data\", (data) => {\n     *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));\n     *     });\n     *     readableStream.on(\"end\", () => {\n     *       resolve(Buffer.concat(chunks));\n     *     });\n     *     readableStream.on(\"error\", reject);\n     *   });\n     * }\n     * ```\n     *\n     * @param query -\n     * @param options -\n     */\n    async query(query, options = {}) {\n        var _a;\n        ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-query\", options);\n        try {\n            if (!isNode) {\n                throw new Error(\"This operation currently is only supported in Node.js.\");\n            }\n            const response = await this._blobContext.query(Object.assign({ abortSignal: options.abortSignal, queryRequest: {\n                    queryType: \"SQL\",\n                    expression: query,\n                    inputSerialization: toQuerySerialization(options.inputTextConfiguration),\n                    outputSerialization: toQuerySerialization(options.outputTextConfiguration)\n                }, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n            return new BlobQueryResponse(response, {\n                abortSignal: options.abortSignal,\n                onProgress: options.onProgress,\n                onError: options.onError\n            });\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Creates a new block blob, or updates the content of an existing block blob.\n     * Updating an existing block blob overwrites any existing metadata on the blob.\n     * Partial updates are not supported; the content of the existing blob is\n     * overwritten with the new content. To perform a partial update of a block blob's,\n     * use {@link stageBlock} and {@link commitBlockList}.\n     *\n     * This is a non-parallel uploading method, please use {@link uploadFile},\n     * {@link uploadStream} or {@link uploadBrowserData} for better performance\n     * with concurrency uploading.\n     *\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function\n     *                               which returns a new Readable stream whose offset is from data source beginning.\n     * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a\n     *                               string including non non-Base64/Hex-encoded characters.\n     * @param options - Options to the Block Blob Upload operation.\n     * @returns Response data for the Block Blob Upload operation.\n     *\n     * Example usage:\n     *\n     * ```js\n     * const content = \"Hello world!\";\n     * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);\n     * ```\n     */\n    async upload(body, contentLength, options = {}) {\n        var _a, _b, _c;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-upload\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blockBlobContext.upload(contentLength, body, Object.assign({ abortSignal: options.abortSignal, blobHttpHeaders: options.blobHTTPHeaders, leaseAccessConditions: options.conditions, metadata: options.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), requestOptions: {\n                    onUploadProgress: options.onProgress\n                }, cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope, immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn, immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode, legalHold: options.legalHold, tier: toAccessTier(options.tier), blobTagsString: toBlobTagsString(options.tags) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Creates a new Block Blob where the contents of the blob are read from a given URL.\n     * This API is supported beginning with the 2020-04-08 version. Partial updates\n     * are not supported with Put Blob from URL; the content of an existing blob is overwritten with\n     * the content of the new blob.  To perform partial updates to a block blob’s contents using a\n     * source URL, use {@link stageBlockFromURL} and {@link commitBlockList}.\n     *\n     * @param sourceURL - Specifies the URL of the blob. The value\n     *                           may be a URL of up to 2 KB in length that specifies a blob.\n     *                           The value should be URL-encoded as it would appear\n     *                           in a request URI. The source blob must either be public\n     *                           or must be authenticated via a shared access signature.\n     *                           If the source blob is public, no authentication is required\n     *                           to perform the operation. Here are some examples of source object URLs:\n     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob\n     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n     * @param options - Optional parameters.\n     */\n    async syncUploadFromURL(sourceURL, options = {}) {\n        var _a, _b, _c, _d, _e;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-syncUploadFromURL\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blockBlobContext.putBlobFromUrl(0, sourceURL, Object.assign(Object.assign(Object.assign({}, options), { blobHttpHeaders: options.blobHTTPHeaders, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: options.conditions.tagConditions }), sourceModifiedAccessConditions: {\n                    sourceIfMatch: (_a = options.sourceConditions) === null || _a === void 0 ? void 0 : _a.ifMatch,\n                    sourceIfModifiedSince: (_b = options.sourceConditions) === null || _b === void 0 ? void 0 : _b.ifModifiedSince,\n                    sourceIfNoneMatch: (_c = options.sourceConditions) === null || _c === void 0 ? void 0 : _c.ifNoneMatch,\n                    sourceIfUnmodifiedSince: (_d = options.sourceConditions) === null || _d === void 0 ? void 0 : _d.ifUnmodifiedSince,\n                    sourceIfTags: (_e = options.sourceConditions) === null || _e === void 0 ? void 0 : _e.tagConditions\n                }, cpkInfo: options.customerProvidedKey, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization), tier: toAccessTier(options.tier), blobTagsString: toBlobTagsString(options.tags) }), convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Uploads the specified block to the block blob's \"staging area\" to be later\n     * committed by a call to commitBlockList.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-block\n     *\n     * @param blockId - A 64-byte value that is base64-encoded\n     * @param body - Data to upload to the staging area.\n     * @param contentLength - Number of bytes to upload.\n     * @param options - Options to the Block Blob Stage Block operation.\n     * @returns Response data for the Block Blob Stage Block operation.\n     */\n    async stageBlock(blockId, body, contentLength, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-stageBlock\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blockBlobContext.stageBlock(blockId, contentLength, body, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, requestOptions: {\n                    onUploadProgress: options.onProgress\n                }, transactionalContentMD5: options.transactionalContentMD5, transactionalContentCrc64: options.transactionalContentCrc64, cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * The Stage Block From URL operation creates a new block to be committed as part\n     * of a blob where the contents are read from a URL.\n     * This API is available starting in version 2018-03-28.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-block-from-url\n     *\n     * @param blockId - A 64-byte value that is base64-encoded\n     * @param sourceURL - Specifies the URL of the blob. The value\n     *                           may be a URL of up to 2 KB in length that specifies a blob.\n     *                           The value should be URL-encoded as it would appear\n     *                           in a request URI. The source blob must either be public\n     *                           or must be authenticated via a shared access signature.\n     *                           If the source blob is public, no authentication is required\n     *                           to perform the operation. Here are some examples of source object URLs:\n     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob\n     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n     * @param offset - From which position of the blob to download, greater than or equal to 0\n     * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined\n     * @param options - Options to the Block Blob Stage Block From URL operation.\n     * @returns Response data for the Block Blob Stage Block From URL operation.\n     */\n    async stageBlockFromURL(blockId, sourceURL, offset = 0, count, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-stageBlockFromURL\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, sourceContentMD5: options.sourceContentMD5, sourceContentCrc64: options.sourceContentCrc64, sourceRange: offset === 0 && !count ? undefined : rangeToString({ offset, count }), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Writes a blob by specifying the list of block IDs that make up the blob.\n     * In order to be written as part of a blob, a block must have been successfully written\n     * to the server in a prior {@link stageBlock} operation. You can call {@link commitBlockList} to\n     * update a blob by uploading only those blocks that have changed, then committing the new and existing\n     * blocks together. Any blocks not specified in the block list and permanently deleted.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-block-list\n     *\n     * @param blocks -  Array of 64-byte value that is base64-encoded\n     * @param options - Options to the Block Blob Commit Block List operation.\n     * @returns Response data for the Block Blob Commit Block List operation.\n     */\n    async commitBlockList(blocks, options = {}) {\n        var _a, _b, _c;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-commitBlockList\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.blockBlobContext.commitBlockList({ latest: blocks }, Object.assign({ abortSignal: options.abortSignal, blobHttpHeaders: options.blobHTTPHeaders, leaseAccessConditions: options.conditions, metadata: options.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope, immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn, immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode, legalHold: options.legalHold, tier: toAccessTier(options.tier), blobTagsString: toBlobTagsString(options.tags) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns the list of blocks that have been uploaded as part of a block blob\n     * using the specified block list filter.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-block-list\n     *\n     * @param listType - Specifies whether to return the list of committed blocks,\n     *                                        the list of uncommitted blocks, or both lists together.\n     * @param options - Options to the Block Blob Get Block List operation.\n     * @returns Response data for the Block Blob Get Block List operation.\n     */\n    async getBlockList(listType, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-getBlockList\", options);\n        try {\n            const res = await this.blockBlobContext.getBlockList(listType, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n            if (!res.committedBlocks) {\n                res.committedBlocks = [];\n            }\n            if (!res.uncommittedBlocks) {\n                res.uncommittedBlocks = [];\n            }\n            return res;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    // High level functions\n    /**\n     * Uploads a Buffer(Node.js)/Blob(browsers)/ArrayBuffer/ArrayBufferView object to a BlockBlob.\n     *\n     * When data length is no more than the specifiled {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is\n     * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.\n     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}\n     * to commit the block list.\n     *\n     * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is\n     * `blobContentType`, enabling the browser to provide\n     * functionality based on file type.\n     *\n     * @param data - Buffer(Node.js), Blob, ArrayBuffer or ArrayBufferView\n     * @param options -\n     */\n    async uploadData(data, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadData\", options);\n        try {\n            if (isNode) {\n                let buffer;\n                if (data instanceof Buffer) {\n                    buffer = data;\n                }\n                else if (data instanceof ArrayBuffer) {\n                    buffer = Buffer.from(data);\n                }\n                else {\n                    data = data;\n                    buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n                }\n                return this.uploadSeekableInternal((offset, size) => buffer.slice(offset, offset + size), buffer.byteLength, updatedOptions);\n            }\n            else {\n                const browserBlob = new Blob([data]);\n                return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);\n            }\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * ONLY AVAILABLE IN BROWSERS.\n     *\n     * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to block blob.\n     *\n     * When buffer length lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.\n     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call\n     * {@link commitBlockList} to commit the block list.\n     *\n     * A common {@link BlockBlobParallelUploadOptions.blobHTTPHeaders} option to set is\n     * `blobContentType`, enabling the browser to provide\n     * functionality based on file type.\n     *\n     * @deprecated Use {@link uploadData} instead.\n     *\n     * @param browserData - Blob, File, ArrayBuffer or ArrayBufferView\n     * @param options - Options to upload browser data.\n     * @returns Response data for the Blob Upload operation.\n     */\n    async uploadBrowserData(browserData, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadBrowserData\", options);\n        try {\n            const browserBlob = new Blob([browserData]);\n            return await this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     *\n     * Uploads data to block blob. Requires a bodyFactory as the data source,\n     * which need to return a {@link HttpRequestBody} object with the offset and size provided.\n     *\n     * When data length is no more than the specifiled {@link BlockBlobParallelUploadOptions.maxSingleShotSize} (default is\n     * {@link BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}), this method will use 1 {@link upload} call to finish the upload.\n     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}\n     * to commit the block list.\n     *\n     * @param bodyFactory -\n     * @param size - size of the data to upload.\n     * @param options - Options to Upload to Block Blob operation.\n     * @returns Response data for the Blob Upload operation.\n     */\n    async uploadSeekableInternal(bodyFactory, size, options = {}) {\n        if (!options.blockSize) {\n            options.blockSize = 0;\n        }\n        if (options.blockSize < 0 || options.blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {\n            throw new RangeError(`blockSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`);\n        }\n        if (options.maxSingleShotSize !== 0 && !options.maxSingleShotSize) {\n            options.maxSingleShotSize = BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;\n        }\n        if (options.maxSingleShotSize < 0 ||\n            options.maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) {\n            throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`);\n        }\n        if (options.blockSize === 0) {\n            if (size > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * BLOCK_BLOB_MAX_BLOCKS) {\n                throw new RangeError(`${size} is too larger to upload to a block blob.`);\n            }\n            if (size > options.maxSingleShotSize) {\n                options.blockSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);\n                if (options.blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {\n                    options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;\n                }\n            }\n        }\n        if (!options.blobHTTPHeaders) {\n            options.blobHTTPHeaders = {};\n        }\n        if (!options.conditions) {\n            options.conditions = {};\n        }\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadSeekableInternal\", options);\n        try {\n            if (size <= options.maxSingleShotSize) {\n                return await this.upload(bodyFactory(0, size), size, updatedOptions);\n            }\n            const numBlocks = Math.floor((size - 1) / options.blockSize) + 1;\n            if (numBlocks > BLOCK_BLOB_MAX_BLOCKS) {\n                throw new RangeError(`The buffer's size is too big or the BlockSize is too small;` +\n                    `the number of blocks must be <= ${BLOCK_BLOB_MAX_BLOCKS}`);\n            }\n            const blockList = [];\n            const blockIDPrefix = generateUuid();\n            let transferProgress = 0;\n            const batch = new Batch(options.concurrency);\n            for (let i = 0; i < numBlocks; i++) {\n                batch.addOperation(async () => {\n                    const blockID = generateBlockID(blockIDPrefix, i);\n                    const start = options.blockSize * i;\n                    const end = i === numBlocks - 1 ? size : start + options.blockSize;\n                    const contentLength = end - start;\n                    blockList.push(blockID);\n                    await this.stageBlock(blockID, bodyFactory(start, contentLength), contentLength, {\n                        abortSignal: options.abortSignal,\n                        conditions: options.conditions,\n                        encryptionScope: options.encryptionScope,\n                        tracingOptions: updatedOptions.tracingOptions\n                    });\n                    // Update progress after block is successfully uploaded to server, in case of block trying\n                    // TODO: Hook with convenience layer progress event in finer level\n                    transferProgress += contentLength;\n                    if (options.onProgress) {\n                        options.onProgress({\n                            loadedBytes: transferProgress\n                        });\n                    }\n                });\n            }\n            await batch.do();\n            return this.commitBlockList(blockList, updatedOptions);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * ONLY AVAILABLE IN NODE.JS RUNTIME.\n     *\n     * Uploads a local file in blocks to a block blob.\n     *\n     * When file size lesser than or equal to 256MB, this method will use 1 upload call to finish the upload.\n     * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList\n     * to commit the block list.\n     *\n     * @param filePath - Full path of local file\n     * @param options - Options to Upload to Block Blob operation.\n     * @returns Response data for the Blob Upload operation.\n     */\n    async uploadFile(filePath, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadFile\", options);\n        try {\n            const size = (await fsStat(filePath)).size;\n            return await this.uploadSeekableInternal((offset, count) => {\n                return () => fsCreateReadStream(filePath, {\n                    autoClose: true,\n                    end: count ? offset + count - 1 : Infinity,\n                    start: offset\n                });\n            }, size, Object.assign(Object.assign({}, options), { tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions)) }));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * ONLY AVAILABLE IN NODE.JS RUNTIME.\n     *\n     * Uploads a Node.js Readable stream into block blob.\n     *\n     * PERFORMANCE IMPROVEMENT TIPS:\n     * * Input stream highWaterMark is better to set a same value with bufferSize\n     *    parameter, which will avoid Buffer.concat() operations.\n     *\n     * @param stream - Node.js Readable stream\n     * @param bufferSize - Size of every buffer allocated, also the block size in the uploaded block blob. Default value is 8MB\n     * @param maxConcurrency -  Max concurrency indicates the max number of buffers that can be allocated,\n     *                                 positive correlation with max uploading concurrency. Default value is 5\n     * @param options - Options to Upload Stream to Block Blob operation.\n     * @returns Response data for the Blob Upload operation.\n     */\n    async uploadStream(stream, bufferSize = DEFAULT_BLOCK_BUFFER_SIZE_BYTES, maxConcurrency = 5, options = {}) {\n        if (!options.blobHTTPHeaders) {\n            options.blobHTTPHeaders = {};\n        }\n        if (!options.conditions) {\n            options.conditions = {};\n        }\n        const { span, updatedOptions } = createSpan(\"BlockBlobClient-uploadStream\", options);\n        try {\n            let blockNum = 0;\n            const blockIDPrefix = generateUuid();\n            let transferProgress = 0;\n            const blockList = [];\n            const scheduler = new BufferScheduler(stream, bufferSize, maxConcurrency, async (body, length) => {\n                const blockID = generateBlockID(blockIDPrefix, blockNum);\n                blockList.push(blockID);\n                blockNum++;\n                await this.stageBlock(blockID, body, length, {\n                    conditions: options.conditions,\n                    encryptionScope: options.encryptionScope,\n                    tracingOptions: updatedOptions.tracingOptions\n                });\n                // Update progress after block is successfully uploaded to server, in case of block trying\n                transferProgress += length;\n                if (options.onProgress) {\n                    options.onProgress({ loadedBytes: transferProgress });\n                }\n            }, \n            // concurrency should set a smaller value than maxConcurrency, which is helpful to\n            // reduce the possibility when a outgoing handler waits for stream data, in\n            // this situation, outgoing handlers are blocked.\n            // Outgoing queue shouldn't be empty.\n            Math.ceil((maxConcurrency / 4) * 3));\n            await scheduler.do();\n            return await this.commitBlockList(blockList, Object.assign(Object.assign({}, options), { tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions)) }));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n}\n/**\n * PageBlobClient defines a set of operations applicable to page blobs.\n */\nexport class PageBlobClient extends BlobClient {\n    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, \n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options) {\n        // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.\n        //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);\n        let pipeline;\n        let url;\n        options = options || {};\n        if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n            // (url: string, pipeline: Pipeline)\n            url = urlOrConnectionString;\n            pipeline = credentialOrPipelineOrContainerName;\n        }\n        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n            isTokenCredential(credentialOrPipelineOrContainerName)) {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            url = urlOrConnectionString;\n            options = blobNameOrOptions;\n            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n        }\n        else if (!credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName !== \"string\") {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            // The second parameter is undefined. Use anonymous credential.\n            url = urlOrConnectionString;\n            pipeline = newPipeline(new AnonymousCredential(), options);\n        }\n        else if (credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName === \"string\" &&\n            blobNameOrOptions &&\n            typeof blobNameOrOptions === \"string\") {\n            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n            const containerName = credentialOrPipelineOrContainerName;\n            const blobName = blobNameOrOptions;\n            const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n            if (extractedCreds.kind === \"AccountConnString\") {\n                if (isNode) {\n                    const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n                    url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));\n                    options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n                    pipeline = newPipeline(sharedKeyCredential, options);\n                }\n                else {\n                    throw new Error(\"Account connection string is only supported in Node.js environment\");\n                }\n            }\n            else if (extractedCreds.kind === \"SASConnString\") {\n                url =\n                    appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) +\n                        \"?\" +\n                        extractedCreds.accountSas;\n                pipeline = newPipeline(new AnonymousCredential(), options);\n            }\n            else {\n                throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n            }\n        }\n        else {\n            throw new Error(\"Expecting non-empty strings for containerName and blobName parameters\");\n        }\n        super(url, pipeline);\n        this.pageBlobContext = new PageBlob(this.storageClientContext);\n    }\n    /**\n     * Creates a new PageBlobClient object identical to the source but with the\n     * specified snapshot timestamp.\n     * Provide \"\" will remove the snapshot and return a Client to the base blob.\n     *\n     * @param snapshot - The snapshot timestamp.\n     * @returns A new PageBlobClient object identical to the source but with the specified snapshot timestamp.\n     */\n    withSnapshot(snapshot) {\n        return new PageBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n    }\n    /**\n     * Creates a page blob of the specified length. Call uploadPages to upload data\n     * data to a page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param size - size of the page blob.\n     * @param options - Options to the Page Blob Create operation.\n     * @returns Response data for the Page Blob Create operation.\n     */\n    async create(size, options = {}) {\n        var _a, _b, _c;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-create\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.pageBlobContext.create(0, size, Object.assign({ abortSignal: options.abortSignal, blobHttpHeaders: options.blobHTTPHeaders, blobSequenceNumber: options.blobSequenceNumber, leaseAccessConditions: options.conditions, metadata: options.metadata, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope, immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === void 0 ? void 0 : _b.expiriesOn, immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === void 0 ? void 0 : _c.policyMode, legalHold: options.legalHold, tier: toAccessTier(options.tier), blobTagsString: toBlobTagsString(options.tags) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Creates a page blob of the specified length. Call uploadPages to upload data\n     * data to a page blob. If the blob with the same name already exists, the content\n     * of the existing blob will remain unchanged.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param size - size of the page blob.\n     * @param options -\n     */\n    async createIfNotExists(size, options = {}) {\n        var _a, _b;\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-createIfNotExists\", options);\n        try {\n            const conditions = { ifNoneMatch: ETagAny };\n            const res = await this.create(size, Object.assign(Object.assign({}, options), { conditions, tracingOptions: updatedOptions.tracingOptions }));\n            return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response // _response is made non-enumerable\n             });\n        }\n        catch (e) {\n            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"BlobAlreadyExists\") {\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: \"Expected exception when creating a blob only if it does not already exist.\"\n                });\n                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });\n            }\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Writes 1 or more pages to the page blob. The start and end offsets must be a multiple of 512.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-page\n     *\n     * @param body - Data to upload\n     * @param offset - Offset of destination page blob\n     * @param count - Content length of the body, also number of bytes to be uploaded\n     * @param options - Options to the Page Blob Upload Pages operation.\n     * @returns Response data for the Page Blob Upload Pages operation.\n     */\n    async uploadPages(body, offset, count, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-uploadPages\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.pageBlobContext.uploadPages(count, body, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), requestOptions: {\n                    onUploadProgress: options.onProgress\n                }, range: rangeToString({ offset, count }), sequenceNumberAccessConditions: options.conditions, transactionalContentMD5: options.transactionalContentMD5, transactionalContentCrc64: options.transactionalContentCrc64, cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * The Upload Pages operation writes a range of pages to a page blob where the\n     * contents are read from a URL.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-page-from-url\n     *\n     * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication\n     * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source page blob\n     * @param destOffset - Offset of destination page blob\n     * @param count - Number of bytes to be uploaded from source page blob\n     * @param options -\n     */\n    async uploadPagesFromURL(sourceURL, sourceOffset, destOffset, count, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        options.sourceConditions = options.sourceConditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-uploadPagesFromURL\", options);\n        try {\n            ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);\n            return await this.pageBlobContext.uploadPagesFromURL(sourceURL, rangeToString({ offset: sourceOffset, count }), 0, rangeToString({ offset: destOffset, count }), Object.assign({ abortSignal: options.abortSignal, sourceContentMD5: options.sourceContentMD5, sourceContentCrc64: options.sourceContentCrc64, leaseAccessConditions: options.conditions, sequenceNumberAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), sourceModifiedAccessConditions: {\n                    sourceIfMatch: options.sourceConditions.ifMatch,\n                    sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,\n                    sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,\n                    sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince\n                }, cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Frees the specified pages from the page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-page\n     *\n     * @param offset - Starting byte position of the pages to clear.\n     * @param count - Number of bytes to clear.\n     * @param options - Options to the Page Blob Clear Pages operation.\n     * @returns Response data for the Page Blob Clear Pages operation.\n     */\n    async clearPages(offset = 0, count, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-clearPages\", options);\n        try {\n            return await this.pageBlobContext.clearPages(0, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), range: rangeToString({ offset, count }), sequenceNumberAccessConditions: options.conditions, cpkInfo: options.customerProvidedKey, encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns the list of valid page ranges for a page blob or snapshot of a page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     * @param offset - Starting byte position of the page ranges.\n     * @param count - Number of bytes to get.\n     * @param options - Options to the Page Blob Get Ranges operation.\n     * @returns Response data for the Page Blob Get Ranges operation.\n     */\n    async getPageRanges(offset = 0, count, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-getPageRanges\", options);\n        try {\n            return await this.pageBlobContext\n                .getPageRanges(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), range: rangeToString({ offset, count }) }, convertTracingToRequestOptionsBase(updatedOptions)))\n                .then(rangeResponseFromModel);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Gets the collection of page ranges that differ between a specified snapshot and this page blob.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     * @param offset - Starting byte position of the page blob\n     * @param count - Number of bytes to get ranges diff.\n     * @param prevSnapshot - Timestamp of snapshot to retrieve the difference.\n     * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n     * @returns Response data for the Page Blob Get Page Range Diff operation.\n     */\n    async getPageRangesDiff(offset, count, prevSnapshot, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-getPageRangesDiff\", options);\n        try {\n            return await this.pageBlobContext\n                .getPageRangesDiff(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), prevsnapshot: prevSnapshot, range: rangeToString({ offset, count }) }, convertTracingToRequestOptionsBase(updatedOptions)))\n                .then(rangeResponseFromModel);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Gets the collection of page ranges that differ between a specified snapshot and this page blob for managed disks.\n     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges\n     *\n     * @param offset - Starting byte position of the page blob\n     * @param count - Number of bytes to get ranges diff.\n     * @param prevSnapshotUrl - URL of snapshot to retrieve the difference.\n     * @param options - Options to the Page Blob Get Page Ranges Diff operation.\n     * @returns Response data for the Page Blob Get Page Range Diff operation.\n     */\n    async getPageRangesDiffForManagedDisks(offset, count, prevSnapshotUrl, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-GetPageRangesDiffForManagedDisks\", options);\n        try {\n            return await this.pageBlobContext\n                .getPageRangesDiff(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), prevSnapshotUrl, range: rangeToString({ offset, count }) }, convertTracingToRequestOptionsBase(updatedOptions)))\n                .then(rangeResponseFromModel);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Resizes the page blob to the specified size (which must be a multiple of 512).\n     * @see https://docs.microsoft.com/rest/api/storageservices/set-blob-properties\n     *\n     * @param size - Target size\n     * @param options - Options to the Page Blob Resize operation.\n     * @returns Response data for the Page Blob Resize operation.\n     */\n    async resize(size, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-resize\", options);\n        try {\n            return await this.pageBlobContext.resize(size, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }), encryptionScope: options.encryptionScope }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets a page blob's sequence number.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n     *\n     * @param sequenceNumberAction - Indicates how the service should modify the blob's sequence number.\n     * @param sequenceNumber - Required if sequenceNumberAction is max or update\n     * @param options - Options to the Page Blob Update Sequence Number operation.\n     * @returns Response data for the Page Blob Update Sequence Number operation.\n     */\n    async updateSequenceNumber(sequenceNumberAction, sequenceNumber, options = {}) {\n        var _a;\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-updateSequenceNumber\", options);\n        try {\n            return await this.pageBlobContext.updateSequenceNumber(sequenceNumberAction, Object.assign({ abortSignal: options.abortSignal, blobSequenceNumber: sequenceNumber, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Begins an operation to start an incremental copy from one page blob's snapshot to this page blob.\n     * The snapshot is copied such that only the differential changes between the previously\n     * copied snapshot are transferred to the destination.\n     * The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual.\n     * @see https://docs.microsoft.com/rest/api/storageservices/incremental-copy-blob\n     * @see https://docs.microsoft.com/en-us/azure/virtual-machines/windows/incremental-snapshots\n     *\n     * @param copySource - Specifies the name of the source page blob snapshot. For example,\n     *                            https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n     * @param options - Options to the Page Blob Copy Incremental operation.\n     * @returns Response data for the Page Blob Copy Incremental operation.\n     */\n    async startCopyIncremental(copySource, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"PageBlobClient-startCopyIncremental\", options);\n        try {\n            return await this.pageBlobContext.copyIncremental(copySource, Object.assign({ abortSignal: options.abortSignal, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === void 0 ? void 0 : _a.tagConditions }) }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n}\n//# sourceMappingURL=Clients.js.map"]},"metadata":{},"sourceType":"module"}