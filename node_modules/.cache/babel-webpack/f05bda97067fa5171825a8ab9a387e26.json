{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { logPolicy } from \"./policies/logPolicy\";\nimport { getPathStringFromParameter, getPathStringFromParameterPath } from \"./operationParameter\";\nimport { getStreamResponseStatusCodes } from \"./operationSpec\";\nimport { deserializationPolicy, DefaultDeserializationOptions } from \"./policies/deserializationPolicy\";\nimport { exponentialRetryPolicy, DefaultRetryOptions } from \"./policies/exponentialRetryPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { userAgentPolicy, getDefaultUserAgentHeaderName, getDefaultUserAgentValue } from \"./policies/userAgentPolicy\";\nimport { redirectPolicy, DefaultRedirectOptions } from \"./policies/redirectPolicy\";\nimport { RequestPolicyOptions } from \"./policies/requestPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { MapperType } from \"./serializer\";\nimport { URLBuilder } from \"./url\";\nimport * as utils from \"./util/utils\";\nimport { stringifyXML } from \"./util/xml\";\nimport { WebResource, isWebResourceLike } from \"./webResource\";\nimport { isNode } from \"./util/utils\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { logger } from \"./log\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\nimport { ndJsonPolicy } from \"./policies/ndJsonPolicy\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\nimport { URL } from \"./url\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\n/**\n * ServiceClient sends service requests and receives responses.\n */\n\nexport class ServiceClient {\n  /**\n   * The ServiceClient constructor\n   * @param credentials - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(credentials,\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n  options) {\n    if (!options) {\n      options = {};\n    }\n\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n    let requestPolicyFactories;\n\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      let authPolicyFactory = undefined;\n\n      if (isTokenCredential(credentials)) {\n        logger.info(\"ServiceClient: creating bearer token authentication policy from provided credentials\"); // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n\n        const wrappedPolicyFactory = () => {\n          let bearerTokenPolicyFactory = undefined; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n          const serviceClient = this;\n          const serviceClientOptions = options;\n          return {\n            create(nextPolicy, createOptions) {\n              const credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);\n\n              if (!credentialScopes) {\n                throw new Error(`When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy`);\n              }\n\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, credentialScopes);\n              }\n\n              return bearerTokenPolicyFactory.create(nextPolicy, createOptions);\n            }\n\n          };\n        };\n\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        const newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);\n\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n\n\n  sendRequest(options) {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n\n    let httpRequest;\n\n    try {\n      if (isWebResourceLike(options)) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    let httpPipeline = this._httpClient;\n\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);\n      }\n    }\n\n    return httpPipeline.sendRequest(httpRequest);\n  }\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   * @param callback - The callback to call when the response is received.\n   */\n\n\n  sendOperationRequest(operationArguments, operationSpec, callback) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      if (typeof operationArguments.options === \"function\") {\n        callback = operationArguments.options;\n        operationArguments.options = undefined;\n      }\n\n      const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n      const httpRequest = new WebResource();\n      let result;\n\n      try {\n        const baseUri = operationSpec.baseUrl || _this.baseUri;\n\n        if (!baseUri) {\n          throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\");\n        }\n\n        httpRequest.method = operationSpec.httpMethod;\n        httpRequest.operationSpec = operationSpec;\n        const requestUrl = URLBuilder.parse(baseUri);\n\n        if (operationSpec.path) {\n          requestUrl.appendPath(operationSpec.path);\n        }\n\n        if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n          for (const urlParameter of operationSpec.urlParameters) {\n            let urlParameterValue = getOperationArgumentValueFromParameter(_this, operationArguments, urlParameter, operationSpec.serializer);\n            urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter), serializerOptions);\n\n            if (!urlParameter.skipEncoding) {\n              urlParameterValue = encodeURIComponent(urlParameterValue);\n            }\n\n            requestUrl.replaceAll(`{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`, urlParameterValue);\n          }\n        }\n\n        if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n          for (const queryParameter of operationSpec.queryParameters) {\n            let queryParameterValue = getOperationArgumentValueFromParameter(_this, operationArguments, queryParameter, operationSpec.serializer);\n\n            if (queryParameterValue !== undefined && queryParameterValue !== null) {\n              queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter), serializerOptions);\n\n              if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null) {\n                if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                  if (queryParameterValue.length === 0) {\n                    // The collection is empty, no need to try serializing the current queryParam\n                    continue;\n                  } else {\n                    for (const index in queryParameterValue) {\n                      const item = queryParameterValue[index];\n                      queryParameterValue[index] = item === undefined || item === null ? \"\" : item.toString();\n                    }\n                  }\n                } else if (queryParameter.collectionFormat === QueryCollectionFormat.Ssv || queryParameter.collectionFormat === QueryCollectionFormat.Tsv) {\n                  queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n                }\n              }\n\n              if (!queryParameter.skipEncoding) {\n                if (Array.isArray(queryParameterValue)) {\n                  for (const index in queryParameterValue) {\n                    if (queryParameterValue[index] !== undefined && queryParameterValue[index] !== null) {\n                      queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                    }\n                  }\n                } else {\n                  queryParameterValue = encodeURIComponent(queryParameterValue);\n                }\n              }\n\n              if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== QueryCollectionFormat.Multi && queryParameter.collectionFormat !== QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== QueryCollectionFormat.Tsv) {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n\n              requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n            }\n          }\n        }\n\n        httpRequest.url = requestUrl.toString();\n        const contentType = operationSpec.contentType || _this.requestContentType;\n\n        if (contentType && operationSpec.requestBody) {\n          httpRequest.headers.set(\"Content-Type\", contentType);\n        }\n\n        if (operationSpec.headerParameters) {\n          for (const headerParameter of operationSpec.headerParameters) {\n            let headerValue = getOperationArgumentValueFromParameter(_this, operationArguments, headerParameter, operationSpec.serializer);\n\n            if (headerValue !== undefined && headerValue !== null) {\n              headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter), serializerOptions);\n              const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n\n              if (headerCollectionPrefix) {\n                for (const key of Object.keys(headerValue)) {\n                  httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n                }\n              } else {\n                httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n              }\n            }\n          }\n        }\n\n        const options = operationArguments.options;\n\n        if (options) {\n          if (options.customHeaders) {\n            for (const customHeaderName in options.customHeaders) {\n              httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n            }\n          }\n\n          if (options.abortSignal) {\n            httpRequest.abortSignal = options.abortSignal;\n          }\n\n          if (options.timeout) {\n            httpRequest.timeout = options.timeout;\n          }\n\n          if (options.onUploadProgress) {\n            httpRequest.onUploadProgress = options.onUploadProgress;\n          }\n\n          if (options.onDownloadProgress) {\n            httpRequest.onDownloadProgress = options.onDownloadProgress;\n          }\n\n          if (options.spanOptions) {\n            // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.\n            httpRequest.spanOptions = options.spanOptions;\n          }\n\n          if (options.tracingContext) {\n            httpRequest.tracingContext = options.tracingContext;\n          }\n\n          if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n            httpRequest.shouldDeserialize = options.shouldDeserialize;\n          }\n        }\n\n        httpRequest.withCredentials = _this._withCredentials;\n        serializeRequestBody(_this, httpRequest, operationArguments, operationSpec);\n\n        if (httpRequest.streamResponseStatusCodes === undefined) {\n          httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);\n        }\n\n        let rawResponse;\n        let sendRequestError;\n\n        try {\n          rawResponse = yield _this.sendRequest(httpRequest);\n        } catch (error) {\n          sendRequestError = error;\n        }\n\n        if (sendRequestError) {\n          if (sendRequestError.response) {\n            sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses[\"default\"]);\n          }\n\n          result = Promise.reject(sendRequestError);\n        } else {\n          result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));\n        }\n      } catch (error) {\n        result = Promise.reject(error);\n      }\n\n      const cb = callback;\n\n      if (cb) {\n        result.then(res => cb(null, res._response.parsedBody, res._response.request, res._response)).catch(err => cb(err));\n      }\n\n      return result;\n    })();\n  }\n\n}\nexport function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {\n  var _a, _b, _c, _d, _e, _f;\n\n  const serializerOptions = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions) !== null && _b !== void 0 ? _b : {};\n  const updatedOptions = {\n    rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : \"\",\n    includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,\n    xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : XML_CHARKEY\n  };\n  const xmlCharKey = serializerOptions.xmlCharKey;\n\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const {\n      required,\n      xmlName,\n      xmlElementName,\n      serializedName,\n      xmlNamespace,\n      xmlNamespacePrefix\n    } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n\n    try {\n      if (httpRequest.body !== undefined && httpRequest.body !== null || required) {\n        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);\n        const isStream = typeName === MapperType.Stream;\n\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);\n\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(utils.prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          }\n        } else if (typeName === MapperType.String && (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(`Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, \"  \")}.`);\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);\n\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n      }\n    }\n  }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\n\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result = {};\n    result[options.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = {\n      [xmlnsKey]: xmlNamespace\n    };\n    return result;\n  }\n\n  return serializedValue;\n}\n\nfunction getValueOrFunctionResult(value, defaultValueCreator) {\n  let result;\n\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n\n  return result;\n}\n\nfunction createDefaultRequestPolicyFactories(authPolicyFactory, options) {\n  const factories = [];\n\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n\n  const userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);\n  const userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);\n\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({\n      key: userAgentHeaderName,\n      value: userAgentHeaderValue\n    }));\n  }\n\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n\n  factories.push(logPolicy({\n    logger: logger.info\n  }));\n  return factories;\n}\n\nexport function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {\n  const requestPolicyFactories = [];\n\n  if (pipelineOptions.sendStreamingJson) {\n    requestPolicyFactories.push(ndJsonPolicy());\n  }\n\n  let userAgentValue = undefined;\n\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    const userAgentInfo = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix); // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n\n    const defaultUserAgentInfo = getDefaultUserAgentValue();\n\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n\n  const keepAliveOptions = Object.assign(Object.assign({}, DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);\n  const retryOptions = Object.assign(Object.assign({}, DefaultRetryOptions), pipelineOptions.retryOptions);\n  const redirectOptions = Object.assign(Object.assign({}, DefaultRedirectOptions), pipelineOptions.redirectOptions);\n\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n\n  const deserializationOptions = Object.assign(Object.assign({}, DefaultDeserializationOptions), pipelineOptions.deserializationOptions);\n  const loggingOptions = Object.assign({}, pipelineOptions.loggingOptions);\n  requestPolicyFactories.push(tracingPolicy({\n    userAgent: userAgentValue\n  }), keepAlivePolicy(keepAliveOptions), userAgentPolicy({\n    value: userAgentValue\n  }), generateClientRequestIdPolicy(), deserializationPolicy(deserializationOptions.expectedContentTypes), throttlingRetryPolicy(), systemErrorRetryPolicy(), exponentialRetryPolicy(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));\n\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories\n  };\n}\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\n\nexport function getPropertyParent(parent, propertyPath) {\n  if (parent && propertyPath) {\n    const propertyPathLength = propertyPath.length;\n\n    for (let i = 0; i < propertyPathLength - 1; ++i) {\n      const propertyName = propertyPath[i];\n\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n\n      parent = parent[propertyName];\n    }\n  }\n\n  return parent;\n}\n\nfunction getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {\n  return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);\n}\n\nexport function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {\n  var _a;\n\n  let value;\n\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n\n  const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n\n        let useDefaultValue = false;\n\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue = parameterMapper.required || parameterPath[0] === \"options\" && parameterPath.length === 2;\n        }\n\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      } // Serialize just for validation purposes.\n\n\n      const parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);\n      serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n\n    for (const propertyName in parameterPath) {\n      const propertyMapper = parameterMapper.type.modelProperties[propertyName];\n      const propertyPath = parameterPath[propertyName];\n      const propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer); // Serialize just for validation purposes.\n\n      const propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);\n\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction getPropertyFromParameterPath(parent, parameterPath) {\n  const result = {\n    propertyFound: false\n  };\n  let i = 0;\n\n  for (; i < parameterPath.length; ++i) {\n    const parameterPathPart = parameterPath[i]; // Make sure to check inherited properties too, so don't use hasOwnProperty().\n\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n\n  return result;\n}\n\nexport function flattenResponse(_response, responseSpec) {\n  const parsedHeaders = _response.parsedHeaders;\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n\n  const addOperationResponse = obj => {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response\n    });\n  };\n\n  if (bodyMapper) {\n    const typeName = bodyMapper.type.name;\n\n    if (typeName === \"Stream\") {\n      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody\n      }));\n    }\n\n    const modelProperties = typeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n    const isPageableResponse = Object.keys(modelProperties).some(k => modelProperties[k].serializedName === \"\");\n\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      const arrayResponse = [...(_response.parsedBody || [])];\n\n      for (const key of Object.keys(modelProperties)) {\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n\n      if (parsedHeaders) {\n        for (const key of Object.keys(parsedHeaders)) {\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n    }\n  }\n\n  if (bodyMapper || _response.request.method === \"HEAD\" || utils.isPrimitiveType(_response.parsedBody)) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), {\n      body: _response.parsedBody\n    }));\n  }\n\n  return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n}\n\nfunction getCredentialScopes(options, baseUri) {\n  if (options === null || options === void 0 ? void 0 : options.credentialScopes) {\n    const scopes = options.credentialScopes;\n    return Array.isArray(scopes) ? scopes.map(scope => new URL(scope).toString()) : new URL(scopes).toString();\n  }\n\n  if (baseUri) {\n    return `${baseUri}/.default`;\n  }\n\n  return undefined;\n} //# sourceMappingURL=serviceClient.js.map","map":{"version":3,"sources":["F:/statvalu/AR_DocuExpert_Test/node_modules/@azure/core-http/dist-esm/src/serviceClient.js"],"names":["isTokenCredential","logPolicy","getPathStringFromParameter","getPathStringFromParameterPath","getStreamResponseStatusCodes","deserializationPolicy","DefaultDeserializationOptions","exponentialRetryPolicy","DefaultRetryOptions","generateClientRequestIdPolicy","userAgentPolicy","getDefaultUserAgentHeaderName","getDefaultUserAgentValue","redirectPolicy","DefaultRedirectOptions","RequestPolicyOptions","rpRegistrationPolicy","bearerTokenAuthenticationPolicy","systemErrorRetryPolicy","QueryCollectionFormat","MapperType","URLBuilder","utils","stringifyXML","WebResource","isWebResourceLike","isNode","proxyPolicy","throttlingRetryPolicy","signingPolicy","logger","DefaultKeepAliveOptions","keepAlivePolicy","tracingPolicy","disableResponseDecompressionPolicy","ndJsonPolicy","XML_ATTRKEY","XML_CHARKEY","URL","getCachedDefaultHttpClient","ServiceClient","constructor","credentials","options","_withCredentials","withCredentials","_httpClient","httpClient","_requestPolicyOptions","httpPipelineLogger","requestPolicyFactories","Array","isArray","info","authPolicyFactory","undefined","wrappedPolicyFactory","bearerTokenPolicyFactory","serviceClient","serviceClientOptions","create","nextPolicy","createOptions","credentialScopes","getCredentialScopes","baseUri","Error","signRequest","createDefaultRequestPolicyFactories","newRequestPolicyFactories","_requestPolicyFactories","sendRequest","httpRequest","validateRequestProperties","prepare","error","Promise","reject","httpPipeline","length","i","sendOperationRequest","operationArguments","operationSpec","callback","_a","serializerOptions","result","baseUrl","method","httpMethod","requestUrl","parse","path","appendPath","urlParameters","urlParameter","urlParameterValue","getOperationArgumentValueFromParameter","serializer","serialize","mapper","skipEncoding","encodeURIComponent","replaceAll","serializedName","queryParameters","queryParameter","queryParameterValue","collectionFormat","Multi","index","item","toString","Ssv","Tsv","join","setQueryParameter","url","contentType","requestContentType","requestBody","headers","set","headerParameters","headerParameter","headerValue","headerCollectionPrefix","key","Object","keys","customHeaders","customHeaderName","abortSignal","timeout","onUploadProgress","onDownloadProgress","spanOptions","tracingContext","shouldDeserialize","serializeRequestBody","streamResponseStatusCodes","rawResponse","sendRequestError","response","details","flattenResponse","responses","statusCode","resolve","status","cb","then","res","_response","parsedBody","request","catch","err","_b","_c","_d","_e","_f","updatedOptions","rootName","includeRoot","xmlCharKey","body","bodyMapper","required","xmlName","xmlElementName","xmlNamespace","xmlNamespacePrefix","typeName","type","name","requestBodyParameterPathString","isStream","Stream","isXML","xmlnsKey","value","getXmlValueWithNamespace","Sequence","prepareXMLRootList","String","match","mediaType","JSON","stringify","message","formDataParameters","formData","formDataParameter","formDataParameterValue","formDataParameterPropertyName","serializedValue","includes","getValueOrFunctionResult","defaultValueCreator","factories","generateClientRequestIdHeader","push","clientRequestIdHeaderName","userAgentHeaderName","userAgentHeaderValue","userAgent","rpRegistrationRetryTimeout","noRetryPolicy","deserializationContentTypes","proxySettings","createPipelineFromOptions","pipelineOptions","sendStreamingJson","userAgentValue","userAgentOptions","userAgentPrefix","userAgentInfo","defaultUserAgentInfo","indexOf","keepAliveOptions","assign","retryOptions","redirectOptions","proxyOptions","deserializationOptions","loggingOptions","expectedContentTypes","maxRetries","retryDelayInMs","maxRetryDelayInMs","handleRedirects","decompressResponse","getPropertyParent","parent","propertyPath","propertyPathLength","propertyName","parameter","getOperationArgumentValueFromParameterPath","parameterPath","parameterMapper","isConstant","defaultValue","propertySearchResult","getPropertyFromParameterPath","propertyFound","useDefaultValue","propertyValue","parameterPathString","propertyMapper","modelProperties","propertyPathString","parameterPathPart","responseSpec","parsedHeaders","addOperationResponse","obj","defineProperty","blobBody","readableStreamBody","isPageableResponse","some","k","arrayResponse","isPrimitiveType","scopes","map","scope"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { logPolicy } from \"./policies/logPolicy\";\nimport { getPathStringFromParameter, getPathStringFromParameterPath } from \"./operationParameter\";\nimport { getStreamResponseStatusCodes } from \"./operationSpec\";\nimport { deserializationPolicy, DefaultDeserializationOptions } from \"./policies/deserializationPolicy\";\nimport { exponentialRetryPolicy, DefaultRetryOptions } from \"./policies/exponentialRetryPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { userAgentPolicy, getDefaultUserAgentHeaderName, getDefaultUserAgentValue } from \"./policies/userAgentPolicy\";\nimport { redirectPolicy, DefaultRedirectOptions } from \"./policies/redirectPolicy\";\nimport { RequestPolicyOptions } from \"./policies/requestPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { MapperType } from \"./serializer\";\nimport { URLBuilder } from \"./url\";\nimport * as utils from \"./util/utils\";\nimport { stringifyXML } from \"./util/xml\";\nimport { WebResource, isWebResourceLike } from \"./webResource\";\nimport { isNode } from \"./util/utils\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { logger } from \"./log\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\nimport { ndJsonPolicy } from \"./policies/ndJsonPolicy\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\nimport { URL } from \"./url\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\n/**\n * ServiceClient sends service requests and receives responses.\n */\nexport class ServiceClient {\n    /**\n     * The ServiceClient constructor\n     * @param credentials - The credentials used for authentication with the service.\n     * @param options - The service client options that govern the behavior of the client.\n     */\n    constructor(credentials, \n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options) {\n        if (!options) {\n            options = {};\n        }\n        this._withCredentials = options.withCredentials || false;\n        this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n        this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n        let requestPolicyFactories;\n        if (Array.isArray(options.requestPolicyFactories)) {\n            logger.info(\"ServiceClient: using custom request policies\");\n            requestPolicyFactories = options.requestPolicyFactories;\n        }\n        else {\n            let authPolicyFactory = undefined;\n            if (isTokenCredential(credentials)) {\n                logger.info(\"ServiceClient: creating bearer token authentication policy from provided credentials\");\n                // Create a wrapped RequestPolicyFactory here so that we can provide the\n                // correct scope to the BearerTokenAuthenticationPolicy at the first time\n                // one is requested.  This is needed because generated ServiceClient\n                // implementations do not set baseUri until after ServiceClient's constructor\n                // is finished, leaving baseUri empty at the time when it is needed to\n                // build the correct scope name.\n                const wrappedPolicyFactory = () => {\n                    let bearerTokenPolicyFactory = undefined;\n                    // eslint-disable-next-line @typescript-eslint/no-this-alias\n                    const serviceClient = this;\n                    const serviceClientOptions = options;\n                    return {\n                        create(nextPolicy, createOptions) {\n                            const credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);\n                            if (!credentialScopes) {\n                                throw new Error(`When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy`);\n                            }\n                            if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, credentialScopes);\n                            }\n                            return bearerTokenPolicyFactory.create(nextPolicy, createOptions);\n                        }\n                    };\n                };\n                authPolicyFactory = wrappedPolicyFactory();\n            }\n            else if (credentials && typeof credentials.signRequest === \"function\") {\n                logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n                authPolicyFactory = signingPolicy(credentials);\n            }\n            else if (credentials !== undefined && credentials !== null) {\n                throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n            }\n            logger.info(\"ServiceClient: using default request policies\");\n            requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n            if (options.requestPolicyFactories) {\n                // options.requestPolicyFactories can also be a function that manipulates\n                // the default requestPolicyFactories array\n                const newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);\n                if (newRequestPolicyFactories) {\n                    requestPolicyFactories = newRequestPolicyFactories;\n                }\n            }\n        }\n        this._requestPolicyFactories = requestPolicyFactories;\n    }\n    /**\n     * Send the provided httpRequest.\n     */\n    sendRequest(options) {\n        if (options === null || options === undefined || typeof options !== \"object\") {\n            throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n        }\n        let httpRequest;\n        try {\n            if (isWebResourceLike(options)) {\n                options.validateRequestProperties();\n                httpRequest = options;\n            }\n            else {\n                httpRequest = new WebResource();\n                httpRequest = httpRequest.prepare(options);\n            }\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n        let httpPipeline = this._httpClient;\n        if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n            for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n                httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);\n            }\n        }\n        return httpPipeline.sendRequest(httpRequest);\n    }\n    /**\n     * Send an HTTP request that is populated using the provided OperationSpec.\n     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n     * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n     * @param callback - The callback to call when the response is received.\n     */\n    async sendOperationRequest(operationArguments, operationSpec, callback) {\n        var _a;\n        if (typeof operationArguments.options === \"function\") {\n            callback = operationArguments.options;\n            operationArguments.options = undefined;\n        }\n        const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n        const httpRequest = new WebResource();\n        let result;\n        try {\n            const baseUri = operationSpec.baseUrl || this.baseUri;\n            if (!baseUri) {\n                throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\");\n            }\n            httpRequest.method = operationSpec.httpMethod;\n            httpRequest.operationSpec = operationSpec;\n            const requestUrl = URLBuilder.parse(baseUri);\n            if (operationSpec.path) {\n                requestUrl.appendPath(operationSpec.path);\n            }\n            if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n                for (const urlParameter of operationSpec.urlParameters) {\n                    let urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);\n                    urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter), serializerOptions);\n                    if (!urlParameter.skipEncoding) {\n                        urlParameterValue = encodeURIComponent(urlParameterValue);\n                    }\n                    requestUrl.replaceAll(`{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`, urlParameterValue);\n                }\n            }\n            if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n                for (const queryParameter of operationSpec.queryParameters) {\n                    let queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);\n                    if (queryParameterValue !== undefined && queryParameterValue !== null) {\n                        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter), serializerOptions);\n                        if (queryParameter.collectionFormat !== undefined &&\n                            queryParameter.collectionFormat !== null) {\n                            if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                                if (queryParameterValue.length === 0) {\n                                    // The collection is empty, no need to try serializing the current queryParam\n                                    continue;\n                                }\n                                else {\n                                    for (const index in queryParameterValue) {\n                                        const item = queryParameterValue[index];\n                                        queryParameterValue[index] =\n                                            item === undefined || item === null ? \"\" : item.toString();\n                                    }\n                                }\n                            }\n                            else if (queryParameter.collectionFormat === QueryCollectionFormat.Ssv ||\n                                queryParameter.collectionFormat === QueryCollectionFormat.Tsv) {\n                                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n                            }\n                        }\n                        if (!queryParameter.skipEncoding) {\n                            if (Array.isArray(queryParameterValue)) {\n                                for (const index in queryParameterValue) {\n                                    if (queryParameterValue[index] !== undefined &&\n                                        queryParameterValue[index] !== null) {\n                                        queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                                    }\n                                }\n                            }\n                            else {\n                                queryParameterValue = encodeURIComponent(queryParameterValue);\n                            }\n                        }\n                        if (queryParameter.collectionFormat !== undefined &&\n                            queryParameter.collectionFormat !== null &&\n                            queryParameter.collectionFormat !== QueryCollectionFormat.Multi &&\n                            queryParameter.collectionFormat !== QueryCollectionFormat.Ssv &&\n                            queryParameter.collectionFormat !== QueryCollectionFormat.Tsv) {\n                            queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n                        }\n                        requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n                    }\n                }\n            }\n            httpRequest.url = requestUrl.toString();\n            const contentType = operationSpec.contentType || this.requestContentType;\n            if (contentType && operationSpec.requestBody) {\n                httpRequest.headers.set(\"Content-Type\", contentType);\n            }\n            if (operationSpec.headerParameters) {\n                for (const headerParameter of operationSpec.headerParameters) {\n                    let headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);\n                    if (headerValue !== undefined && headerValue !== null) {\n                        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter), serializerOptions);\n                        const headerCollectionPrefix = headerParameter.mapper\n                            .headerCollectionPrefix;\n                        if (headerCollectionPrefix) {\n                            for (const key of Object.keys(headerValue)) {\n                                httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n                            }\n                        }\n                        else {\n                            httpRequest.headers.set(headerParameter.mapper.serializedName ||\n                                getPathStringFromParameter(headerParameter), headerValue);\n                        }\n                    }\n                }\n            }\n            const options = operationArguments.options;\n            if (options) {\n                if (options.customHeaders) {\n                    for (const customHeaderName in options.customHeaders) {\n                        httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n                    }\n                }\n                if (options.abortSignal) {\n                    httpRequest.abortSignal = options.abortSignal;\n                }\n                if (options.timeout) {\n                    httpRequest.timeout = options.timeout;\n                }\n                if (options.onUploadProgress) {\n                    httpRequest.onUploadProgress = options.onUploadProgress;\n                }\n                if (options.onDownloadProgress) {\n                    httpRequest.onDownloadProgress = options.onDownloadProgress;\n                }\n                if (options.spanOptions) {\n                    // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.\n                    httpRequest.spanOptions = options.spanOptions;\n                }\n                if (options.tracingContext) {\n                    httpRequest.tracingContext = options.tracingContext;\n                }\n                if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n                    httpRequest.shouldDeserialize = options.shouldDeserialize;\n                }\n            }\n            httpRequest.withCredentials = this._withCredentials;\n            serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n            if (httpRequest.streamResponseStatusCodes === undefined) {\n                httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);\n            }\n            let rawResponse;\n            let sendRequestError;\n            try {\n                rawResponse = await this.sendRequest(httpRequest);\n            }\n            catch (error) {\n                sendRequestError = error;\n            }\n            if (sendRequestError) {\n                if (sendRequestError.response) {\n                    sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] ||\n                        operationSpec.responses[\"default\"]);\n                }\n                result = Promise.reject(sendRequestError);\n            }\n            else {\n                result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));\n            }\n        }\n        catch (error) {\n            result = Promise.reject(error);\n        }\n        const cb = callback;\n        if (cb) {\n            result\n                .then((res) => cb(null, res._response.parsedBody, res._response.request, res._response))\n                .catch((err) => cb(err));\n        }\n        return result;\n    }\n}\nexport function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {\n    var _a, _b, _c, _d, _e, _f;\n    const serializerOptions = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions) !== null && _b !== void 0 ? _b : {};\n    const updatedOptions = {\n        rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : \"\",\n        includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,\n        xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : XML_CHARKEY\n    };\n    const xmlCharKey = serializerOptions.xmlCharKey;\n    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n        httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);\n        const bodyMapper = operationSpec.requestBody.mapper;\n        const { required, xmlName, xmlElementName, serializedName, xmlNamespace, xmlNamespacePrefix } = bodyMapper;\n        const typeName = bodyMapper.type.name;\n        try {\n            if ((httpRequest.body !== undefined && httpRequest.body !== null) || required) {\n                const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n                httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);\n                const isStream = typeName === MapperType.Stream;\n                if (operationSpec.isXML) {\n                    const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n                    const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);\n                    if (typeName === MapperType.Sequence) {\n                        httpRequest.body = stringifyXML(utils.prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {\n                            rootName: xmlName || serializedName,\n                            xmlCharKey\n                        });\n                    }\n                    else if (!isStream) {\n                        httpRequest.body = stringifyXML(value, {\n                            rootName: xmlName || serializedName,\n                            xmlCharKey\n                        });\n                    }\n                }\n                else if (typeName === MapperType.String &&\n                    (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n                    // the String serializer has validated that request body is a string\n                    // so just send the string.\n                    return;\n                }\n                else if (!isStream) {\n                    httpRequest.body = JSON.stringify(httpRequest.body);\n                }\n            }\n        }\n        catch (error) {\n            throw new Error(`Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, \"  \")}.`);\n        }\n    }\n    else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n        httpRequest.formData = {};\n        for (const formDataParameter of operationSpec.formDataParameters) {\n            const formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);\n            if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n                const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n                httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n            }\n        }\n    }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n    // Composite and Sequence schemas already got their root namespace set during serialization\n    // We just need to add xmlns to the other schema types\n    if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n        const result = {};\n        result[options.xmlCharKey] = serializedValue;\n        result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };\n        return result;\n    }\n    return serializedValue;\n}\nfunction getValueOrFunctionResult(value, defaultValueCreator) {\n    let result;\n    if (typeof value === \"string\") {\n        result = value;\n    }\n    else {\n        result = defaultValueCreator();\n        if (typeof value === \"function\") {\n            result = value(result);\n        }\n    }\n    return result;\n}\nfunction createDefaultRequestPolicyFactories(authPolicyFactory, options) {\n    const factories = [];\n    if (options.generateClientRequestIdHeader) {\n        factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n    }\n    if (authPolicyFactory) {\n        factories.push(authPolicyFactory);\n    }\n    const userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);\n    const userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);\n    if (userAgentHeaderName && userAgentHeaderValue) {\n        factories.push(userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue }));\n    }\n    factories.push(redirectPolicy());\n    factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n    if (!options.noRetryPolicy) {\n        factories.push(exponentialRetryPolicy());\n        factories.push(systemErrorRetryPolicy());\n        factories.push(throttlingRetryPolicy());\n    }\n    factories.push(deserializationPolicy(options.deserializationContentTypes));\n    if (isNode) {\n        factories.push(proxyPolicy(options.proxySettings));\n    }\n    factories.push(logPolicy({ logger: logger.info }));\n    return factories;\n}\nexport function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {\n    const requestPolicyFactories = [];\n    if (pipelineOptions.sendStreamingJson) {\n        requestPolicyFactories.push(ndJsonPolicy());\n    }\n    let userAgentValue = undefined;\n    if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n        const userAgentInfo = [];\n        userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n        // Add the default user agent value if it isn't already specified\n        // by the userAgentPrefix option.\n        const defaultUserAgentInfo = getDefaultUserAgentValue();\n        if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n            userAgentInfo.push(defaultUserAgentInfo);\n        }\n        userAgentValue = userAgentInfo.join(\" \");\n    }\n    const keepAliveOptions = Object.assign(Object.assign({}, DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);\n    const retryOptions = Object.assign(Object.assign({}, DefaultRetryOptions), pipelineOptions.retryOptions);\n    const redirectOptions = Object.assign(Object.assign({}, DefaultRedirectOptions), pipelineOptions.redirectOptions);\n    if (isNode) {\n        requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n    }\n    const deserializationOptions = Object.assign(Object.assign({}, DefaultDeserializationOptions), pipelineOptions.deserializationOptions);\n    const loggingOptions = Object.assign({}, pipelineOptions.loggingOptions);\n    requestPolicyFactories.push(tracingPolicy({ userAgent: userAgentValue }), keepAlivePolicy(keepAliveOptions), userAgentPolicy({ value: userAgentValue }), generateClientRequestIdPolicy(), deserializationPolicy(deserializationOptions.expectedContentTypes), throttlingRetryPolicy(), systemErrorRetryPolicy(), exponentialRetryPolicy(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));\n    if (redirectOptions.handleRedirects) {\n        requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n    }\n    if (authPolicyFactory) {\n        requestPolicyFactories.push(authPolicyFactory);\n    }\n    requestPolicyFactories.push(logPolicy(loggingOptions));\n    if (isNode && pipelineOptions.decompressResponse === false) {\n        requestPolicyFactories.push(disableResponseDecompressionPolicy());\n    }\n    return {\n        httpClient: pipelineOptions.httpClient,\n        requestPolicyFactories\n    };\n}\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent, propertyPath) {\n    if (parent && propertyPath) {\n        const propertyPathLength = propertyPath.length;\n        for (let i = 0; i < propertyPathLength - 1; ++i) {\n            const propertyName = propertyPath[i];\n            if (!parent[propertyName]) {\n                parent[propertyName] = {};\n            }\n            parent = parent[propertyName];\n        }\n    }\n    return parent;\n}\nfunction getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {\n    return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);\n}\nexport function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {\n    var _a;\n    let value;\n    if (typeof parameterPath === \"string\") {\n        parameterPath = [parameterPath];\n    }\n    const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n    if (Array.isArray(parameterPath)) {\n        if (parameterPath.length > 0) {\n            if (parameterMapper.isConstant) {\n                value = parameterMapper.defaultValue;\n            }\n            else {\n                let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n                if (!propertySearchResult.propertyFound) {\n                    propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n                }\n                let useDefaultValue = false;\n                if (!propertySearchResult.propertyFound) {\n                    useDefaultValue =\n                        parameterMapper.required ||\n                            (parameterPath[0] === \"options\" && parameterPath.length === 2);\n                }\n                value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n            }\n            // Serialize just for validation purposes.\n            const parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);\n            serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);\n        }\n    }\n    else {\n        if (parameterMapper.required) {\n            value = {};\n        }\n        for (const propertyName in parameterPath) {\n            const propertyMapper = parameterMapper.type.modelProperties[propertyName];\n            const propertyPath = parameterPath[propertyName];\n            const propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer);\n            // Serialize just for validation purposes.\n            const propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);\n            serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);\n            if (propertyValue !== undefined && propertyValue !== null) {\n                if (!value) {\n                    value = {};\n                }\n                value[propertyName] = propertyValue;\n            }\n        }\n    }\n    return value;\n}\nfunction getPropertyFromParameterPath(parent, parameterPath) {\n    const result = { propertyFound: false };\n    let i = 0;\n    for (; i < parameterPath.length; ++i) {\n        const parameterPathPart = parameterPath[i];\n        // Make sure to check inherited properties too, so don't use hasOwnProperty().\n        if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n            parent = parent[parameterPathPart];\n        }\n        else {\n            break;\n        }\n    }\n    if (i === parameterPath.length) {\n        result.propertyValue = parent;\n        result.propertyFound = true;\n    }\n    return result;\n}\nexport function flattenResponse(_response, responseSpec) {\n    const parsedHeaders = _response.parsedHeaders;\n    const bodyMapper = responseSpec && responseSpec.bodyMapper;\n    const addOperationResponse = (obj) => {\n        return Object.defineProperty(obj, \"_response\", {\n            value: _response\n        });\n    };\n    if (bodyMapper) {\n        const typeName = bodyMapper.type.name;\n        if (typeName === \"Stream\") {\n            return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), { blobBody: _response.blobBody, readableStreamBody: _response.readableStreamBody }));\n        }\n        const modelProperties = (typeName === \"Composite\" && bodyMapper.type.modelProperties) || {};\n        const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === \"\");\n        if (typeName === \"Sequence\" || isPageableResponse) {\n            const arrayResponse = [...(_response.parsedBody || [])];\n            for (const key of Object.keys(modelProperties)) {\n                if (modelProperties[key].serializedName) {\n                    arrayResponse[key] = _response.parsedBody[key];\n                }\n            }\n            if (parsedHeaders) {\n                for (const key of Object.keys(parsedHeaders)) {\n                    arrayResponse[key] = parsedHeaders[key];\n                }\n            }\n            addOperationResponse(arrayResponse);\n            return arrayResponse;\n        }\n        if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n            return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n        }\n    }\n    if (bodyMapper ||\n        _response.request.method === \"HEAD\" ||\n        utils.isPrimitiveType(_response.parsedBody)) {\n        // primitive body types and HEAD booleans\n        return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), { body: _response.parsedBody }));\n    }\n    return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));\n}\nfunction getCredentialScopes(options, baseUri) {\n    if (options === null || options === void 0 ? void 0 : options.credentialScopes) {\n        const scopes = options.credentialScopes;\n        return Array.isArray(scopes)\n            ? scopes.map((scope) => new URL(scope).toString())\n            : new URL(scopes).toString();\n    }\n    if (baseUri) {\n        return `${baseUri}/.default`;\n    }\n    return undefined;\n}\n//# sourceMappingURL=serviceClient.js.map"]},"metadata":{},"sourceType":"module"}