{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { RestError } from \"../restError\";\nimport { MapperType } from \"../serializer\";\nimport { parseXML } from \"../util/xml\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { XML_CHARKEY } from \"../util/serializer.common\";\n/**\n * Create a new serialization RequestPolicyCreator that will serialized HTTP request bodies as they\n * pass through the HTTP pipeline.\n */\n\nexport function deserializationPolicy(deserializationContentTypes, parsingOptions) {\n  return {\n    create: (nextPolicy, options) => {\n      return new DeserializationPolicy(nextPolicy, options, deserializationContentTypes, parsingOptions);\n    }\n  };\n}\nexport const defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nexport const defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\nexport const DefaultDeserializationOptions = {\n  expectedContentTypes: {\n    json: defaultJsonContentTypes,\n    xml: defaultXmlContentTypes\n  }\n};\n/**\n * A RequestPolicy that will deserialize HTTP response bodies and headers as they pass through the\n * HTTP pipeline.\n */\n\nexport class DeserializationPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy, requestPolicyOptions, deserializationContentTypes, parsingOptions = {}) {\n    var _a;\n\n    super(nextPolicy, requestPolicyOptions);\n    this.jsonContentTypes = deserializationContentTypes && deserializationContentTypes.json || defaultJsonContentTypes;\n    this.xmlContentTypes = deserializationContentTypes && deserializationContentTypes.xml || defaultXmlContentTypes;\n    this.xmlCharKey = (_a = parsingOptions.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;\n  }\n\n  sendRequest(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this._nextPolicy.sendRequest(request).then(response => deserializeResponseBody(_this.jsonContentTypes, _this.xmlContentTypes, response, {\n        xmlCharKey: _this.xmlCharKey\n      }));\n    })();\n  }\n\n}\n\nfunction getOperationResponse(parsedResponse) {\n  let result;\n  const request = parsedResponse.request;\n  const operationSpec = request.operationSpec;\n\n  if (operationSpec) {\n    const operationResponseGetter = request.operationResponseGetter;\n\n    if (!operationResponseGetter) {\n      result = operationSpec.responses[parsedResponse.status];\n    } else {\n      result = operationResponseGetter(operationSpec, parsedResponse);\n    }\n  }\n\n  return result;\n}\n\nfunction shouldDeserializeResponse(parsedResponse) {\n  const shouldDeserialize = parsedResponse.request.shouldDeserialize;\n  let result;\n\n  if (shouldDeserialize === undefined) {\n    result = true;\n  } else if (typeof shouldDeserialize === \"boolean\") {\n    result = shouldDeserialize;\n  } else {\n    result = shouldDeserialize(parsedResponse);\n  }\n\n  return result;\n}\n\nexport function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options = {}) {\n  var _a, _b, _c;\n\n  const updatedOptions = {\n    rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : \"\",\n    includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,\n    xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n  };\n  return parse(jsonContentTypes, xmlContentTypes, response, updatedOptions).then(parsedResponse => {\n    if (!shouldDeserializeResponse(parsedResponse)) {\n      return parsedResponse;\n    }\n\n    const operationSpec = parsedResponse.request.operationSpec;\n\n    if (!operationSpec || !operationSpec.responses) {\n      return parsedResponse;\n    }\n\n    const responseSpec = getOperationResponse(parsedResponse);\n    const {\n      error,\n      shouldReturnResponse\n    } = handleErrorResponse(parsedResponse, operationSpec, responseSpec);\n\n    if (error) {\n      throw error;\n    } else if (shouldReturnResponse) {\n      return parsedResponse;\n    } // An operation response spec does exist for current status code, so\n    // use it to deserialize the response.\n\n\n    if (responseSpec) {\n      if (responseSpec.bodyMapper) {\n        let valueToDeserialize = parsedResponse.parsedBody;\n\n        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperType.Sequence) {\n          valueToDeserialize = typeof valueToDeserialize === \"object\" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];\n        }\n\n        try {\n          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, \"operationRes.parsedBody\", options);\n        } catch (innerError) {\n          const restError = new RestError(`Error ${innerError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, undefined, parsedResponse.status, parsedResponse.request, parsedResponse);\n          throw restError;\n        }\n      } else if (operationSpec.httpMethod === \"HEAD\") {\n        // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n      }\n\n      if (responseSpec.headersMapper) {\n        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.rawHeaders(), \"operationRes.parsedHeaders\", options);\n      }\n    }\n\n    return parsedResponse;\n  });\n}\n\nfunction isOperationSpecEmpty(operationSpec) {\n  const expectedStatusCodes = Object.keys(operationSpec.responses);\n  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\";\n}\n\nfunction handleErrorResponse(parsedResponse, operationSpec, responseSpec) {\n  var _a;\n\n  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;\n\n  if (isExpectedStatusCode) {\n    if (responseSpec) {\n      if (!responseSpec.isError) {\n        return {\n          error: null,\n          shouldReturnResponse: false\n        };\n      }\n    } else {\n      return {\n        error: null,\n        shouldReturnResponse: false\n      };\n    }\n  }\n\n  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;\n  const streaming = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) || parsedResponse.request.streamResponseBody;\n  const initialErrorMessage = streaming ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;\n  const error = new RestError(initialErrorMessage, undefined, parsedResponse.status, parsedResponse.request, parsedResponse); // If the item failed but there's no error spec or default spec to deserialize the error,\n  // we should fail so we just throw the parsed response\n\n  if (!errorResponseSpec) {\n    throw error;\n  }\n\n  const defaultBodyMapper = errorResponseSpec.bodyMapper;\n  const defaultHeadersMapper = errorResponseSpec.headersMapper;\n\n  try {\n    // If error response has a body, try to deserialize it using default body mapper.\n    // Then try to extract error code & message from it\n    if (parsedResponse.parsedBody) {\n      const parsedBody = parsedResponse.parsedBody;\n      let parsedError;\n\n      if (defaultBodyMapper) {\n        let valueToDeserialize = parsedBody;\n\n        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperType.Sequence) {\n          valueToDeserialize = typeof parsedBody === \"object\" ? parsedBody[defaultBodyMapper.xmlElementName] : [];\n        }\n\n        parsedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, \"error.response.parsedBody\");\n      }\n\n      const internalError = parsedBody.error || parsedError || parsedBody;\n      error.code = internalError.code;\n\n      if (internalError.message) {\n        error.message = internalError.message;\n      }\n\n      if (defaultBodyMapper) {\n        error.response.parsedBody = parsedError;\n      }\n    } // If error response has headers, try to deserialize it using default header mapper\n\n\n    if (parsedResponse.headers && defaultHeadersMapper) {\n      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.rawHeaders(), \"operationRes.parsedHeaders\");\n    }\n  } catch (defaultError) {\n    error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n  }\n\n  return {\n    error,\n    shouldReturnResponse: false\n  };\n}\n\nfunction parse(jsonContentTypes, xmlContentTypes, operationResponse, opts) {\n  var _a;\n\n  const errorHandler = err => {\n    const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n    const errCode = err.code || RestError.PARSE_ERROR;\n    const e = new RestError(msg, errCode, operationResponse.status, operationResponse.request, operationResponse);\n    return Promise.reject(e);\n  };\n\n  const streaming = ((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) || operationResponse.request.streamResponseBody;\n\n  if (!streaming && operationResponse.bodyAsText) {\n    const text = operationResponse.bodyAsText;\n    const contentType = operationResponse.headers.get(\"Content-Type\") || \"\";\n    const contentComponents = !contentType ? [] : contentType.split(\";\").map(component => component.toLowerCase());\n\n    if (contentComponents.length === 0 || contentComponents.some(component => jsonContentTypes.indexOf(component) !== -1)) {\n      return new Promise(resolve => {\n        operationResponse.parsedBody = JSON.parse(text);\n        resolve(operationResponse);\n      }).catch(errorHandler);\n    } else if (contentComponents.some(component => xmlContentTypes.indexOf(component) !== -1)) {\n      return parseXML(text, opts).then(body => {\n        operationResponse.parsedBody = body;\n        return operationResponse;\n      }).catch(errorHandler);\n    }\n  }\n\n  return Promise.resolve(operationResponse);\n} //# sourceMappingURL=deserializationPolicy.js.map","map":{"version":3,"sources":["F:/statvalu/AR_DocuExpert_Test/node_modules/@azure/core-http/dist-esm/src/policies/deserializationPolicy.js"],"names":["RestError","MapperType","parseXML","BaseRequestPolicy","XML_CHARKEY","deserializationPolicy","deserializationContentTypes","parsingOptions","create","nextPolicy","options","DeserializationPolicy","defaultJsonContentTypes","defaultXmlContentTypes","DefaultDeserializationOptions","expectedContentTypes","json","xml","constructor","requestPolicyOptions","_a","jsonContentTypes","xmlContentTypes","xmlCharKey","sendRequest","request","_nextPolicy","then","response","deserializeResponseBody","getOperationResponse","parsedResponse","result","operationSpec","operationResponseGetter","responses","status","shouldDeserializeResponse","shouldDeserialize","undefined","_b","_c","updatedOptions","rootName","includeRoot","parse","responseSpec","error","shouldReturnResponse","handleErrorResponse","bodyMapper","valueToDeserialize","parsedBody","isXML","type","name","Sequence","xmlElementName","serializer","deserialize","innerError","restError","bodyAsText","httpMethod","headersMapper","parsedHeaders","headers","rawHeaders","isOperationSpecEmpty","expectedStatusCodes","Object","keys","length","isSuccessByStatus","isExpectedStatusCode","isError","errorResponseSpec","default","streaming","streamResponseStatusCodes","has","streamResponseBody","initialErrorMessage","defaultBodyMapper","defaultHeadersMapper","parsedError","internalError","code","message","defaultError","operationResponse","opts","errorHandler","err","msg","errCode","PARSE_ERROR","e","Promise","reject","text","contentType","get","contentComponents","split","map","component","toLowerCase","some","indexOf","resolve","JSON","catch","body"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { RestError } from \"../restError\";\nimport { MapperType } from \"../serializer\";\nimport { parseXML } from \"../util/xml\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { XML_CHARKEY } from \"../util/serializer.common\";\n/**\n * Create a new serialization RequestPolicyCreator that will serialized HTTP request bodies as they\n * pass through the HTTP pipeline.\n */\nexport function deserializationPolicy(deserializationContentTypes, parsingOptions) {\n    return {\n        create: (nextPolicy, options) => {\n            return new DeserializationPolicy(nextPolicy, options, deserializationContentTypes, parsingOptions);\n        }\n    };\n}\nexport const defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nexport const defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\nexport const DefaultDeserializationOptions = {\n    expectedContentTypes: {\n        json: defaultJsonContentTypes,\n        xml: defaultXmlContentTypes\n    }\n};\n/**\n * A RequestPolicy that will deserialize HTTP response bodies and headers as they pass through the\n * HTTP pipeline.\n */\nexport class DeserializationPolicy extends BaseRequestPolicy {\n    constructor(nextPolicy, requestPolicyOptions, deserializationContentTypes, parsingOptions = {}) {\n        var _a;\n        super(nextPolicy, requestPolicyOptions);\n        this.jsonContentTypes =\n            (deserializationContentTypes && deserializationContentTypes.json) || defaultJsonContentTypes;\n        this.xmlContentTypes =\n            (deserializationContentTypes && deserializationContentTypes.xml) || defaultXmlContentTypes;\n        this.xmlCharKey = (_a = parsingOptions.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;\n    }\n    async sendRequest(request) {\n        return this._nextPolicy.sendRequest(request).then((response) => deserializeResponseBody(this.jsonContentTypes, this.xmlContentTypes, response, {\n            xmlCharKey: this.xmlCharKey\n        }));\n    }\n}\nfunction getOperationResponse(parsedResponse) {\n    let result;\n    const request = parsedResponse.request;\n    const operationSpec = request.operationSpec;\n    if (operationSpec) {\n        const operationResponseGetter = request.operationResponseGetter;\n        if (!operationResponseGetter) {\n            result = operationSpec.responses[parsedResponse.status];\n        }\n        else {\n            result = operationResponseGetter(operationSpec, parsedResponse);\n        }\n    }\n    return result;\n}\nfunction shouldDeserializeResponse(parsedResponse) {\n    const shouldDeserialize = parsedResponse.request.shouldDeserialize;\n    let result;\n    if (shouldDeserialize === undefined) {\n        result = true;\n    }\n    else if (typeof shouldDeserialize === \"boolean\") {\n        result = shouldDeserialize;\n    }\n    else {\n        result = shouldDeserialize(parsedResponse);\n    }\n    return result;\n}\nexport function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options = {}) {\n    var _a, _b, _c;\n    const updatedOptions = {\n        rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : \"\",\n        includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,\n        xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n    };\n    return parse(jsonContentTypes, xmlContentTypes, response, updatedOptions).then((parsedResponse) => {\n        if (!shouldDeserializeResponse(parsedResponse)) {\n            return parsedResponse;\n        }\n        const operationSpec = parsedResponse.request.operationSpec;\n        if (!operationSpec || !operationSpec.responses) {\n            return parsedResponse;\n        }\n        const responseSpec = getOperationResponse(parsedResponse);\n        const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec);\n        if (error) {\n            throw error;\n        }\n        else if (shouldReturnResponse) {\n            return parsedResponse;\n        }\n        // An operation response spec does exist for current status code, so\n        // use it to deserialize the response.\n        if (responseSpec) {\n            if (responseSpec.bodyMapper) {\n                let valueToDeserialize = parsedResponse.parsedBody;\n                if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperType.Sequence) {\n                    valueToDeserialize =\n                        typeof valueToDeserialize === \"object\"\n                            ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName]\n                            : [];\n                }\n                try {\n                    parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, \"operationRes.parsedBody\", options);\n                }\n                catch (innerError) {\n                    const restError = new RestError(`Error ${innerError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, undefined, parsedResponse.status, parsedResponse.request, parsedResponse);\n                    throw restError;\n                }\n            }\n            else if (operationSpec.httpMethod === \"HEAD\") {\n                // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n                parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n            }\n            if (responseSpec.headersMapper) {\n                parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.rawHeaders(), \"operationRes.parsedHeaders\", options);\n            }\n        }\n        return parsedResponse;\n    });\n}\nfunction isOperationSpecEmpty(operationSpec) {\n    const expectedStatusCodes = Object.keys(operationSpec.responses);\n    return (expectedStatusCodes.length === 0 ||\n        (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\"));\n}\nfunction handleErrorResponse(parsedResponse, operationSpec, responseSpec) {\n    var _a;\n    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec)\n        ? isSuccessByStatus\n        : !!responseSpec;\n    if (isExpectedStatusCode) {\n        if (responseSpec) {\n            if (!responseSpec.isError) {\n                return { error: null, shouldReturnResponse: false };\n            }\n        }\n        else {\n            return { error: null, shouldReturnResponse: false };\n        }\n    }\n    const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;\n    const streaming = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) ||\n        parsedResponse.request.streamResponseBody;\n    const initialErrorMessage = streaming\n        ? `Unexpected status code: ${parsedResponse.status}`\n        : parsedResponse.bodyAsText;\n    const error = new RestError(initialErrorMessage, undefined, parsedResponse.status, parsedResponse.request, parsedResponse);\n    // If the item failed but there's no error spec or default spec to deserialize the error,\n    // we should fail so we just throw the parsed response\n    if (!errorResponseSpec) {\n        throw error;\n    }\n    const defaultBodyMapper = errorResponseSpec.bodyMapper;\n    const defaultHeadersMapper = errorResponseSpec.headersMapper;\n    try {\n        // If error response has a body, try to deserialize it using default body mapper.\n        // Then try to extract error code & message from it\n        if (parsedResponse.parsedBody) {\n            const parsedBody = parsedResponse.parsedBody;\n            let parsedError;\n            if (defaultBodyMapper) {\n                let valueToDeserialize = parsedBody;\n                if (operationSpec.isXML && defaultBodyMapper.type.name === MapperType.Sequence) {\n                    valueToDeserialize =\n                        typeof parsedBody === \"object\" ? parsedBody[defaultBodyMapper.xmlElementName] : [];\n                }\n                parsedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, \"error.response.parsedBody\");\n            }\n            const internalError = parsedBody.error || parsedError || parsedBody;\n            error.code = internalError.code;\n            if (internalError.message) {\n                error.message = internalError.message;\n            }\n            if (defaultBodyMapper) {\n                error.response.parsedBody = parsedError;\n            }\n        }\n        // If error response has headers, try to deserialize it using default header mapper\n        if (parsedResponse.headers && defaultHeadersMapper) {\n            error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.rawHeaders(), \"operationRes.parsedHeaders\");\n        }\n    }\n    catch (defaultError) {\n        error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n    }\n    return { error, shouldReturnResponse: false };\n}\nfunction parse(jsonContentTypes, xmlContentTypes, operationResponse, opts) {\n    var _a;\n    const errorHandler = (err) => {\n        const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n        const errCode = err.code || RestError.PARSE_ERROR;\n        const e = new RestError(msg, errCode, operationResponse.status, operationResponse.request, operationResponse);\n        return Promise.reject(e);\n    };\n    const streaming = ((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) ||\n        operationResponse.request.streamResponseBody;\n    if (!streaming && operationResponse.bodyAsText) {\n        const text = operationResponse.bodyAsText;\n        const contentType = operationResponse.headers.get(\"Content-Type\") || \"\";\n        const contentComponents = !contentType\n            ? []\n            : contentType.split(\";\").map((component) => component.toLowerCase());\n        if (contentComponents.length === 0 ||\n            contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {\n            return new Promise((resolve) => {\n                operationResponse.parsedBody = JSON.parse(text);\n                resolve(operationResponse);\n            }).catch(errorHandler);\n        }\n        else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {\n            return parseXML(text, opts)\n                .then((body) => {\n                operationResponse.parsedBody = body;\n                return operationResponse;\n            })\n                .catch(errorHandler);\n        }\n    }\n    return Promise.resolve(operationResponse);\n}\n//# sourceMappingURL=deserializationPolicy.js.map"]},"metadata":{},"sourceType":"module"}