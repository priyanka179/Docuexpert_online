{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/project/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\"; // Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isTokenCredential, isNode, getDefaultProxySettings } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { Container, Service } from \"./generated/src/operations\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { ContainerClient } from \"./ContainerClient\";\nimport { appendToURLPath, appendToURLQuery, extractConnectionStringParts, toTags } from \"./utils/utils.common\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport \"@azure/core-paging\";\nimport { truncatedISO8061Date } from \"./utils/utils.common\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport { BlobBatchClient } from \"./BlobBatchClient\";\nimport { StorageClient } from \"./StorageClient\";\nimport { AccountSASPermissions } from \"./sas/AccountSASPermissions\";\nimport { generateAccountSASQueryParameters } from \"./sas/AccountSASSignatureValues\";\nimport { AccountSASServices } from \"./sas/AccountSASServices\";\n/**\n * A BlobServiceClient represents a Client to the Azure Storage Blob service allowing you\n * to manipulate blob containers.\n */\n\nexport class BlobServiceClient extends StorageClient {\n  constructor(url, credentialOrPipeline, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    let pipeline;\n\n    if (isPipelineLike(credentialOrPipeline)) {\n      pipeline = credentialOrPipeline;\n    } else if (isNode && credentialOrPipeline instanceof StorageSharedKeyCredential || credentialOrPipeline instanceof AnonymousCredential || isTokenCredential(credentialOrPipeline)) {\n      pipeline = newPipeline(credentialOrPipeline, options);\n    } else {\n      // The second parameter is undefined. Use anonymous credential\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    }\n\n    super(url, pipeline);\n    this.serviceContext = new Service(this.storageClientContext);\n  }\n  /**\n   *\n   * Creates an instance of BlobServiceClient from connection string.\n   *\n   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n   *                                  Account connection string example -\n   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n   *                                  SAS connection string example -\n   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n\n\n  static fromConnectionString(connectionString, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    options = options || {};\n    const extractedCreds = extractConnectionStringParts(connectionString);\n\n    if (extractedCreds.kind === \"AccountConnString\") {\n      if (isNode) {\n        const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n        options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n        const pipeline = newPipeline(sharedKeyCredential, options);\n        return new BlobServiceClient(extractedCreds.url, pipeline);\n      } else {\n        throw new Error(\"Account connection string is only supported in Node.js environment\");\n      }\n    } else if (extractedCreds.kind === \"SASConnString\") {\n      const pipeline = newPipeline(new AnonymousCredential(), options);\n      return new BlobServiceClient(extractedCreds.url + \"?\" + extractedCreds.accountSas, pipeline);\n    } else {\n      throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n    }\n  }\n  /**\n   * Creates a {@link ContainerClient} object\n   *\n   * @param containerName - A container name\n   * @returns A new ContainerClient object for the given container name.\n   *\n   * Example usage:\n   *\n   * ```js\n   * const containerClient = blobServiceClient.getContainerClient(\"<container name>\");\n   * ```\n   */\n\n\n  getContainerClient(containerName) {\n    return new ContainerClient(appendToURLPath(this.url, encodeURIComponent(containerName)), this.pipeline);\n  }\n  /**\n   * Create a Blob container.\n   *\n   * @param containerName - Name of the container to create.\n   * @param options - Options to configure Container Create operation.\n   * @returns Container creation response and the corresponding container client.\n   */\n\n\n  createContainer(containerName, options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobServiceClient-createContainer\", options);\n\n      try {\n        const containerClient = _this.getContainerClient(containerName);\n\n        const containerCreateResponse = yield containerClient.create(updatedOptions);\n        return {\n          containerClient,\n          containerCreateResponse\n        };\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Deletes a Blob container.\n   *\n   * @param containerName - Name of the container to delete.\n   * @param options - Options to configure Container Delete operation.\n   * @returns Container deletion response.\n   */\n\n\n  deleteContainer(containerName, options = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobServiceClient-deleteContainer\", options);\n\n      try {\n        const containerClient = _this2.getContainerClient(containerName);\n\n        return yield containerClient.delete(updatedOptions);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Restore a previously deleted Blob container.\n   * This API is only functional if Container Soft Delete is enabled for the storage account associated with the container.\n   *\n   * @param deletedContainerName - Name of the previously deleted container.\n   * @param deletedContainerVersion - Version of the previously deleted container, used to uniquely identify the deleted container.\n   * @param options - Options to configure Container Restore operation.\n   * @returns Container deletion response.\n   */\n\n\n  undeleteContainer(deletedContainerName, deletedContainerVersion, options = {}) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobServiceClient-undeleteContainer\", options);\n\n      try {\n        const containerClient = _this3.getContainerClient(options.destinationContainerName || deletedContainerName); // Hack to access a protected member.\n\n\n        const containerContext = new Container(containerClient[\"storageClientContext\"]);\n        const containerUndeleteResponse = yield containerContext.restore(Object.assign({\n          deletedContainerName,\n          deletedContainerVersion\n        }, updatedOptions));\n        return {\n          containerClient,\n          containerUndeleteResponse\n        };\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Rename an existing Blob Container.\n   *\n   * @param sourceContainerName - The name of the source container.\n   * @param destinationContainerName - The new name of the container.\n   * @param options - Options to configure Container Rename operation.\n   */\n\n  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n  // @ts-ignore Need to hide this interface for now. Make it public and turn on the live tests for it when the service is ready.\n\n\n  renameContainer(sourceContainerName, destinationContainerName, options = {}) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobServiceClient-renameContainer\", options);\n\n      try {\n        const containerClient = _this4.getContainerClient(destinationContainerName); // Hack to access a protected member.\n\n\n        const containerContext = new Container(containerClient[\"storageClientContext\"]);\n        const containerRenameResponse = yield containerContext.rename(sourceContainerName, Object.assign(Object.assign({}, updatedOptions), {\n          sourceLeaseId: (_a = options.sourceCondition) === null || _a === void 0 ? void 0 : _a.leaseId\n        }));\n        return {\n          containerClient,\n          containerRenameResponse\n        };\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Gets the properties of a storage account’s Blob service, including properties\n   * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n   *\n   * @param options - Options to the Service Get Properties operation.\n   * @returns Response data for the Service Get Properties operation.\n   */\n\n\n  getProperties(options = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobServiceClient-getProperties\", options);\n\n      try {\n        return yield _this5.serviceContext.getProperties(Object.assign({\n          abortSignal: options.abortSignal\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets properties for a storage account’s Blob service endpoint, including properties\n   * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-service-properties\n   *\n   * @param properties -\n   * @param options - Options to the Service Set Properties operation.\n   * @returns Response data for the Service Set Properties operation.\n   */\n\n\n  setProperties(properties, options = {}) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobServiceClient-setProperties\", options);\n\n      try {\n        return yield _this6.serviceContext.setProperties(properties, Object.assign({\n          abortSignal: options.abortSignal\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Retrieves statistics related to replication for the Blob service. It is only\n   * available on the secondary location endpoint when read-access geo-redundant\n   * replication is enabled for the storage account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-stats\n   *\n   * @param options - Options to the Service Get Statistics operation.\n   * @returns Response data for the Service Get Statistics operation.\n   */\n\n\n  getStatistics(options = {}) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobServiceClient-getStatistics\", options);\n\n      try {\n        return yield _this7.serviceContext.getStatistics(Object.assign({\n          abortSignal: options.abortSignal\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * The Get Account Information operation returns the sku name and account kind\n   * for the specified account.\n   * The Get Account Information operation is available on service versions beginning\n   * with version 2018-03-28.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-account-information\n   *\n   * @param options - Options to the Service Get Account Info operation.\n   * @returns Response data for the Service Get Account Info operation.\n   */\n\n\n  getAccountInfo(options = {}) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobServiceClient-getAccountInfo\", options);\n\n      try {\n        return yield _this8.serviceContext.getAccountInfo(Object.assign({\n          abortSignal: options.abortSignal\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns a list of the containers under the specified account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-containers2\n   *\n   * @param marker - A string value that identifies the portion of\n   *                        the list of containers to be returned with the next listing operation. The\n   *                        operation returns the continuationToken value within the response body if the\n   *                        listing operation did not return all containers remaining to be listed\n   *                        with the current page. The continuationToken value can be used as the value for\n   *                        the marker parameter in a subsequent call to request the next page of list\n   *                        items. The marker value is opaque to the client.\n   * @param options - Options to the Service List Container Segment operation.\n   * @returns Response data for the Service List Container Segment operation.\n   */\n\n\n  listContainersSegment(marker, options = {}) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobServiceClient-listContainersSegment\", options);\n\n      try {\n        return yield _this9.serviceContext.listContainersSegment(Object.assign(Object.assign(Object.assign({\n          abortSignal: options.abortSignal,\n          marker\n        }, options), {\n          include: typeof options.include === \"string\" ? [options.include] : options.include\n        }), convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * The Filter Blobs operation enables callers to list blobs across all containers whose tags\n   * match a given search expression. Filter blobs searches across all containers within a\n   * storage account but can be scoped within the expression to a single container.\n   *\n   * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                        The given expression must evaluate to true for a blob to be returned in the results.\n   *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                        however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n\n\n  findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobServiceClient-findBlobsByTagsSegment\", options);\n\n      try {\n        const response = yield _this10.serviceContext.filterBlobs(Object.assign({\n          abortSignal: options.abortSignal,\n          where: tagFilterSqlExpression,\n          marker,\n          maxPageSize: options.maxPageSize\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n        const wrappedResponse = Object.assign(Object.assign({}, response), {\n          _response: response._response,\n          blobs: response.blobs.map(blob => {\n            var _a;\n\n            let tagValue = \"\";\n\n            if (((_a = blob.tags) === null || _a === void 0 ? void 0 : _a.blobTagSet.length) === 1) {\n              tagValue = blob.tags.blobTagSet[0].value;\n            }\n\n            return Object.assign(Object.assign({}, blob), {\n              tags: toTags(blob.tags),\n              tagValue\n            });\n          })\n        });\n        return wrappedResponse;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns an AsyncIterableIterator for ServiceFindBlobsByTagsSegmentResponse.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n\n\n  findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {\n    return __asyncGenerator(this, arguments, function* findBlobsByTagsSegments_1() {\n      let response;\n\n      if (!!marker || marker === undefined) {\n        do {\n          response = yield __await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options));\n          response.blobs = response.blobs || [];\n          marker = response.continuationToken;\n          yield yield __await(response);\n        } while (marker);\n      }\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator for blobs.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to findBlobsByTagsItems.\n   */\n\n\n  findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {\n    return __asyncGenerator(this, arguments, function* findBlobsByTagsItems_1() {\n      var e_1, _a;\n\n      let marker;\n\n      try {\n        for (var _b = __asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n          const segment = _c.value;\n          yield __await(yield* __asyncDelegator(__asyncValues(segment.blobs)));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  /**\n   * Returns an async iterable iterator to find all blobs with specified tag\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs in pages.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const blob of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\")) {\n   *   console.log(`Blob ${i++}: ${container.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\");\n   * let blobItem = await iter.next();\n   * while (!blobItem.done) {\n   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n   *   blobItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 20 })) {\n   *   if (response.blobs) {\n   *     for (const blob of response.blobs) {\n   *       console.log(`Blob ${i++}: ${blob.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *     console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = blobServiceClient\n   *   .findBlobsByTags(\"tagkey='tagvalue'\")\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *      console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to find blobs by tags.\n   */\n\n\n  findBlobsByTags(tagFilterSqlExpression, options = {}) {\n    // AsyncIterableIterator to iterate over blobs\n    const listSegmentOptions = Object.assign({}, options);\n    const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings = {}) => {\n        return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, listSegmentOptions));\n      }\n    };\n  }\n  /**\n   * Returns an AsyncIterableIterator for ServiceListContainersSegmentResponses\n   *\n   * @param marker - A string value that identifies the portion of\n   *                        the list of containers to be returned with the next listing operation. The\n   *                        operation returns the continuationToken value within the response body if the\n   *                        listing operation did not return all containers remaining to be listed\n   *                        with the current page. The continuationToken value can be used as the value for\n   *                        the marker parameter in a subsequent call to request the next page of list\n   *                        items. The marker value is opaque to the client.\n   * @param options - Options to list containers operation.\n   */\n\n\n  listSegments(marker, options = {}) {\n    return __asyncGenerator(this, arguments, function* listSegments_1() {\n      let listContainersSegmentResponse;\n\n      if (!!marker || marker === undefined) {\n        do {\n          listContainersSegmentResponse = yield __await(this.listContainersSegment(marker, options));\n          listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [];\n          marker = listContainersSegmentResponse.continuationToken;\n          yield yield __await(yield __await(listContainersSegmentResponse));\n        } while (marker);\n      }\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator for Container Items\n   *\n   * @param options - Options to list containers operation.\n   */\n\n\n  listItems(options = {}) {\n    return __asyncGenerator(this, arguments, function* listItems_1() {\n      var e_2, _a;\n\n      let marker;\n\n      try {\n        for (var _b = __asyncValues(this.listSegments(marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n          const segment = _c.value;\n          yield __await(yield* __asyncDelegator(__asyncValues(segment.containerItems)));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n  /**\n   * Returns an async iterable iterator to list all the containers\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the containers in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const container of blobServiceClient.listContainers()) {\n   *   console.log(`Container ${i++}: ${container.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = blobServiceClient.listContainers();\n   * let containerItem = await iter.next();\n   * while (!containerItem.done) {\n   *   console.log(`Container ${i++}: ${containerItem.value.name}`);\n   *   containerItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of blobServiceClient.listContainers().byPage({ maxPageSize: 20 })) {\n   *   if (response.containerItems) {\n   *     for (const container of response.containerItems) {\n   *       console.log(`Container ${i++}: ${container.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = blobServiceClient.listContainers().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 container names\n   * if (response.containerItems) {\n   *   for (const container of response.containerItems) {\n   *     console.log(`Container ${i++}: ${container.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = blobServiceClient\n   *   .listContainers()\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 container names\n   * if (response.containerItems) {\n   *   for (const container of response.containerItems) {\n   *      console.log(`Container ${i++}: ${container.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param options - Options to list containers.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n\n\n  listContainers(options = {}) {\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    const include = [];\n\n    if (options.includeDeleted) {\n      include.push(\"deleted\");\n    }\n\n    if (options.includeMetadata) {\n      include.push(\"metadata\");\n    } // AsyncIterableIterator to iterate over containers\n\n\n    const listSegmentOptions = Object.assign(Object.assign({}, options), include.length > 0 ? {\n      include\n    } : {});\n    const iter = this.listItems(listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings = {}) => {\n        return this.listSegments(settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, listSegmentOptions));\n      }\n    };\n  }\n  /**\n   * ONLY AVAILABLE WHEN USING BEARER TOKEN AUTHENTICATION (TokenCredential).\n   *\n   * Retrieves a user delegation key for the Blob service. This is only a valid operation when using\n   * bearer token authentication.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-user-delegation-key\n   *\n   * @param startsOn -      The start time for the user delegation SAS. Must be within 7 days of the current time\n   * @param expiresOn -     The end time for the user delegation SAS. Must be within 7 days of the current time\n   */\n\n\n  getUserDelegationKey(startsOn, expiresOn, options = {}) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BlobServiceClient-getUserDelegationKey\", options);\n\n      try {\n        const response = yield _this11.serviceContext.getUserDelegationKey({\n          startsOn: truncatedISO8061Date(startsOn, false),\n          expiresOn: truncatedISO8061Date(expiresOn, false)\n        }, Object.assign({\n          abortSignal: options.abortSignal\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n        const userDelegationKey = {\n          signedObjectId: response.signedObjectId,\n          signedTenantId: response.signedTenantId,\n          signedStartsOn: new Date(response.signedStartsOn),\n          signedExpiresOn: new Date(response.signedExpiresOn),\n          signedService: response.signedService,\n          signedVersion: response.signedVersion,\n          value: response.value\n        };\n        const res = Object.assign({\n          _response: response._response,\n          requestId: response.requestId,\n          clientRequestId: response.clientRequestId,\n          version: response.version,\n          date: response.date,\n          errorCode: response.errorCode\n        }, userDelegationKey);\n        return res;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a BlobBatchClient object to conduct batch operations.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch\n   *\n   * @returns A new BlobBatchClient object for this service.\n   */\n\n\n  getBlobBatchClient() {\n    return new BlobBatchClient(this.url, this.pipeline);\n  }\n  /**\n   * Only available for BlobServiceClient constructed with a shared key credential.\n   *\n   * Generates a Blob account Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-account-sas\n   *\n   * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.\n   * @param permissions - Specifies the list of permissions to be associated with the SAS.\n   * @param resourceTypes - Specifies the resource types associated with the shared access signature.\n   * @param options - Optional parameters.\n   * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n\n\n  generateAccountSasUrl(expiresOn, permissions = AccountSASPermissions.parse(\"r\"), resourceTypes = \"sco\", options = {}) {\n    if (!(this.credential instanceof StorageSharedKeyCredential)) {\n      throw RangeError(\"Can only generate the account SAS when the client is initialized with a shared key credential\");\n    }\n\n    if (expiresOn === undefined) {\n      const now = new Date();\n      expiresOn = new Date(now.getTime() + 3600 * 1000);\n    }\n\n    const sas = generateAccountSASQueryParameters(Object.assign({\n      permissions,\n      expiresOn,\n      resourceTypes,\n      services: AccountSASServices.parse(\"b\").toString()\n    }, options), this.credential).toString();\n    return appendToURLQuery(this.url, sas);\n  }\n\n} //# sourceMappingURL=BlobServiceClient.js.map","map":{"version":3,"sources":["F:/statvalu/project/AR_DocuExpert_Test/node_modules/@azure/storage-blob/dist-esm/storage-blob/src/BlobServiceClient.js"],"names":["__asyncDelegator","__asyncGenerator","__asyncValues","__await","isTokenCredential","isNode","getDefaultProxySettings","SpanStatusCode","Container","Service","newPipeline","isPipelineLike","ContainerClient","appendToURLPath","appendToURLQuery","extractConnectionStringParts","toTags","StorageSharedKeyCredential","AnonymousCredential","truncatedISO8061Date","convertTracingToRequestOptionsBase","createSpan","BlobBatchClient","StorageClient","AccountSASPermissions","generateAccountSASQueryParameters","AccountSASServices","BlobServiceClient","constructor","url","credentialOrPipeline","options","pipeline","serviceContext","storageClientContext","fromConnectionString","connectionString","extractedCreds","kind","sharedKeyCredential","accountName","accountKey","proxyOptions","proxyUri","Error","accountSas","getContainerClient","containerName","encodeURIComponent","createContainer","span","updatedOptions","containerClient","containerCreateResponse","create","e","setStatus","code","ERROR","message","end","deleteContainer","delete","undeleteContainer","deletedContainerName","deletedContainerVersion","destinationContainerName","containerContext","containerUndeleteResponse","restore","Object","assign","renameContainer","sourceContainerName","_a","containerRenameResponse","rename","sourceLeaseId","sourceCondition","leaseId","getProperties","abortSignal","setProperties","properties","getStatistics","getAccountInfo","listContainersSegment","marker","include","findBlobsByTagsSegment","tagFilterSqlExpression","response","filterBlobs","where","maxPageSize","wrappedResponse","_response","blobs","map","blob","tagValue","tags","blobTagSet","length","value","findBlobsByTagsSegments","arguments","findBlobsByTagsSegments_1","undefined","continuationToken","findBlobsByTagsItems","findBlobsByTagsItems_1","e_1","_b","_c","next","done","segment","e_1_1","error","return","call","findBlobsByTags","listSegmentOptions","iter","Symbol","asyncIterator","byPage","settings","listSegments","listSegments_1","listContainersSegmentResponse","containerItems","listItems","listItems_1","e_2","e_2_1","listContainers","prefix","includeDeleted","push","includeMetadata","getUserDelegationKey","startsOn","expiresOn","userDelegationKey","signedObjectId","signedTenantId","signedStartsOn","Date","signedExpiresOn","signedService","signedVersion","res","requestId","clientRequestId","version","date","errorCode","getBlobBatchClient","generateAccountSasUrl","permissions","parse","resourceTypes","credential","RangeError","now","getTime","sas","services","toString"],"mappings":"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","sourcesContent":["import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { isTokenCredential, isNode, getDefaultProxySettings } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { Container, Service } from \"./generated/src/operations\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { ContainerClient } from \"./ContainerClient\";\nimport { appendToURLPath, appendToURLQuery, extractConnectionStringParts, toTags } from \"./utils/utils.common\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport \"@azure/core-paging\";\nimport { truncatedISO8061Date } from \"./utils/utils.common\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport { BlobBatchClient } from \"./BlobBatchClient\";\nimport { StorageClient } from \"./StorageClient\";\nimport { AccountSASPermissions } from \"./sas/AccountSASPermissions\";\nimport { generateAccountSASQueryParameters } from \"./sas/AccountSASSignatureValues\";\nimport { AccountSASServices } from \"./sas/AccountSASServices\";\n/**\n * A BlobServiceClient represents a Client to the Azure Storage Blob service allowing you\n * to manipulate blob containers.\n */\nexport class BlobServiceClient extends StorageClient {\n    constructor(url, credentialOrPipeline, \n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options) {\n        let pipeline;\n        if (isPipelineLike(credentialOrPipeline)) {\n            pipeline = credentialOrPipeline;\n        }\n        else if ((isNode && credentialOrPipeline instanceof StorageSharedKeyCredential) ||\n            credentialOrPipeline instanceof AnonymousCredential ||\n            isTokenCredential(credentialOrPipeline)) {\n            pipeline = newPipeline(credentialOrPipeline, options);\n        }\n        else {\n            // The second parameter is undefined. Use anonymous credential\n            pipeline = newPipeline(new AnonymousCredential(), options);\n        }\n        super(url, pipeline);\n        this.serviceContext = new Service(this.storageClientContext);\n    }\n    /**\n     *\n     * Creates an instance of BlobServiceClient from connection string.\n     *\n     * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n     *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n     *                                  Account connection string example -\n     *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n     *                                  SAS connection string example -\n     *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n     * @param options - Optional. Options to configure the HTTP pipeline.\n     */\n    static fromConnectionString(connectionString, \n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options) {\n        options = options || {};\n        const extractedCreds = extractConnectionStringParts(connectionString);\n        if (extractedCreds.kind === \"AccountConnString\") {\n            if (isNode) {\n                const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n                options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n                const pipeline = newPipeline(sharedKeyCredential, options);\n                return new BlobServiceClient(extractedCreds.url, pipeline);\n            }\n            else {\n                throw new Error(\"Account connection string is only supported in Node.js environment\");\n            }\n        }\n        else if (extractedCreds.kind === \"SASConnString\") {\n            const pipeline = newPipeline(new AnonymousCredential(), options);\n            return new BlobServiceClient(extractedCreds.url + \"?\" + extractedCreds.accountSas, pipeline);\n        }\n        else {\n            throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n        }\n    }\n    /**\n     * Creates a {@link ContainerClient} object\n     *\n     * @param containerName - A container name\n     * @returns A new ContainerClient object for the given container name.\n     *\n     * Example usage:\n     *\n     * ```js\n     * const containerClient = blobServiceClient.getContainerClient(\"<container name>\");\n     * ```\n     */\n    getContainerClient(containerName) {\n        return new ContainerClient(appendToURLPath(this.url, encodeURIComponent(containerName)), this.pipeline);\n    }\n    /**\n     * Create a Blob container.\n     *\n     * @param containerName - Name of the container to create.\n     * @param options - Options to configure Container Create operation.\n     * @returns Container creation response and the corresponding container client.\n     */\n    async createContainer(containerName, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobServiceClient-createContainer\", options);\n        try {\n            const containerClient = this.getContainerClient(containerName);\n            const containerCreateResponse = await containerClient.create(updatedOptions);\n            return {\n                containerClient,\n                containerCreateResponse\n            };\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Deletes a Blob container.\n     *\n     * @param containerName - Name of the container to delete.\n     * @param options - Options to configure Container Delete operation.\n     * @returns Container deletion response.\n     */\n    async deleteContainer(containerName, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobServiceClient-deleteContainer\", options);\n        try {\n            const containerClient = this.getContainerClient(containerName);\n            return await containerClient.delete(updatedOptions);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Restore a previously deleted Blob container.\n     * This API is only functional if Container Soft Delete is enabled for the storage account associated with the container.\n     *\n     * @param deletedContainerName - Name of the previously deleted container.\n     * @param deletedContainerVersion - Version of the previously deleted container, used to uniquely identify the deleted container.\n     * @param options - Options to configure Container Restore operation.\n     * @returns Container deletion response.\n     */\n    async undeleteContainer(deletedContainerName, deletedContainerVersion, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobServiceClient-undeleteContainer\", options);\n        try {\n            const containerClient = this.getContainerClient(options.destinationContainerName || deletedContainerName);\n            // Hack to access a protected member.\n            const containerContext = new Container(containerClient[\"storageClientContext\"]);\n            const containerUndeleteResponse = await containerContext.restore(Object.assign({ deletedContainerName,\n                deletedContainerVersion }, updatedOptions));\n            return { containerClient, containerUndeleteResponse };\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Rename an existing Blob Container.\n     *\n     * @param sourceContainerName - The name of the source container.\n     * @param destinationContainerName - The new name of the container.\n     * @param options - Options to configure Container Rename operation.\n     */\n    /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n    // @ts-ignore Need to hide this interface for now. Make it public and turn on the live tests for it when the service is ready.\n    async renameContainer(sourceContainerName, destinationContainerName, options = {}) {\n        var _a;\n        const { span, updatedOptions } = createSpan(\"BlobServiceClient-renameContainer\", options);\n        try {\n            const containerClient = this.getContainerClient(destinationContainerName);\n            // Hack to access a protected member.\n            const containerContext = new Container(containerClient[\"storageClientContext\"]);\n            const containerRenameResponse = await containerContext.rename(sourceContainerName, Object.assign(Object.assign({}, updatedOptions), { sourceLeaseId: (_a = options.sourceCondition) === null || _a === void 0 ? void 0 : _a.leaseId }));\n            return { containerClient, containerRenameResponse };\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Gets the properties of a storage account’s Blob service, including properties\n     * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n     *\n     * @param options - Options to the Service Get Properties operation.\n     * @returns Response data for the Service Get Properties operation.\n     */\n    async getProperties(options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobServiceClient-getProperties\", options);\n        try {\n            return await this.serviceContext.getProperties(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets properties for a storage account’s Blob service endpoint, including properties\n     * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-service-properties\n     *\n     * @param properties -\n     * @param options - Options to the Service Set Properties operation.\n     * @returns Response data for the Service Set Properties operation.\n     */\n    async setProperties(properties, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobServiceClient-setProperties\", options);\n        try {\n            return await this.serviceContext.setProperties(properties, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Retrieves statistics related to replication for the Blob service. It is only\n     * available on the secondary location endpoint when read-access geo-redundant\n     * replication is enabled for the storage account.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-stats\n     *\n     * @param options - Options to the Service Get Statistics operation.\n     * @returns Response data for the Service Get Statistics operation.\n     */\n    async getStatistics(options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobServiceClient-getStatistics\", options);\n        try {\n            return await this.serviceContext.getStatistics(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * The Get Account Information operation returns the sku name and account kind\n     * for the specified account.\n     * The Get Account Information operation is available on service versions beginning\n     * with version 2018-03-28.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-account-information\n     *\n     * @param options - Options to the Service Get Account Info operation.\n     * @returns Response data for the Service Get Account Info operation.\n     */\n    async getAccountInfo(options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobServiceClient-getAccountInfo\", options);\n        try {\n            return await this.serviceContext.getAccountInfo(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns a list of the containers under the specified account.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-containers2\n     *\n     * @param marker - A string value that identifies the portion of\n     *                        the list of containers to be returned with the next listing operation. The\n     *                        operation returns the continuationToken value within the response body if the\n     *                        listing operation did not return all containers remaining to be listed\n     *                        with the current page. The continuationToken value can be used as the value for\n     *                        the marker parameter in a subsequent call to request the next page of list\n     *                        items. The marker value is opaque to the client.\n     * @param options - Options to the Service List Container Segment operation.\n     * @returns Response data for the Service List Container Segment operation.\n     */\n    async listContainersSegment(marker, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobServiceClient-listContainersSegment\", options);\n        try {\n            return await this.serviceContext.listContainersSegment(Object.assign(Object.assign(Object.assign({ abortSignal: options.abortSignal, marker }, options), { include: typeof options.include === \"string\" ? [options.include] : options.include }), convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * The Filter Blobs operation enables callers to list blobs across all containers whose tags\n     * match a given search expression. Filter blobs searches across all containers within a\n     * storage account but can be scoped within the expression to a single container.\n     *\n     * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.\n     *                                        The given expression must evaluate to true for a blob to be returned in the results.\n     *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n     *                                        however, only a subset of the OData filter syntax is supported in the Blob service.\n     * @param marker - A string value that identifies the portion of\n     *                          the list of blobs to be returned with the next listing operation. The\n     *                          operation returns the continuationToken value within the response body if the\n     *                          listing operation did not return all blobs remaining to be listed\n     *                          with the current page. The continuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of list\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to find blobs by tags.\n     */\n    async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobServiceClient-findBlobsByTagsSegment\", options);\n        try {\n            const response = await this.serviceContext.filterBlobs(Object.assign({ abortSignal: options.abortSignal, where: tagFilterSqlExpression, marker, maxPageSize: options.maxPageSize }, convertTracingToRequestOptionsBase(updatedOptions)));\n            const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, blobs: response.blobs.map((blob) => {\n                    var _a;\n                    let tagValue = \"\";\n                    if (((_a = blob.tags) === null || _a === void 0 ? void 0 : _a.blobTagSet.length) === 1) {\n                        tagValue = blob.tags.blobTagSet[0].value;\n                    }\n                    return Object.assign(Object.assign({}, blob), { tags: toTags(blob.tags), tagValue });\n                }) });\n            return wrappedResponse;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns an AsyncIterableIterator for ServiceFindBlobsByTagsSegmentResponse.\n     *\n     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n     *                                         The given expression must evaluate to true for a blob to be returned in the results.\n     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n     * @param marker - A string value that identifies the portion of\n     *                          the list of blobs to be returned with the next listing operation. The\n     *                          operation returns the continuationToken value within the response body if the\n     *                          listing operation did not return all blobs remaining to be listed\n     *                          with the current page. The continuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of list\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to find blobs by tags.\n     */\n    findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {\n        return __asyncGenerator(this, arguments, function* findBlobsByTagsSegments_1() {\n            let response;\n            if (!!marker || marker === undefined) {\n                do {\n                    response = yield __await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options));\n                    response.blobs = response.blobs || [];\n                    marker = response.continuationToken;\n                    yield yield __await(response);\n                } while (marker);\n            }\n        });\n    }\n    /**\n     * Returns an AsyncIterableIterator for blobs.\n     *\n     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n     *                                         The given expression must evaluate to true for a blob to be returned in the results.\n     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n     * @param options - Options to findBlobsByTagsItems.\n     */\n    findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {\n        return __asyncGenerator(this, arguments, function* findBlobsByTagsItems_1() {\n            var e_1, _a;\n            let marker;\n            try {\n                for (var _b = __asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n                    const segment = _c.value;\n                    yield __await(yield* __asyncDelegator(__asyncValues(segment.blobs)));\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        });\n    }\n    /**\n     * Returns an async iterable iterator to find all blobs with specified tag\n     * under the specified account.\n     *\n     * .byPage() returns an async iterable iterator to list the blobs in pages.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * let i = 1;\n     * for await (const blob of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\")) {\n     *   console.log(`Blob ${i++}: ${container.name}`);\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let i = 1;\n     * const iter = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\");\n     * let blobItem = await iter.next();\n     * while (!blobItem.done) {\n     *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n     *   blobItem = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * // passing optional maxPageSize in the page settings\n     * let i = 1;\n     * for await (const response of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 20 })) {\n     *   if (response.blobs) {\n     *     for (const blob of response.blobs) {\n     *       console.log(`Blob ${i++}: ${blob.name}`);\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a marker:\n     *\n     * ```js\n     * let i = 1;\n     * let iterator = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 2 });\n     * let response = (await iterator.next()).value;\n     *\n     * // Prints 2 blob names\n     * if (response.blobs) {\n     *   for (const blob of response.blobs) {\n     *     console.log(`Blob ${i++}: ${blob.name}`);\n     *   }\n     * }\n     *\n     * // Gets next marker\n     * let marker = response.continuationToken;\n     * // Passing next marker as continuationToken\n     * iterator = blobServiceClient\n     *   .findBlobsByTags(\"tagkey='tagvalue'\")\n     *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n     * response = (await iterator.next()).value;\n     *\n     * // Prints blob names\n     * if (response.blobs) {\n     *   for (const blob of response.blobs) {\n     *      console.log(`Blob ${i++}: ${blob.name}`);\n     *   }\n     * }\n     * ```\n     *\n     * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n     *                                         The given expression must evaluate to true for a blob to be returned in the results.\n     *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n     *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n     * @param options - Options to find blobs by tags.\n     */\n    findBlobsByTags(tagFilterSqlExpression, options = {}) {\n        // AsyncIterableIterator to iterate over blobs\n        const listSegmentOptions = Object.assign({}, options);\n        const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);\n        return {\n            /**\n             * The next method, part of the iteration protocol\n             */\n            next() {\n                return iter.next();\n            },\n            /**\n             * The connection to the async iterator, part of the iteration protocol\n             */\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n            /**\n             * Return an AsyncIterableIterator that works a page at a time\n             */\n            byPage: (settings = {}) => {\n                return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, listSegmentOptions));\n            }\n        };\n    }\n    /**\n     * Returns an AsyncIterableIterator for ServiceListContainersSegmentResponses\n     *\n     * @param marker - A string value that identifies the portion of\n     *                        the list of containers to be returned with the next listing operation. The\n     *                        operation returns the continuationToken value within the response body if the\n     *                        listing operation did not return all containers remaining to be listed\n     *                        with the current page. The continuationToken value can be used as the value for\n     *                        the marker parameter in a subsequent call to request the next page of list\n     *                        items. The marker value is opaque to the client.\n     * @param options - Options to list containers operation.\n     */\n    listSegments(marker, options = {}) {\n        return __asyncGenerator(this, arguments, function* listSegments_1() {\n            let listContainersSegmentResponse;\n            if (!!marker || marker === undefined) {\n                do {\n                    listContainersSegmentResponse = yield __await(this.listContainersSegment(marker, options));\n                    listContainersSegmentResponse.containerItems =\n                        listContainersSegmentResponse.containerItems || [];\n                    marker = listContainersSegmentResponse.continuationToken;\n                    yield yield __await(yield __await(listContainersSegmentResponse));\n                } while (marker);\n            }\n        });\n    }\n    /**\n     * Returns an AsyncIterableIterator for Container Items\n     *\n     * @param options - Options to list containers operation.\n     */\n    listItems(options = {}) {\n        return __asyncGenerator(this, arguments, function* listItems_1() {\n            var e_2, _a;\n            let marker;\n            try {\n                for (var _b = __asyncValues(this.listSegments(marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n                    const segment = _c.value;\n                    yield __await(yield* __asyncDelegator(__asyncValues(segment.containerItems)));\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        });\n    }\n    /**\n     * Returns an async iterable iterator to list all the containers\n     * under the specified account.\n     *\n     * .byPage() returns an async iterable iterator to list the containers in pages.\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * let i = 1;\n     * for await (const container of blobServiceClient.listContainers()) {\n     *   console.log(`Container ${i++}: ${container.name}`);\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let i = 1;\n     * const iter = blobServiceClient.listContainers();\n     * let containerItem = await iter.next();\n     * while (!containerItem.done) {\n     *   console.log(`Container ${i++}: ${containerItem.value.name}`);\n     *   containerItem = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * // passing optional maxPageSize in the page settings\n     * let i = 1;\n     * for await (const response of blobServiceClient.listContainers().byPage({ maxPageSize: 20 })) {\n     *   if (response.containerItems) {\n     *     for (const container of response.containerItems) {\n     *       console.log(`Container ${i++}: ${container.name}`);\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a marker:\n     *\n     * ```js\n     * let i = 1;\n     * let iterator = blobServiceClient.listContainers().byPage({ maxPageSize: 2 });\n     * let response = (await iterator.next()).value;\n     *\n     * // Prints 2 container names\n     * if (response.containerItems) {\n     *   for (const container of response.containerItems) {\n     *     console.log(`Container ${i++}: ${container.name}`);\n     *   }\n     * }\n     *\n     * // Gets next marker\n     * let marker = response.continuationToken;\n     * // Passing next marker as continuationToken\n     * iterator = blobServiceClient\n     *   .listContainers()\n     *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n     * response = (await iterator.next()).value;\n     *\n     * // Prints 10 container names\n     * if (response.containerItems) {\n     *   for (const container of response.containerItems) {\n     *      console.log(`Container ${i++}: ${container.name}`);\n     *   }\n     * }\n     * ```\n     *\n     * @param options - Options to list containers.\n     * @returns An asyncIterableIterator that supports paging.\n     */\n    listContainers(options = {}) {\n        if (options.prefix === \"\") {\n            options.prefix = undefined;\n        }\n        const include = [];\n        if (options.includeDeleted) {\n            include.push(\"deleted\");\n        }\n        if (options.includeMetadata) {\n            include.push(\"metadata\");\n        }\n        // AsyncIterableIterator to iterate over containers\n        const listSegmentOptions = Object.assign(Object.assign({}, options), (include.length > 0 ? { include } : {}));\n        const iter = this.listItems(listSegmentOptions);\n        return {\n            /**\n             * The next method, part of the iteration protocol\n             */\n            next() {\n                return iter.next();\n            },\n            /**\n             * The connection to the async iterator, part of the iteration protocol\n             */\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n            /**\n             * Return an AsyncIterableIterator that works a page at a time\n             */\n            byPage: (settings = {}) => {\n                return this.listSegments(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, listSegmentOptions));\n            }\n        };\n    }\n    /**\n     * ONLY AVAILABLE WHEN USING BEARER TOKEN AUTHENTICATION (TokenCredential).\n     *\n     * Retrieves a user delegation key for the Blob service. This is only a valid operation when using\n     * bearer token authentication.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-user-delegation-key\n     *\n     * @param startsOn -      The start time for the user delegation SAS. Must be within 7 days of the current time\n     * @param expiresOn -     The end time for the user delegation SAS. Must be within 7 days of the current time\n     */\n    async getUserDelegationKey(startsOn, expiresOn, options = {}) {\n        const { span, updatedOptions } = createSpan(\"BlobServiceClient-getUserDelegationKey\", options);\n        try {\n            const response = await this.serviceContext.getUserDelegationKey({\n                startsOn: truncatedISO8061Date(startsOn, false),\n                expiresOn: truncatedISO8061Date(expiresOn, false)\n            }, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));\n            const userDelegationKey = {\n                signedObjectId: response.signedObjectId,\n                signedTenantId: response.signedTenantId,\n                signedStartsOn: new Date(response.signedStartsOn),\n                signedExpiresOn: new Date(response.signedExpiresOn),\n                signedService: response.signedService,\n                signedVersion: response.signedVersion,\n                value: response.value\n            };\n            const res = Object.assign({ _response: response._response, requestId: response.requestId, clientRequestId: response.clientRequestId, version: response.version, date: response.date, errorCode: response.errorCode }, userDelegationKey);\n            return res;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Creates a BlobBatchClient object to conduct batch operations.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch\n     *\n     * @returns A new BlobBatchClient object for this service.\n     */\n    getBlobBatchClient() {\n        return new BlobBatchClient(this.url, this.pipeline);\n    }\n    /**\n     * Only available for BlobServiceClient constructed with a shared key credential.\n     *\n     * Generates a Blob account Shared Access Signature (SAS) URI based on the client properties\n     * and parameters passed in. The SAS is signed by the shared key credential of the client.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-account-sas\n     *\n     * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.\n     * @param permissions - Specifies the list of permissions to be associated with the SAS.\n     * @param resourceTypes - Specifies the resource types associated with the shared access signature.\n     * @param options - Optional parameters.\n     * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n     */\n    generateAccountSasUrl(expiresOn, permissions = AccountSASPermissions.parse(\"r\"), resourceTypes = \"sco\", options = {}) {\n        if (!(this.credential instanceof StorageSharedKeyCredential)) {\n            throw RangeError(\"Can only generate the account SAS when the client is initialized with a shared key credential\");\n        }\n        if (expiresOn === undefined) {\n            const now = new Date();\n            expiresOn = new Date(now.getTime() + 3600 * 1000);\n        }\n        const sas = generateAccountSASQueryParameters(Object.assign({ permissions,\n            expiresOn,\n            resourceTypes, services: AccountSASServices.parse(\"b\").toString() }, options), this.credential).toString();\n        return appendToURLQuery(this.url, sas);\n    }\n}\n//# sourceMappingURL=BlobServiceClient.js.map"]},"metadata":{},"sourceType":"module"}