{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { ContainerClient } from \"@azure/storage-blob\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { DataLakeLeaseClient } from \"./DataLakeLeaseClient\";\nimport { FileSystem } from \"./generated/src/operations\";\nimport { newPipeline, Pipeline } from \"./Pipeline\";\nimport { StorageClient } from \"./StorageClient\";\nimport { toContainerPublicAccessType, toPublicAccessType, toPermissions } from \"./transforms\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport { appendToURLPath, appendToURLQuery } from \"./utils/utils.common\";\nimport { DataLakeFileClient, DataLakeDirectoryClient } from \"./clients\";\nimport { generateDataLakeSASQueryParameters } from \"./sas/DataLakeSASSignatureValues\";\nimport { DeletionIdKey, PathResultTypeConstants } from \"./utils/constants\";\nimport { PathClientInternal } from \"./utils/PathClientInternal\";\n/**\n * A DataLakeFileSystemClient represents a URL to the Azure Storage file system\n * allowing you to manipulate its directories and files.\n */\n\nexport class DataLakeFileSystemClient extends StorageClient {\n  constructor(url, credentialOrPipeline, // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n  options) {\n    if (credentialOrPipeline instanceof Pipeline) {\n      super(url, credentialOrPipeline);\n    } else {\n      let credential;\n\n      if (credentialOrPipeline === undefined) {\n        credential = new AnonymousCredential();\n      } else {\n        credential = credentialOrPipeline;\n      }\n\n      const pipeline = newPipeline(credential, options);\n      super(url, pipeline);\n    }\n\n    this.fileSystemContext = new FileSystem(this.storageClientContext);\n    this.fileSystemContextToBlobEndpoint = new FileSystem(this.storageClientContextToBlobEndpoint);\n    this.blobContainerClient = new ContainerClient(this.blobEndpointUrl, this.pipeline);\n  }\n  /**\n   * Name of current file system.\n   *\n   * @readonly\n   */\n\n\n  get name() {\n    return this.blobContainerClient.containerName;\n  }\n  /**\n   * Creates a {@link DataLakeDirectoryClient} object under current file system.\n   *\n   * @param directoryName -\n   */\n  // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */\n\n\n  getDirectoryClient(directoryName) {\n    return new DataLakeDirectoryClient(appendToURLPath(this.url, encodeURIComponent(directoryName)), this.pipeline);\n  }\n  /**\n   * Creates a {@link DataLakeFileClient} object under current file system.\n   *\n   * @param fileName -\n   */\n  // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */\n\n\n  getFileClient(fileName) {\n    return new DataLakeFileClient(appendToURLPath(this.url, encodeURIComponent(fileName)), this.pipeline);\n  }\n  /**\n   * Get a {@link DataLakeLeaseClient} that manages leases on the file system.\n   *\n   * @param proposeLeaseId - Optional. Initial proposed lease Id.\n   */\n\n\n  getDataLakeLeaseClient(proposeLeaseId) {\n    return new DataLakeLeaseClient(this.blobContainerClient.getBlobLeaseClient(proposeLeaseId));\n  }\n  /**\n   * Creates a new file system under the specified account. If the file system with\n   * the same name already exists, the operation fails.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n   *\n   * @param options - Optional. Options when creating file system.\n   */\n\n\n  create(options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"DataLakeFileSystemClient-create\", options);\n\n      try {\n        return yield _this.blobContainerClient.create(Object.assign(Object.assign({}, options), {\n          access: toContainerPublicAccessType(options.access),\n          tracingOptions: updatedOptions.tracingOptions\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a new file system under the specified account. If the file system with\n   * the same name already exists, it is not changed.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n   *\n   * @param options -\n   */\n\n\n  createIfNotExists(options = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"DataLakeFileSystemClient-createIfNotExists\", options);\n\n      try {\n        return yield _this2.blobContainerClient.createIfNotExists(Object.assign(Object.assign({}, options), {\n          access: toContainerPublicAccessType(options.access),\n          tracingOptions: updatedOptions.tracingOptions\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns true if the File system represented by this client exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing file system might be deleted by other clients or\n   * applications. Vice versa new file system with the same name might be added by other clients or\n   * applications after this function completes.\n   *\n   * @param options -\n   */\n\n\n  exists(options = {}) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"DataLakeFileSystemClient-exists\", options);\n\n      try {\n        return yield _this3.blobContainerClient.exists(updatedOptions);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Delete current file system.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n   *\n   * @param options - Optional. Options when deleting file system.\n   */\n\n\n  delete(options = {}) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"DataLakeFileSystemClient-delete\", options);\n\n      try {\n        return yield _this4.blobContainerClient.delete(Object.assign(Object.assign({}, options), {\n          tracingOptions: updatedOptions.tracingOptions\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Delete current file system if it exists.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n   *\n   * @param options -\n   */\n\n\n  deleteIfExists(options = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"DataLakeFileSystemClient-deleteIfExists\", options);\n\n      try {\n        return yield _this5.blobContainerClient.deleteIfExists(updatedOptions);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns all user-defined metadata and system properties for the specified\n   * file system.\n   *\n   * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n   * they originally contained uppercase characters. This differs from the metadata keys returned by\n   * the `listFileSystems` method of {@link DataLakeServiceClient} using the `includeMetadata` option, which\n   * will retain their original casing.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-properties\n   *\n   * @param options - Optional. Options when getting file system properties.\n   */\n\n\n  getProperties(options = {}) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"DataLakeFileSystemClient-getProperties\", options);\n\n      try {\n        const rawResponse = yield _this6.blobContainerClient.getProperties(Object.assign(Object.assign({}, options), {\n          tracingOptions: updatedOptions.tracingOptions\n        })); // Transfer and rename blobPublicAccess to publicAccess\n\n        const response = rawResponse;\n        response.publicAccess = toPublicAccessType(rawResponse.blobPublicAccess);\n        response._response.parsedHeaders.publicAccess = response.publicAccess;\n        delete rawResponse.blobPublicAccess;\n        delete rawResponse._response.parsedHeaders.blobPublicAccess;\n        return response;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets one or more user-defined name-value pairs for the specified file system.\n   *\n   * If no option provided, or no metadata defined in the parameter, the file system\n   * metadata will be removed.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-metadata\n   *\n   * @param metadata - Replace existing metadata with this value.\n   *                              If no value provided the existing metadata will be removed.\n   * @param options - Optional. Options when setting file system metadata.\n   */\n\n\n  setMetadata(metadata, options = {}) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"DataLakeFileSystemClient-setMetadata\", options);\n\n      try {\n        return yield _this7.blobContainerClient.setMetadata(metadata, Object.assign(Object.assign({}, options), {\n          tracingOptions: updatedOptions.tracingOptions\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Gets the permissions for the specified file system. The permissions indicate\n   * whether file system data may be accessed publicly.\n   *\n   * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.\n   * For example, new Date(\"2018-12-31T03:44:23.8827891Z\").toISOString() will get \"2018-12-31T03:44:23.882Z\".\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-acl\n   *\n   * @param options - Optional. Options when getting file system access policy.\n   */\n\n\n  getAccessPolicy(options = {}) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"DataLakeFileSystemClient-getAccessPolicy\", options);\n\n      try {\n        const rawResponse = yield _this8.blobContainerClient.getAccessPolicy(Object.assign(Object.assign({}, options), {\n          tracingOptions: updatedOptions.tracingOptions\n        })); // Transfer and rename blobPublicAccess to publicAccess\n\n        const response = rawResponse;\n        response.publicAccess = toPublicAccessType(rawResponse.blobPublicAccess);\n        response._response.parsedHeaders.publicAccess = response.publicAccess;\n        delete rawResponse.blobPublicAccess;\n        delete rawResponse._response.parsedHeaders.blobPublicAccess;\n        return response;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets the permissions for the specified file system. The permissions indicate\n   * whether directories or files in a file system may be accessed publicly.\n   *\n   * When you set permissions for a file system, the existing permissions are replaced.\n   * If no access or containerAcl provided, the existing file system ACL will be\n   * removed.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-acl\n   *\n   * @param access - Optional. The level of public access to data in the file system.\n   * @param fileSystemAcl - Optional. Array of elements each having a unique Id and details of the access policy.\n   * @param options - Optional. Options when setting file system access policy.\n   */\n\n\n  setAccessPolicy(access, fileSystemAcl, options = {}) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"DataLakeFileSystemClient-setAccessPolicy\", options);\n\n      try {\n        return yield _this9.blobContainerClient.setAccessPolicy(toContainerPublicAccessType(access), fileSystemAcl, Object.assign(Object.assign({}, options), {\n          tracingOptions: updatedOptions.tracingOptions\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns an async iterable iterator to list all the paths (directories and files)\n   * under the specified file system.\n   *\n   * .byPage() returns an async iterable iterator to list the paths in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * // Get the fileSystemClient before you run these snippets,\n   * // Can be obtained from `serviceClient.getFileSystemClient(\"<your-filesystem-name>\");`\n   * let i = 1;\n   * for await (const path of fileSystemClient.listPaths()) {\n   *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = fileSystemClient.listPaths();\n   * let pathItem = await iter.next();\n   * while (!pathItem.done) {\n   *   console.log(`Path ${i++}: ${pathItem.value.name}, isDirectory?: ${pathItem.value.isDirectory}`);\n   *   pathItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of fileSystemClient.listPaths().byPage({ maxPageSize: 20 })) {\n   *   for (const path of response.pathItems) {\n   *     console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = fileSystemClient.listPaths().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 path names\n   * for (const path of response.pathItems) {\n   *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   *\n   * // Passing next marker as continuationToken\n   *\n   * iterator = fileSystemClient.listPaths().byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 path names\n   * for (const path of response.pathItems) {\n   *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);\n   * }\n   * ```\n   *\n   * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n   *\n   * @param options - Optional. Options when listing paths.\n   */\n\n\n  listPaths(options = {}) {\n    options.path = options.path === \"\" ? undefined : options.path;\n    const iter = this.listItems(options);\n    return {\n      next() {\n        return iter.next();\n      },\n\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      byPage: (settings = {}) => {\n        return this.listSegments(settings.continuationToken, Object.assign({\n          maxResults: settings.maxPageSize\n        }, options));\n      }\n    };\n  }\n\n  listItems(options = {}) {\n    return __asyncGenerator(this, arguments, function* listItems_1() {\n      var e_1, _a;\n\n      try {\n        for (var _b = __asyncValues(this.listSegments(undefined, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n          const response = _c.value;\n          yield __await(yield* __asyncDelegator(__asyncValues(response.pathItems || [])));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n\n  listSegments(continuation, options = {}) {\n    return __asyncGenerator(this, arguments, function* listSegments_1() {\n      let response;\n\n      if (!!continuation || continuation === undefined) {\n        do {\n          response = yield __await(this.listPathsSegment(continuation, options));\n          continuation = response.continuation;\n          yield yield __await(response);\n        } while (continuation);\n      }\n    });\n  }\n\n  listPathsSegment(continuation, options = {}) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"DataLakeFileSystemClient-listPathsSegment\", options);\n\n      try {\n        const rawResponse = yield _this10.fileSystemContext.listPaths(options.recursive || false, Object.assign(Object.assign(Object.assign({\n          continuation\n        }, options), {\n          upn: options.userPrincipalName\n        }), convertTracingToRequestOptionsBase(updatedOptions)));\n        const response = rawResponse;\n        response.pathItems = [];\n\n        for (const path of rawResponse.paths || []) {\n          response.pathItems.push(Object.assign(Object.assign({}, path), {\n            permissions: toPermissions(path.permissions)\n          }));\n        }\n\n        delete rawResponse.paths;\n        return response;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns an async iterable iterator to list all the paths (directories and files)\n   * under the specified file system.\n   *\n   * .byPage() returns an async iterable iterator to list the paths in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * // Get the fileSystemClient before you run these snippets,\n   * // Can be obtained from `serviceClient.getFileSystemClient(\"<your-filesystem-name>\");`\n   * let i = 1;\n   * for await (const deletePath of fileSystemClient.listDeletedPaths()) {\n   *   console.log(`Path ${i++}: ${deletePath.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = fileSystemClient.listDeletedPaths();\n   * let deletedPathItem = await iter.next();\n   * while (!deletedPathItem.done) {\n   *   console.log(`Path ${i++}: ${deletedPathItem.value.name}`);\n   *   pathItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of fileSystemClient.listDeletedPaths().byPage({ maxPageSize: 20 })) {\n   *   for (const deletePath of response.pathItems) {\n   *     console.log(`Path ${i++}: ${deletePath.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = fileSystemClient.listDeletedPaths().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 path names\n   * for (const path of response.pathItems) {\n   *   console.log(`Path ${i++}: ${path.name}}`);\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   *\n   * // Passing next marker as continuationToken\n   *\n   * iterator = fileSystemClient.listDeletedPaths().byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 path names\n   * for (const deletePath of response.deletedPathItems) {\n   *   console.log(`Path ${i++}: ${deletePath.name}`);\n   * }\n   * ```\n   *\n   * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n   *\n   * @param options - Optional. Options when listing deleted paths.\n   */\n\n\n  listDeletedPaths(options = {}) {\n    const iter = this.listDeletedItems(options);\n    return {\n      next() {\n        return iter.next();\n      },\n\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      byPage: (settings = {}) => {\n        return this.listDeletedSegments(settings.continuationToken, Object.assign({\n          maxResults: settings.maxPageSize\n        }, options));\n      }\n    };\n  }\n\n  listDeletedItems(options = {}) {\n    return __asyncGenerator(this, arguments, function* listDeletedItems_1() {\n      var e_2, _a;\n\n      try {\n        for (var _b = __asyncValues(this.listDeletedSegments(undefined, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n          const response = _c.value;\n          yield __await(yield* __asyncDelegator(__asyncValues(response.pathItems || [])));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n\n  listDeletedSegments(continuation, options = {}) {\n    return __asyncGenerator(this, arguments, function* listDeletedSegments_1() {\n      let response;\n\n      if (!!continuation || continuation === undefined) {\n        do {\n          response = yield __await(this.listDeletedPathsSegment(continuation, options));\n          continuation = response.continuation;\n          yield yield __await(response);\n        } while (continuation);\n      }\n    });\n  }\n\n  listDeletedPathsSegment(continuation, options = {}) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"DataLakeFileSystemClient-listDeletedPathsSegment\", options);\n\n      try {\n        const rawResponse = yield _this11.fileSystemContextToBlobEndpoint.listBlobHierarchySegment(Object.assign(Object.assign(Object.assign({\n          marker: continuation\n        }, options), {\n          prefix: options.prefix === \"\" ? undefined : options.prefix\n        }), convertTracingToRequestOptionsBase(updatedOptions)));\n        const response = rawResponse;\n        response.pathItems = [];\n\n        for (const path of rawResponse.segment.blobItems || []) {\n          response.pathItems.push({\n            name: path.name,\n            deletionId: path.deletionId,\n            deletedOn: path.properties.deletedTime,\n            remainingRetentionDays: path.properties.remainingRetentionDays\n          });\n        }\n\n        if (!(response.nextMarker === undefined || response.nextMarker === \"\")) {\n          response.continuation = response.nextMarker;\n        }\n\n        return response;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Restores a soft deleted path.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/undelete-blob\n   *\n   * @param deletedPath - Required.  The path of the deleted path.\n   *\n   * @param deletionId - Required.  The deletion ID associated with the soft deleted path.\n   *\n   */\n\n\n  undeletePath(deletedPath, deletionId, options = {}) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"DataLakeFileSystemClient-undeletePath\", options);\n\n      try {\n        const pathClient = new PathClientInternal(appendToURLPath(_this12.blobEndpointUrl, encodeURIComponent(deletedPath)), _this12.pipeline);\n        const rawResponse = yield pathClient.blobPathContext.undelete(Object.assign(Object.assign({\n          undeleteSource: \"?\" + DeletionIdKey + \"=\" + deletionId\n        }, options), {\n          tracingOptions: updatedOptions.tracingOptions\n        }));\n\n        if (rawResponse.resourceType === PathResultTypeConstants.DirectoryResourceType) {\n          return Object.assign({\n            pathClient: _this12.getDirectoryClient(deletedPath)\n          }, rawResponse);\n        } else {\n          return Object.assign({\n            pathClient: _this12.getFileClient(deletedPath)\n          }, rawResponse);\n        }\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Only available for DataLakeFileSystemClient constructed with a shared key credential.\n   *\n   * Generates a Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n\n\n  generateSasUrl(options) {\n    return new Promise(resolve => {\n      if (!(this.credential instanceof StorageSharedKeyCredential)) {\n        throw RangeError(\"Can only generate the SAS when the client is initialized with a shared key credential\");\n      }\n\n      const sas = generateDataLakeSASQueryParameters(Object.assign({\n        fileSystemName: this.name\n      }, options), this.credential).toString();\n      resolve(appendToURLQuery(this.url, sas));\n    });\n  }\n\n} //# sourceMappingURL=DataLakeFileSystemClient.js.map","map":{"version":3,"sources":["F:/statvalu/AR_DocuExpert_Test/node_modules/@azure/storage-file-datalake/dist-esm/storage-file-datalake/src/DataLakeFileSystemClient.js"],"names":["__asyncDelegator","__asyncGenerator","__asyncValues","__await","ContainerClient","SpanStatusCode","AnonymousCredential","StorageSharedKeyCredential","DataLakeLeaseClient","FileSystem","newPipeline","Pipeline","StorageClient","toContainerPublicAccessType","toPublicAccessType","toPermissions","convertTracingToRequestOptionsBase","createSpan","appendToURLPath","appendToURLQuery","DataLakeFileClient","DataLakeDirectoryClient","generateDataLakeSASQueryParameters","DeletionIdKey","PathResultTypeConstants","PathClientInternal","DataLakeFileSystemClient","constructor","url","credentialOrPipeline","options","credential","undefined","pipeline","fileSystemContext","storageClientContext","fileSystemContextToBlobEndpoint","storageClientContextToBlobEndpoint","blobContainerClient","blobEndpointUrl","name","containerName","getDirectoryClient","directoryName","encodeURIComponent","getFileClient","fileName","getDataLakeLeaseClient","proposeLeaseId","getBlobLeaseClient","create","span","updatedOptions","Object","assign","access","tracingOptions","e","setStatus","code","ERROR","message","end","createIfNotExists","exists","delete","deleteIfExists","getProperties","rawResponse","response","publicAccess","blobPublicAccess","_response","parsedHeaders","setMetadata","metadata","getAccessPolicy","setAccessPolicy","fileSystemAcl","listPaths","path","iter","listItems","next","Symbol","asyncIterator","byPage","settings","listSegments","continuationToken","maxResults","maxPageSize","arguments","listItems_1","e_1","_a","_b","_c","done","value","pathItems","e_1_1","error","return","call","continuation","listSegments_1","listPathsSegment","recursive","upn","userPrincipalName","paths","push","permissions","listDeletedPaths","listDeletedItems","listDeletedSegments","listDeletedItems_1","e_2","e_2_1","listDeletedSegments_1","listDeletedPathsSegment","listBlobHierarchySegment","marker","prefix","segment","blobItems","deletionId","deletedOn","properties","deletedTime","remainingRetentionDays","nextMarker","undeletePath","deletedPath","pathClient","blobPathContext","undelete","undeleteSource","resourceType","DirectoryResourceType","generateSasUrl","Promise","resolve","RangeError","sas","fileSystemName","toString"],"mappings":"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","sourcesContent":["import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { ContainerClient } from \"@azure/storage-blob\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { DataLakeLeaseClient } from \"./DataLakeLeaseClient\";\nimport { FileSystem } from \"./generated/src/operations\";\nimport { newPipeline, Pipeline } from \"./Pipeline\";\nimport { StorageClient } from \"./StorageClient\";\nimport { toContainerPublicAccessType, toPublicAccessType, toPermissions } from \"./transforms\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport { appendToURLPath, appendToURLQuery } from \"./utils/utils.common\";\nimport { DataLakeFileClient, DataLakeDirectoryClient } from \"./clients\";\nimport { generateDataLakeSASQueryParameters } from \"./sas/DataLakeSASSignatureValues\";\nimport { DeletionIdKey, PathResultTypeConstants } from \"./utils/constants\";\nimport { PathClientInternal } from \"./utils/PathClientInternal\";\n/**\n * A DataLakeFileSystemClient represents a URL to the Azure Storage file system\n * allowing you to manipulate its directories and files.\n */\nexport class DataLakeFileSystemClient extends StorageClient {\n    constructor(url, credentialOrPipeline, \n    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options) {\n        if (credentialOrPipeline instanceof Pipeline) {\n            super(url, credentialOrPipeline);\n        }\n        else {\n            let credential;\n            if (credentialOrPipeline === undefined) {\n                credential = new AnonymousCredential();\n            }\n            else {\n                credential = credentialOrPipeline;\n            }\n            const pipeline = newPipeline(credential, options);\n            super(url, pipeline);\n        }\n        this.fileSystemContext = new FileSystem(this.storageClientContext);\n        this.fileSystemContextToBlobEndpoint = new FileSystem(this.storageClientContextToBlobEndpoint);\n        this.blobContainerClient = new ContainerClient(this.blobEndpointUrl, this.pipeline);\n    }\n    /**\n     * Name of current file system.\n     *\n     * @readonly\n     */\n    get name() {\n        return this.blobContainerClient.containerName;\n    }\n    /**\n     * Creates a {@link DataLakeDirectoryClient} object under current file system.\n     *\n     * @param directoryName -\n     */\n    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */\n    getDirectoryClient(directoryName) {\n        return new DataLakeDirectoryClient(appendToURLPath(this.url, encodeURIComponent(directoryName)), this.pipeline);\n    }\n    /**\n     * Creates a {@link DataLakeFileClient} object under current file system.\n     *\n     * @param fileName -\n     */\n    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */\n    getFileClient(fileName) {\n        return new DataLakeFileClient(appendToURLPath(this.url, encodeURIComponent(fileName)), this.pipeline);\n    }\n    /**\n     * Get a {@link DataLakeLeaseClient} that manages leases on the file system.\n     *\n     * @param proposeLeaseId - Optional. Initial proposed lease Id.\n     */\n    getDataLakeLeaseClient(proposeLeaseId) {\n        return new DataLakeLeaseClient(this.blobContainerClient.getBlobLeaseClient(proposeLeaseId));\n    }\n    /**\n     * Creates a new file system under the specified account. If the file system with\n     * the same name already exists, the operation fails.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n     *\n     * @param options - Optional. Options when creating file system.\n     */\n    async create(options = {}) {\n        const { span, updatedOptions } = createSpan(\"DataLakeFileSystemClient-create\", options);\n        try {\n            return await this.blobContainerClient.create(Object.assign(Object.assign({}, options), { access: toContainerPublicAccessType(options.access), tracingOptions: updatedOptions.tracingOptions }));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Creates a new file system under the specified account. If the file system with\n     * the same name already exists, it is not changed.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n     *\n     * @param options -\n     */\n    async createIfNotExists(options = {}) {\n        const { span, updatedOptions } = createSpan(\"DataLakeFileSystemClient-createIfNotExists\", options);\n        try {\n            return await this.blobContainerClient.createIfNotExists(Object.assign(Object.assign({}, options), { access: toContainerPublicAccessType(options.access), tracingOptions: updatedOptions.tracingOptions }));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns true if the File system represented by this client exists; false otherwise.\n     *\n     * NOTE: use this function with care since an existing file system might be deleted by other clients or\n     * applications. Vice versa new file system with the same name might be added by other clients or\n     * applications after this function completes.\n     *\n     * @param options -\n     */\n    async exists(options = {}) {\n        const { span, updatedOptions } = createSpan(\"DataLakeFileSystemClient-exists\", options);\n        try {\n            return await this.blobContainerClient.exists(updatedOptions);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Delete current file system.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n     *\n     * @param options - Optional. Options when deleting file system.\n     */\n    async delete(options = {}) {\n        const { span, updatedOptions } = createSpan(\"DataLakeFileSystemClient-delete\", options);\n        try {\n            return await this.blobContainerClient.delete(Object.assign(Object.assign({}, options), { tracingOptions: updatedOptions.tracingOptions }));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Delete current file system if it exists.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n     *\n     * @param options -\n     */\n    async deleteIfExists(options = {}) {\n        const { span, updatedOptions } = createSpan(\"DataLakeFileSystemClient-deleteIfExists\", options);\n        try {\n            return await this.blobContainerClient.deleteIfExists(updatedOptions);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns all user-defined metadata and system properties for the specified\n     * file system.\n     *\n     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n     * they originally contained uppercase characters. This differs from the metadata keys returned by\n     * the `listFileSystems` method of {@link DataLakeServiceClient} using the `includeMetadata` option, which\n     * will retain their original casing.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-properties\n     *\n     * @param options - Optional. Options when getting file system properties.\n     */\n    async getProperties(options = {}) {\n        const { span, updatedOptions } = createSpan(\"DataLakeFileSystemClient-getProperties\", options);\n        try {\n            const rawResponse = await this.blobContainerClient.getProperties(Object.assign(Object.assign({}, options), { tracingOptions: updatedOptions.tracingOptions }));\n            // Transfer and rename blobPublicAccess to publicAccess\n            const response = rawResponse;\n            response.publicAccess = toPublicAccessType(rawResponse.blobPublicAccess);\n            response._response.parsedHeaders.publicAccess = response.publicAccess;\n            delete rawResponse.blobPublicAccess;\n            delete rawResponse._response.parsedHeaders.blobPublicAccess;\n            return response;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets one or more user-defined name-value pairs for the specified file system.\n     *\n     * If no option provided, or no metadata defined in the parameter, the file system\n     * metadata will be removed.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-metadata\n     *\n     * @param metadata - Replace existing metadata with this value.\n     *                              If no value provided the existing metadata will be removed.\n     * @param options - Optional. Options when setting file system metadata.\n     */\n    async setMetadata(metadata, options = {}) {\n        const { span, updatedOptions } = createSpan(\"DataLakeFileSystemClient-setMetadata\", options);\n        try {\n            return await this.blobContainerClient.setMetadata(metadata, Object.assign(Object.assign({}, options), { tracingOptions: updatedOptions.tracingOptions }));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Gets the permissions for the specified file system. The permissions indicate\n     * whether file system data may be accessed publicly.\n     *\n     * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.\n     * For example, new Date(\"2018-12-31T03:44:23.8827891Z\").toISOString() will get \"2018-12-31T03:44:23.882Z\".\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-acl\n     *\n     * @param options - Optional. Options when getting file system access policy.\n     */\n    async getAccessPolicy(options = {}) {\n        const { span, updatedOptions } = createSpan(\"DataLakeFileSystemClient-getAccessPolicy\", options);\n        try {\n            const rawResponse = await this.blobContainerClient.getAccessPolicy(Object.assign(Object.assign({}, options), { tracingOptions: updatedOptions.tracingOptions }));\n            // Transfer and rename blobPublicAccess to publicAccess\n            const response = rawResponse;\n            response.publicAccess = toPublicAccessType(rawResponse.blobPublicAccess);\n            response._response.parsedHeaders.publicAccess = response.publicAccess;\n            delete rawResponse.blobPublicAccess;\n            delete rawResponse._response.parsedHeaders.blobPublicAccess;\n            return response;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets the permissions for the specified file system. The permissions indicate\n     * whether directories or files in a file system may be accessed publicly.\n     *\n     * When you set permissions for a file system, the existing permissions are replaced.\n     * If no access or containerAcl provided, the existing file system ACL will be\n     * removed.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-acl\n     *\n     * @param access - Optional. The level of public access to data in the file system.\n     * @param fileSystemAcl - Optional. Array of elements each having a unique Id and details of the access policy.\n     * @param options - Optional. Options when setting file system access policy.\n     */\n    async setAccessPolicy(access, fileSystemAcl, options = {}) {\n        const { span, updatedOptions } = createSpan(\"DataLakeFileSystemClient-setAccessPolicy\", options);\n        try {\n            return await this.blobContainerClient.setAccessPolicy(toContainerPublicAccessType(access), fileSystemAcl, Object.assign(Object.assign({}, options), { tracingOptions: updatedOptions.tracingOptions }));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns an async iterable iterator to list all the paths (directories and files)\n     * under the specified file system.\n     *\n     * .byPage() returns an async iterable iterator to list the paths in pages.\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * // Get the fileSystemClient before you run these snippets,\n     * // Can be obtained from `serviceClient.getFileSystemClient(\"<your-filesystem-name>\");`\n     * let i = 1;\n     * for await (const path of fileSystemClient.listPaths()) {\n     *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let i = 1;\n     * let iter = fileSystemClient.listPaths();\n     * let pathItem = await iter.next();\n     * while (!pathItem.done) {\n     *   console.log(`Path ${i++}: ${pathItem.value.name}, isDirectory?: ${pathItem.value.isDirectory}`);\n     *   pathItem = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * // passing optional maxPageSize in the page settings\n     * let i = 1;\n     * for await (const response of fileSystemClient.listPaths().byPage({ maxPageSize: 20 })) {\n     *   for (const path of response.pathItems) {\n     *     console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a marker:\n     *\n     * ```js\n     * let i = 1;\n     * let iterator = fileSystemClient.listPaths().byPage({ maxPageSize: 2 });\n     * let response = (await iterator.next()).value;\n     *\n     * // Prints 2 path names\n     * for (const path of response.pathItems) {\n     *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);\n     * }\n     *\n     * // Gets next marker\n     * let marker = response.continuationToken;\n     *\n     * // Passing next marker as continuationToken\n     *\n     * iterator = fileSystemClient.listPaths().byPage({ continuationToken: marker, maxPageSize: 10 });\n     * response = (await iterator.next()).value;\n     *\n     * // Prints 10 path names\n     * for (const path of response.pathItems) {\n     *   console.log(`Path ${i++}: ${path.name}, isDirectory?: ${path.isDirectory}`);\n     * }\n     * ```\n     *\n     * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n     *\n     * @param options - Optional. Options when listing paths.\n     */\n    listPaths(options = {}) {\n        options.path = options.path === \"\" ? undefined : options.path;\n        const iter = this.listItems(options);\n        return {\n            next() {\n                return iter.next();\n            },\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n            byPage: (settings = {}) => {\n                return this.listSegments(settings.continuationToken, Object.assign({ maxResults: settings.maxPageSize }, options));\n            }\n        };\n    }\n    listItems(options = {}) {\n        return __asyncGenerator(this, arguments, function* listItems_1() {\n            var e_1, _a;\n            try {\n                for (var _b = __asyncValues(this.listSegments(undefined, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n                    const response = _c.value;\n                    yield __await(yield* __asyncDelegator(__asyncValues(response.pathItems || [])));\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        });\n    }\n    listSegments(continuation, options = {}) {\n        return __asyncGenerator(this, arguments, function* listSegments_1() {\n            let response;\n            if (!!continuation || continuation === undefined) {\n                do {\n                    response = yield __await(this.listPathsSegment(continuation, options));\n                    continuation = response.continuation;\n                    yield yield __await(response);\n                } while (continuation);\n            }\n        });\n    }\n    async listPathsSegment(continuation, options = {}) {\n        const { span, updatedOptions } = createSpan(\"DataLakeFileSystemClient-listPathsSegment\", options);\n        try {\n            const rawResponse = await this.fileSystemContext.listPaths(options.recursive || false, Object.assign(Object.assign(Object.assign({ continuation }, options), { upn: options.userPrincipalName }), convertTracingToRequestOptionsBase(updatedOptions)));\n            const response = rawResponse;\n            response.pathItems = [];\n            for (const path of rawResponse.paths || []) {\n                response.pathItems.push(Object.assign(Object.assign({}, path), { permissions: toPermissions(path.permissions) }));\n            }\n            delete rawResponse.paths;\n            return response;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns an async iterable iterator to list all the paths (directories and files)\n     * under the specified file system.\n     *\n     * .byPage() returns an async iterable iterator to list the paths in pages.\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * // Get the fileSystemClient before you run these snippets,\n     * // Can be obtained from `serviceClient.getFileSystemClient(\"<your-filesystem-name>\");`\n     * let i = 1;\n     * for await (const deletePath of fileSystemClient.listDeletedPaths()) {\n     *   console.log(`Path ${i++}: ${deletePath.name}`);\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let i = 1;\n     * let iter = fileSystemClient.listDeletedPaths();\n     * let deletedPathItem = await iter.next();\n     * while (!deletedPathItem.done) {\n     *   console.log(`Path ${i++}: ${deletedPathItem.value.name}`);\n     *   pathItem = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * // passing optional maxPageSize in the page settings\n     * let i = 1;\n     * for await (const response of fileSystemClient.listDeletedPaths().byPage({ maxPageSize: 20 })) {\n     *   for (const deletePath of response.pathItems) {\n     *     console.log(`Path ${i++}: ${deletePath.name}`);\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a marker:\n     *\n     * ```js\n     * let i = 1;\n     * let iterator = fileSystemClient.listDeletedPaths().byPage({ maxPageSize: 2 });\n     * let response = (await iterator.next()).value;\n     *\n     * // Prints 2 path names\n     * for (const path of response.pathItems) {\n     *   console.log(`Path ${i++}: ${path.name}}`);\n     * }\n     *\n     * // Gets next marker\n     * let marker = response.continuationToken;\n     *\n     * // Passing next marker as continuationToken\n     *\n     * iterator = fileSystemClient.listDeletedPaths().byPage({ continuationToken: marker, maxPageSize: 10 });\n     * response = (await iterator.next()).value;\n     *\n     * // Prints 10 path names\n     * for (const deletePath of response.deletedPathItems) {\n     *   console.log(`Path ${i++}: ${deletePath.name}`);\n     * }\n     * ```\n     *\n     * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n     *\n     * @param options - Optional. Options when listing deleted paths.\n     */\n    listDeletedPaths(options = {}) {\n        const iter = this.listDeletedItems(options);\n        return {\n            next() {\n                return iter.next();\n            },\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n            byPage: (settings = {}) => {\n                return this.listDeletedSegments(settings.continuationToken, Object.assign({ maxResults: settings.maxPageSize }, options));\n            }\n        };\n    }\n    listDeletedItems(options = {}) {\n        return __asyncGenerator(this, arguments, function* listDeletedItems_1() {\n            var e_2, _a;\n            try {\n                for (var _b = __asyncValues(this.listDeletedSegments(undefined, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n                    const response = _c.value;\n                    yield __await(yield* __asyncDelegator(__asyncValues(response.pathItems || [])));\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        });\n    }\n    listDeletedSegments(continuation, options = {}) {\n        return __asyncGenerator(this, arguments, function* listDeletedSegments_1() {\n            let response;\n            if (!!continuation || continuation === undefined) {\n                do {\n                    response = yield __await(this.listDeletedPathsSegment(continuation, options));\n                    continuation = response.continuation;\n                    yield yield __await(response);\n                } while (continuation);\n            }\n        });\n    }\n    async listDeletedPathsSegment(continuation, options = {}) {\n        const { span, updatedOptions } = createSpan(\"DataLakeFileSystemClient-listDeletedPathsSegment\", options);\n        try {\n            const rawResponse = await this.fileSystemContextToBlobEndpoint.listBlobHierarchySegment(Object.assign(Object.assign(Object.assign({ marker: continuation }, options), { prefix: options.prefix === \"\" ? undefined : options.prefix }), convertTracingToRequestOptionsBase(updatedOptions)));\n            const response = rawResponse;\n            response.pathItems = [];\n            for (const path of rawResponse.segment.blobItems || []) {\n                response.pathItems.push({\n                    name: path.name,\n                    deletionId: path.deletionId,\n                    deletedOn: path.properties.deletedTime,\n                    remainingRetentionDays: path.properties.remainingRetentionDays\n                });\n            }\n            if (!(response.nextMarker === undefined || response.nextMarker === \"\")) {\n                response.continuation = response.nextMarker;\n            }\n            return response;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Restores a soft deleted path.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/undelete-blob\n     *\n     * @param deletedPath - Required.  The path of the deleted path.\n     *\n     * @param deletionId - Required.  The deletion ID associated with the soft deleted path.\n     *\n     */\n    async undeletePath(deletedPath, deletionId, options = {}) {\n        const { span, updatedOptions } = createSpan(\"DataLakeFileSystemClient-undeletePath\", options);\n        try {\n            const pathClient = new PathClientInternal(appendToURLPath(this.blobEndpointUrl, encodeURIComponent(deletedPath)), this.pipeline);\n            const rawResponse = await pathClient.blobPathContext.undelete(Object.assign(Object.assign({ undeleteSource: \"?\" + DeletionIdKey + \"=\" + deletionId }, options), { tracingOptions: updatedOptions.tracingOptions }));\n            if (rawResponse.resourceType === PathResultTypeConstants.DirectoryResourceType) {\n                return Object.assign({ pathClient: this.getDirectoryClient(deletedPath) }, rawResponse);\n            }\n            else {\n                return Object.assign({ pathClient: this.getFileClient(deletedPath) }, rawResponse);\n            }\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Only available for DataLakeFileSystemClient constructed with a shared key credential.\n     *\n     * Generates a Service Shared Access Signature (SAS) URI based on the client properties\n     * and parameters passed in. The SAS is signed by the shared key credential of the client.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n     *\n     * @param options - Optional parameters.\n     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n     */\n    generateSasUrl(options) {\n        return new Promise((resolve) => {\n            if (!(this.credential instanceof StorageSharedKeyCredential)) {\n                throw RangeError(\"Can only generate the SAS when the client is initialized with a shared key credential\");\n            }\n            const sas = generateDataLakeSASQueryParameters(Object.assign({ fileSystemName: this.name }, options), this.credential).toString();\n            resolve(appendToURLQuery(this.url, sas));\n        });\n    }\n}\n//# sourceMappingURL=DataLakeFileSystemClient.js.map"]},"metadata":{},"sourceType":"module"}