{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\n/**\n * returns an async iterator that iterates over results. It also has a `byPage`\n * method that returns pages of items at once.\n *\n * @param pagedResult - an object that specifies how to get pages.\n * @returns a paged async iterator that iterates over results.\n */\n\nexport function getPagedAsyncIterator(pagedResult) {\n  var _a;\n\n  const iter = getItemAsyncIterator(pagedResult);\n  return {\n    next() {\n      return iter.next();\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    byPage: (_a = pagedResult === null || pagedResult === void 0 ? void 0 : pagedResult.byPage) !== null && _a !== void 0 ? _a : settings => {\n      return getPageAsyncIterator(pagedResult, settings === null || settings === void 0 ? void 0 : settings.maxPageSize);\n    }\n  };\n}\n\nfunction getItemAsyncIterator(pagedResult, maxPageSize) {\n  return __asyncGenerator(this, arguments, function* getItemAsyncIterator_1() {\n    var e_1, _a;\n\n    const pages = getPageAsyncIterator(pagedResult, maxPageSize);\n    const firstVal = yield __await(pages.next()); // if the result does not have an array shape, i.e. TPage = TElement, then we return it as is\n\n    if (!Array.isArray(firstVal.value)) {\n      yield yield __await(firstVal.value); // `pages` is of type `AsyncIterableIterator<TPage>` but TPage = TElement in this case\n\n      yield __await(yield* __asyncDelegator(__asyncValues(pages)));\n    } else {\n      yield __await(yield* __asyncDelegator(__asyncValues(firstVal.value)));\n\n      try {\n        for (var pages_1 = __asyncValues(pages), pages_1_1; pages_1_1 = yield __await(pages_1.next()), !pages_1_1.done;) {\n          const page = pages_1_1.value; // pages is of type `AsyncIterableIterator<TPage>` so `page` is of type `TPage`. In this branch,\n          // it must be the case that `TPage = TElement[]`\n\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (pages_1_1 && !pages_1_1.done && (_a = pages_1.return)) yield __await(_a.call(pages_1));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n  });\n}\n\nfunction getPageAsyncIterator(pagedResult, maxPageSize) {\n  return __asyncGenerator(this, arguments, function* getPageAsyncIterator_1() {\n    let response = yield __await(pagedResult.getPage(pagedResult.firstPageLink, maxPageSize));\n    yield yield __await(response.page);\n\n    while (response.nextPageLink) {\n      response = yield __await(pagedResult.getPage(response.nextPageLink, maxPageSize));\n      yield yield __await(response.page);\n    }\n  });\n} //# sourceMappingURL=getPagedAsyncIterator.js.map","map":{"version":3,"sources":["F:/statvalu/AR_DocuExpert_Test/node_modules/@azure/core-paging/dist-esm/src/getPagedAsyncIterator.js"],"names":["__asyncDelegator","__asyncGenerator","__asyncValues","__await","getPagedAsyncIterator","pagedResult","_a","iter","getItemAsyncIterator","next","Symbol","asyncIterator","byPage","settings","getPageAsyncIterator","maxPageSize","arguments","getItemAsyncIterator_1","e_1","pages","firstVal","Array","isArray","value","pages_1","pages_1_1","done","page","e_1_1","error","return","call","getPageAsyncIterator_1","response","getPage","firstPageLink","nextPageLink"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\n/**\n * returns an async iterator that iterates over results. It also has a `byPage`\n * method that returns pages of items at once.\n *\n * @param pagedResult - an object that specifies how to get pages.\n * @returns a paged async iterator that iterates over results.\n */\nexport function getPagedAsyncIterator(pagedResult) {\n    var _a;\n    const iter = getItemAsyncIterator(pagedResult);\n    return {\n        next() {\n            return iter.next();\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n        byPage: (_a = pagedResult === null || pagedResult === void 0 ? void 0 : pagedResult.byPage) !== null && _a !== void 0 ? _a : ((settings) => {\n            return getPageAsyncIterator(pagedResult, settings === null || settings === void 0 ? void 0 : settings.maxPageSize);\n        })\n    };\n}\nfunction getItemAsyncIterator(pagedResult, maxPageSize) {\n    return __asyncGenerator(this, arguments, function* getItemAsyncIterator_1() {\n        var e_1, _a;\n        const pages = getPageAsyncIterator(pagedResult, maxPageSize);\n        const firstVal = yield __await(pages.next());\n        // if the result does not have an array shape, i.e. TPage = TElement, then we return it as is\n        if (!Array.isArray(firstVal.value)) {\n            yield yield __await(firstVal.value);\n            // `pages` is of type `AsyncIterableIterator<TPage>` but TPage = TElement in this case\n            yield __await(yield* __asyncDelegator(__asyncValues(pages)));\n        }\n        else {\n            yield __await(yield* __asyncDelegator(__asyncValues(firstVal.value)));\n            try {\n                for (var pages_1 = __asyncValues(pages), pages_1_1; pages_1_1 = yield __await(pages_1.next()), !pages_1_1.done;) {\n                    const page = pages_1_1.value;\n                    // pages is of type `AsyncIterableIterator<TPage>` so `page` is of type `TPage`. In this branch,\n                    // it must be the case that `TPage = TElement[]`\n                    yield __await(yield* __asyncDelegator(__asyncValues(page)));\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (pages_1_1 && !pages_1_1.done && (_a = pages_1.return)) yield __await(_a.call(pages_1));\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n    });\n}\nfunction getPageAsyncIterator(pagedResult, maxPageSize) {\n    return __asyncGenerator(this, arguments, function* getPageAsyncIterator_1() {\n        let response = yield __await(pagedResult.getPage(pagedResult.firstPageLink, maxPageSize));\n        yield yield __await(response.page);\n        while (response.nextPageLink) {\n            response = yield __await(pagedResult.getPage(response.nextPageLink, maxPageSize));\n            yield yield __await(response.page);\n        }\n    });\n}\n//# sourceMappingURL=getPagedAsyncIterator.js.map"]},"metadata":{},"sourceType":"module"}