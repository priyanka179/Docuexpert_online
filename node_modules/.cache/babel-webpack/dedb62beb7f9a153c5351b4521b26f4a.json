{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy, deserializationPolicy, generateUuid, HttpHeaders, WebResource, isTokenCredential, bearerTokenAuthenticationPolicy, isNode } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { BlobClient } from \"./Clients\";\nimport { Mutex } from \"./utils/Mutex\";\nimport { Pipeline } from \"./Pipeline\";\nimport { attachCredential, getURLPath, getURLPathAndQuery, iEqual } from \"./utils/utils.common\";\nimport { HeaderConstants, BATCH_MAX_REQUEST, HTTP_VERSION_1_1, HTTP_LINE_ENDING, StorageOAuthScopes } from \"./utils/constants\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { createSpan } from \"./utils/tracing\";\n/**\n * A BlobBatch represents an aggregated set of operations on blobs.\n * Currently, only `delete` and `setAccessTier` are supported.\n */\n\nexport class BlobBatch {\n  constructor() {\n    this.batch = \"batch\";\n    this.batchRequest = new InnerBatchRequest();\n  }\n  /**\n   * Get the value of Content-Type for a batch request.\n   * The value must be multipart/mixed with a batch boundary.\n   * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252\n   */\n\n\n  getMultiPartContentType() {\n    return this.batchRequest.getMultipartContentType();\n  }\n  /**\n   * Get assembled HTTP request body for sub requests.\n   */\n\n\n  getHttpRequestBody() {\n    return this.batchRequest.getHttpRequestBody();\n  }\n  /**\n   * Get sub requests that are added into the batch request.\n   */\n\n\n  getSubRequests() {\n    return this.batchRequest.getSubRequests();\n  }\n\n  addSubRequestInternal(subRequest, assembleSubRequestFunc) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield Mutex.lock(_this.batch);\n\n      try {\n        _this.batchRequest.preAddSubRequest(subRequest);\n\n        yield assembleSubRequestFunc();\n\n        _this.batchRequest.postAddSubRequest(subRequest);\n      } finally {\n        yield Mutex.unlock(_this.batch);\n      }\n    })();\n  }\n\n  setBatchType(batchType) {\n    if (!this.batchType) {\n      this.batchType = batchType;\n    }\n\n    if (this.batchType !== batchType) {\n      throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);\n    }\n  }\n\n  deleteBlob(urlOrBlobClient, credentialOrOptions, options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let url;\n      let credential;\n\n      if (typeof urlOrBlobClient === \"string\" && (isNode && credentialOrOptions instanceof StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential || isTokenCredential(credentialOrOptions))) {\n        // First overload\n        url = urlOrBlobClient;\n        credential = credentialOrOptions;\n      } else if (urlOrBlobClient instanceof BlobClient) {\n        // Second overload\n        url = urlOrBlobClient.url;\n        credential = urlOrBlobClient.credential;\n        options = credentialOrOptions;\n      } else {\n        throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n      }\n\n      if (!options) {\n        options = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BatchDeleteRequest-addSubRequest\", options);\n\n      try {\n        _this2.setBatchType(\"delete\");\n\n        yield _this2.addSubRequestInternal({\n          url: url,\n          credential: credential\n        }, /*#__PURE__*/_asyncToGenerator(function* () {\n          yield new BlobClient(url, _this2.batchRequest.createPipeline(credential)).delete(updatedOptions);\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n  setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let url;\n      let credential;\n      let tier;\n\n      if (typeof urlOrBlobClient === \"string\" && (isNode && credentialOrTier instanceof StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential || isTokenCredential(credentialOrTier))) {\n        // First overload\n        url = urlOrBlobClient;\n        credential = credentialOrTier;\n        tier = tierOrOptions;\n      } else if (urlOrBlobClient instanceof BlobClient) {\n        // Second overload\n        url = urlOrBlobClient.url;\n        credential = urlOrBlobClient.credential;\n        tier = credentialOrTier;\n        options = tierOrOptions;\n      } else {\n        throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n      }\n\n      if (!options) {\n        options = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"BatchSetTierRequest-addSubRequest\", options);\n\n      try {\n        _this3.setBatchType(\"setAccessTier\");\n\n        yield _this3.addSubRequestInternal({\n          url: url,\n          credential: credential\n        }, /*#__PURE__*/_asyncToGenerator(function* () {\n          yield new BlobClient(url, _this3.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);\n        }));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n\n}\n/**\n * Inner batch request class which is responsible for assembling and serializing sub requests.\n * See https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#request-body for how requests are assembled.\n */\n\nclass InnerBatchRequest {\n  constructor() {\n    this.operationCount = 0;\n    this.body = \"\";\n    const tempGuid = generateUuid(); // batch_{batchid}\n\n    this.boundary = `batch_${tempGuid}`; // --batch_{batchid}\n    // Content-Type: application/http\n    // Content-Transfer-Encoding: binary\n\n    this.subRequestPrefix = `--${this.boundary}${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TYPE}: application/http${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`; // multipart/mixed; boundary=batch_{batchid}\n\n    this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`; // --batch_{batchid}--\n\n    this.batchRequestEnding = `--${this.boundary}--`;\n    this.subRequests = new Map();\n  }\n  /**\n   * Create pipeline to assemble sub requests. The idea here is to use existing\n   * credential and serialization/deserialization components, with additional policies to\n   * filter unnecessary headers, assemble sub requests into request's body\n   * and intercept request from going to wire.\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   */\n\n\n  createPipeline(credential) {\n    const isAnonymousCreds = credential instanceof AnonymousCredential;\n    const policyFactoryLength = 3 + (isAnonymousCreds ? 0 : 1); // [deserializationPolicy, BatchHeaderFilterPolicyFactory, (Optional)Credential, BatchRequestAssemblePolicyFactory]\n\n    const factories = new Array(policyFactoryLength);\n    factories[0] = deserializationPolicy(); // Default deserializationPolicy is provided by protocol layer\n\n    factories[1] = new BatchHeaderFilterPolicyFactory(); // Use batch header filter policy to exclude unnecessary headers\n\n    if (!isAnonymousCreds) {\n      factories[2] = isTokenCredential(credential) ? attachCredential(bearerTokenAuthenticationPolicy(credential, StorageOAuthScopes), credential) : credential;\n    }\n\n    factories[policyFactoryLength - 1] = new BatchRequestAssemblePolicyFactory(this); // Use batch assemble policy to assemble request and intercept request from going to wire\n\n    return new Pipeline(factories, {});\n  }\n\n  appendSubRequestToBody(request) {\n    // Start to assemble sub request\n    this.body += [this.subRequestPrefix, `${HeaderConstants.CONTENT_ID}: ${this.operationCount}`, \"\", `${request.method.toString()} ${getURLPathAndQuery(request.url)} ${HTTP_VERSION_1_1}${HTTP_LINE_ENDING}` // sub request start line with method\n    ].join(HTTP_LINE_ENDING);\n\n    for (const header of request.headers.headersArray()) {\n      this.body += `${header.name}: ${header.value}${HTTP_LINE_ENDING}`;\n    }\n\n    this.body += HTTP_LINE_ENDING; // sub request's headers need be ending with an empty line\n    // No body to assemble for current batch request support\n    // End to assemble sub request\n  }\n\n  preAddSubRequest(subRequest) {\n    if (this.operationCount >= BATCH_MAX_REQUEST) {\n      throw new RangeError(`Cannot exceed ${BATCH_MAX_REQUEST} sub requests in a single batch`);\n    } // Fast fail if url for sub request is invalid\n\n\n    const path = getURLPath(subRequest.url);\n\n    if (!path || path === \"\") {\n      throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);\n    }\n  }\n\n  postAddSubRequest(subRequest) {\n    this.subRequests.set(this.operationCount, subRequest);\n    this.operationCount++;\n  } // Return the http request body with assembling the ending line to the sub request body.\n\n\n  getHttpRequestBody() {\n    return `${this.body}${this.batchRequestEnding}${HTTP_LINE_ENDING}`;\n  }\n\n  getMultipartContentType() {\n    return this.multipartContentType;\n  }\n\n  getSubRequests() {\n    return this.subRequests;\n  }\n\n}\n\nclass BatchRequestAssemblePolicy extends BaseRequestPolicy {\n  constructor(batchRequest, nextPolicy, options) {\n    super(nextPolicy, options);\n    this.dummyResponse = {\n      request: new WebResource(),\n      status: 200,\n      headers: new HttpHeaders()\n    };\n    this.batchRequest = batchRequest;\n  }\n\n  sendRequest(request) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this4.batchRequest.appendSubRequestToBody(request);\n      return _this4.dummyResponse; // Intercept request from going to wire\n    })();\n  }\n\n}\n\nclass BatchRequestAssemblePolicyFactory {\n  constructor(batchRequest) {\n    this.batchRequest = batchRequest;\n  }\n\n  create(nextPolicy, options) {\n    return new BatchRequestAssemblePolicy(this.batchRequest, nextPolicy, options);\n  }\n\n}\n\nclass BatchHeaderFilterPolicy extends BaseRequestPolicy {\n  // The base class has a protected constructor. Adding a public one to enable constructing of this class.\n\n  /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/\n  constructor(nextPolicy, options) {\n    super(nextPolicy, options);\n  }\n\n  sendRequest(request) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      let xMsHeaderName = \"\";\n\n      for (const header of request.headers.headersArray()) {\n        if (iEqual(header.name, HeaderConstants.X_MS_VERSION)) {\n          xMsHeaderName = header.name;\n        }\n      }\n\n      if (xMsHeaderName !== \"\") {\n        request.headers.remove(xMsHeaderName); // The subrequests should not have the x-ms-version header.\n      }\n\n      return _this5._nextPolicy.sendRequest(request);\n    })();\n  }\n\n}\n\nclass BatchHeaderFilterPolicyFactory {\n  create(nextPolicy, options) {\n    return new BatchHeaderFilterPolicy(nextPolicy, options);\n  }\n\n} //# sourceMappingURL=BlobBatch.js.map","map":{"version":3,"sources":["F:/statvalu/AR_DocuExpert_Test/node_modules/@azure/storage-blob/dist-esm/storage-blob/src/BlobBatch.js"],"names":["BaseRequestPolicy","deserializationPolicy","generateUuid","HttpHeaders","WebResource","isTokenCredential","bearerTokenAuthenticationPolicy","isNode","SpanStatusCode","AnonymousCredential","BlobClient","Mutex","Pipeline","attachCredential","getURLPath","getURLPathAndQuery","iEqual","HeaderConstants","BATCH_MAX_REQUEST","HTTP_VERSION_1_1","HTTP_LINE_ENDING","StorageOAuthScopes","StorageSharedKeyCredential","createSpan","BlobBatch","constructor","batch","batchRequest","InnerBatchRequest","getMultiPartContentType","getMultipartContentType","getHttpRequestBody","getSubRequests","addSubRequestInternal","subRequest","assembleSubRequestFunc","lock","preAddSubRequest","postAddSubRequest","unlock","setBatchType","batchType","RangeError","deleteBlob","urlOrBlobClient","credentialOrOptions","options","url","credential","span","updatedOptions","createPipeline","delete","e","setStatus","code","ERROR","message","end","setBlobAccessTier","credentialOrTier","tierOrOptions","tier","setAccessTier","operationCount","body","tempGuid","boundary","subRequestPrefix","CONTENT_TYPE","CONTENT_TRANSFER_ENCODING","multipartContentType","batchRequestEnding","subRequests","Map","isAnonymousCreds","policyFactoryLength","factories","Array","BatchHeaderFilterPolicyFactory","BatchRequestAssemblePolicyFactory","appendSubRequestToBody","request","CONTENT_ID","method","toString","join","header","headers","headersArray","name","value","path","set","BatchRequestAssemblePolicy","nextPolicy","dummyResponse","status","sendRequest","create","BatchHeaderFilterPolicy","xMsHeaderName","X_MS_VERSION","remove","_nextPolicy"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy, deserializationPolicy, generateUuid, HttpHeaders, WebResource, isTokenCredential, bearerTokenAuthenticationPolicy, isNode } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { BlobClient } from \"./Clients\";\nimport { Mutex } from \"./utils/Mutex\";\nimport { Pipeline } from \"./Pipeline\";\nimport { attachCredential, getURLPath, getURLPathAndQuery, iEqual } from \"./utils/utils.common\";\nimport { HeaderConstants, BATCH_MAX_REQUEST, HTTP_VERSION_1_1, HTTP_LINE_ENDING, StorageOAuthScopes } from \"./utils/constants\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { createSpan } from \"./utils/tracing\";\n/**\n * A BlobBatch represents an aggregated set of operations on blobs.\n * Currently, only `delete` and `setAccessTier` are supported.\n */\nexport class BlobBatch {\n    constructor() {\n        this.batch = \"batch\";\n        this.batchRequest = new InnerBatchRequest();\n    }\n    /**\n     * Get the value of Content-Type for a batch request.\n     * The value must be multipart/mixed with a batch boundary.\n     * Example: multipart/mixed; boundary=batch_a81786c8-e301-4e42-a729-a32ca24ae252\n     */\n    getMultiPartContentType() {\n        return this.batchRequest.getMultipartContentType();\n    }\n    /**\n     * Get assembled HTTP request body for sub requests.\n     */\n    getHttpRequestBody() {\n        return this.batchRequest.getHttpRequestBody();\n    }\n    /**\n     * Get sub requests that are added into the batch request.\n     */\n    getSubRequests() {\n        return this.batchRequest.getSubRequests();\n    }\n    async addSubRequestInternal(subRequest, assembleSubRequestFunc) {\n        await Mutex.lock(this.batch);\n        try {\n            this.batchRequest.preAddSubRequest(subRequest);\n            await assembleSubRequestFunc();\n            this.batchRequest.postAddSubRequest(subRequest);\n        }\n        finally {\n            await Mutex.unlock(this.batch);\n        }\n    }\n    setBatchType(batchType) {\n        if (!this.batchType) {\n            this.batchType = batchType;\n        }\n        if (this.batchType !== batchType) {\n            throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);\n        }\n    }\n    async deleteBlob(urlOrBlobClient, credentialOrOptions, options) {\n        let url;\n        let credential;\n        if (typeof urlOrBlobClient === \"string\" &&\n            ((isNode && credentialOrOptions instanceof StorageSharedKeyCredential) ||\n                credentialOrOptions instanceof AnonymousCredential ||\n                isTokenCredential(credentialOrOptions))) {\n            // First overload\n            url = urlOrBlobClient;\n            credential = credentialOrOptions;\n        }\n        else if (urlOrBlobClient instanceof BlobClient) {\n            // Second overload\n            url = urlOrBlobClient.url;\n            credential = urlOrBlobClient.credential;\n            options = credentialOrOptions;\n        }\n        else {\n            throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n        }\n        if (!options) {\n            options = {};\n        }\n        const { span, updatedOptions } = createSpan(\"BatchDeleteRequest-addSubRequest\", options);\n        try {\n            this.setBatchType(\"delete\");\n            await this.addSubRequestInternal({\n                url: url,\n                credential: credential\n            }, async () => {\n                await new BlobClient(url, this.batchRequest.createPipeline(credential)).delete(updatedOptions);\n            });\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    async setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {\n        let url;\n        let credential;\n        let tier;\n        if (typeof urlOrBlobClient === \"string\" &&\n            ((isNode && credentialOrTier instanceof StorageSharedKeyCredential) ||\n                credentialOrTier instanceof AnonymousCredential ||\n                isTokenCredential(credentialOrTier))) {\n            // First overload\n            url = urlOrBlobClient;\n            credential = credentialOrTier;\n            tier = tierOrOptions;\n        }\n        else if (urlOrBlobClient instanceof BlobClient) {\n            // Second overload\n            url = urlOrBlobClient.url;\n            credential = urlOrBlobClient.credential;\n            tier = credentialOrTier;\n            options = tierOrOptions;\n        }\n        else {\n            throw new RangeError(\"Invalid arguments. Either url and credential, or BlobClient need be provided.\");\n        }\n        if (!options) {\n            options = {};\n        }\n        const { span, updatedOptions } = createSpan(\"BatchSetTierRequest-addSubRequest\", options);\n        try {\n            this.setBatchType(\"setAccessTier\");\n            await this.addSubRequestInternal({\n                url: url,\n                credential: credential\n            }, async () => {\n                await new BlobClient(url, this.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);\n            });\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n}\n/**\n * Inner batch request class which is responsible for assembling and serializing sub requests.\n * See https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#request-body for how requests are assembled.\n */\nclass InnerBatchRequest {\n    constructor() {\n        this.operationCount = 0;\n        this.body = \"\";\n        const tempGuid = generateUuid();\n        // batch_{batchid}\n        this.boundary = `batch_${tempGuid}`;\n        // --batch_{batchid}\n        // Content-Type: application/http\n        // Content-Transfer-Encoding: binary\n        this.subRequestPrefix = `--${this.boundary}${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TYPE}: application/http${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;\n        // multipart/mixed; boundary=batch_{batchid}\n        this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;\n        // --batch_{batchid}--\n        this.batchRequestEnding = `--${this.boundary}--`;\n        this.subRequests = new Map();\n    }\n    /**\n     * Create pipeline to assemble sub requests. The idea here is to use existing\n     * credential and serialization/deserialization components, with additional policies to\n     * filter unnecessary headers, assemble sub requests into request's body\n     * and intercept request from going to wire.\n     * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n     */\n    createPipeline(credential) {\n        const isAnonymousCreds = credential instanceof AnonymousCredential;\n        const policyFactoryLength = 3 + (isAnonymousCreds ? 0 : 1); // [deserializationPolicy, BatchHeaderFilterPolicyFactory, (Optional)Credential, BatchRequestAssemblePolicyFactory]\n        const factories = new Array(policyFactoryLength);\n        factories[0] = deserializationPolicy(); // Default deserializationPolicy is provided by protocol layer\n        factories[1] = new BatchHeaderFilterPolicyFactory(); // Use batch header filter policy to exclude unnecessary headers\n        if (!isAnonymousCreds) {\n            factories[2] = isTokenCredential(credential)\n                ? attachCredential(bearerTokenAuthenticationPolicy(credential, StorageOAuthScopes), credential)\n                : credential;\n        }\n        factories[policyFactoryLength - 1] = new BatchRequestAssemblePolicyFactory(this); // Use batch assemble policy to assemble request and intercept request from going to wire\n        return new Pipeline(factories, {});\n    }\n    appendSubRequestToBody(request) {\n        // Start to assemble sub request\n        this.body += [\n            this.subRequestPrefix,\n            `${HeaderConstants.CONTENT_ID}: ${this.operationCount}`,\n            \"\",\n            `${request.method.toString()} ${getURLPathAndQuery(request.url)} ${HTTP_VERSION_1_1}${HTTP_LINE_ENDING}` // sub request start line with method\n        ].join(HTTP_LINE_ENDING);\n        for (const header of request.headers.headersArray()) {\n            this.body += `${header.name}: ${header.value}${HTTP_LINE_ENDING}`;\n        }\n        this.body += HTTP_LINE_ENDING; // sub request's headers need be ending with an empty line\n        // No body to assemble for current batch request support\n        // End to assemble sub request\n    }\n    preAddSubRequest(subRequest) {\n        if (this.operationCount >= BATCH_MAX_REQUEST) {\n            throw new RangeError(`Cannot exceed ${BATCH_MAX_REQUEST} sub requests in a single batch`);\n        }\n        // Fast fail if url for sub request is invalid\n        const path = getURLPath(subRequest.url);\n        if (!path || path === \"\") {\n            throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);\n        }\n    }\n    postAddSubRequest(subRequest) {\n        this.subRequests.set(this.operationCount, subRequest);\n        this.operationCount++;\n    }\n    // Return the http request body with assembling the ending line to the sub request body.\n    getHttpRequestBody() {\n        return `${this.body}${this.batchRequestEnding}${HTTP_LINE_ENDING}`;\n    }\n    getMultipartContentType() {\n        return this.multipartContentType;\n    }\n    getSubRequests() {\n        return this.subRequests;\n    }\n}\nclass BatchRequestAssemblePolicy extends BaseRequestPolicy {\n    constructor(batchRequest, nextPolicy, options) {\n        super(nextPolicy, options);\n        this.dummyResponse = {\n            request: new WebResource(),\n            status: 200,\n            headers: new HttpHeaders()\n        };\n        this.batchRequest = batchRequest;\n    }\n    async sendRequest(request) {\n        await this.batchRequest.appendSubRequestToBody(request);\n        return this.dummyResponse; // Intercept request from going to wire\n    }\n}\nclass BatchRequestAssemblePolicyFactory {\n    constructor(batchRequest) {\n        this.batchRequest = batchRequest;\n    }\n    create(nextPolicy, options) {\n        return new BatchRequestAssemblePolicy(this.batchRequest, nextPolicy, options);\n    }\n}\nclass BatchHeaderFilterPolicy extends BaseRequestPolicy {\n    // The base class has a protected constructor. Adding a public one to enable constructing of this class.\n    /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/\n    constructor(nextPolicy, options) {\n        super(nextPolicy, options);\n    }\n    async sendRequest(request) {\n        let xMsHeaderName = \"\";\n        for (const header of request.headers.headersArray()) {\n            if (iEqual(header.name, HeaderConstants.X_MS_VERSION)) {\n                xMsHeaderName = header.name;\n            }\n        }\n        if (xMsHeaderName !== \"\") {\n            request.headers.remove(xMsHeaderName); // The subrequests should not have the x-ms-version header.\n        }\n        return this._nextPolicy.sendRequest(request);\n    }\n}\nclass BatchHeaderFilterPolicyFactory {\n    create(nextPolicy, options) {\n        return new BatchHeaderFilterPolicy(nextPolicy, options);\n    }\n}\n//# sourceMappingURL=BlobBatch.js.map"]},"metadata":{},"sourceType":"module"}