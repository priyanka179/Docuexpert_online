{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/project/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { getDefaultProxySettings, isNode, isTokenCredential, URLBuilder } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { Container } from \"./generated/src/operations\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { StorageClient } from \"./StorageClient\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport { appendToURLPath, appendToURLQuery, extractConnectionStringParts, isIpEndpointStyle, parseObjectReplicationRecord, toTags, truncatedISO8061Date } from \"./utils/utils.common\";\nimport { generateBlobSASQueryParameters } from \"./sas/BlobSASSignatureValues\";\nimport { BlobLeaseClient } from \"./BlobLeaseClient\";\nimport { AppendBlobClient, BlobClient, BlockBlobClient, PageBlobClient } from \"./Clients\";\nimport { BlobBatchClient } from \"./BlobBatchClient\";\n/**\n * A ContainerClient represents a URL to the Azure Storage container allowing you to manipulate its blobs.\n */\n\nexport class ContainerClient extends StorageClient {\n  constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    let pipeline;\n    let url;\n    options = options || {};\n\n    if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n      // (url: string, pipeline: Pipeline)\n      url = urlOrConnectionString;\n      pipeline = credentialOrPipelineOrContainerName;\n    } else if (isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || isTokenCredential(credentialOrPipelineOrContainerName)) {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      url = urlOrConnectionString;\n      pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n    } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== \"string\") {\n      // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n      // The second parameter is undefined. Use anonymous credential.\n      url = urlOrConnectionString;\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === \"string\") {\n      // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n      const containerName = credentialOrPipelineOrContainerName;\n      const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n\n      if (extractedCreds.kind === \"AccountConnString\") {\n        if (isNode) {\n          const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n          url = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName));\n          options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n          pipeline = newPipeline(sharedKeyCredential, options);\n        } else {\n          throw new Error(\"Account connection string is only supported in Node.js environment\");\n        }\n      } else if (extractedCreds.kind === \"SASConnString\") {\n        url = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)) + \"?\" + extractedCreds.accountSas;\n        pipeline = newPipeline(new AnonymousCredential(), options);\n      } else {\n        throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n      }\n    } else {\n      throw new Error(\"Expecting non-empty strings for containerName parameter\");\n    }\n\n    super(url, pipeline);\n    this._containerName = this.getContainerNameFromUrl();\n    this.containerContext = new Container(this.storageClientContext);\n  }\n  /**\n   * The name of the container.\n   */\n\n\n  get containerName() {\n    return this._containerName;\n  }\n  /**\n   * Creates a new container under the specified account. If the container with\n   * the same name already exists, the operation fails.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n   *\n   * @param options - Options to Container Create operation.\n   *\n   *\n   * Example usage:\n   *\n   * ```js\n   * const containerClient = blobServiceClient.getContainerClient(\"<container name>\");\n   * const createContainerResponse = await containerClient.create();\n   * console.log(\"Container was created successfully\", createContainerResponse.requestId);\n   * ```\n   */\n\n\n  create(options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-create\", options);\n\n      try {\n        // Spread operator in destructuring assignments,\n        // this will filter out unwanted properties from the response object into result object\n        return yield _this.containerContext.create(Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a new container under the specified account. If the container with\n   * the same name already exists, it is not changed.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n   *\n   * @param options -\n   */\n\n\n  createIfNotExists(options = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-createIfNotExists\", options);\n\n      try {\n        const res = yield _this2.create(updatedOptions);\n        return Object.assign(Object.assign({\n          succeeded: true\n        }, res), {\n          _response: res._response // _response is made non-enumerable\n\n        });\n      } catch (e) {\n        if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"ContainerAlreadyExists\") {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: \"Expected exception when creating a container only if it does not already exist.\"\n          });\n          return Object.assign(Object.assign({\n            succeeded: false\n          }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n            _response: e.response\n          });\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns true if the Azure container resource represented by this client exists; false otherwise.\n   *\n   * NOTE: use this function with care since an existing container might be deleted by other clients or\n   * applications. Vice versa new containers with the same name might be added by other clients or\n   * applications after this function completes.\n   *\n   * @param options -\n   */\n\n\n  exists(options = {}) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-exists\", options);\n\n      try {\n        yield _this3.getProperties({\n          abortSignal: options.abortSignal,\n          tracingOptions: updatedOptions.tracingOptions\n        });\n        return true;\n      } catch (e) {\n        if (e.statusCode === 404) {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: \"Expected exception when checking container existence\"\n          });\n          return false;\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Creates a {@link BlobClient}\n   *\n   * @param blobName - A blob name\n   * @returns A new BlobClient object for the given blob name.\n   */\n\n\n  getBlobClient(blobName) {\n    return new BlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);\n  }\n  /**\n   * Creates an {@link AppendBlobClient}\n   *\n   * @param blobName - An append blob name\n   */\n\n\n  getAppendBlobClient(blobName) {\n    return new AppendBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);\n  }\n  /**\n   * Creates a {@link BlockBlobClient}\n   *\n   * @param blobName - A block blob name\n   *\n   *\n   * Example usage:\n   *\n   * ```js\n   * const content = \"Hello world!\";\n   *\n   * const blockBlobClient = containerClient.getBlockBlobClient(\"<blob name>\");\n   * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);\n   * ```\n   */\n\n\n  getBlockBlobClient(blobName) {\n    return new BlockBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);\n  }\n  /**\n   * Creates a {@link PageBlobClient}\n   *\n   * @param blobName - A page blob name\n   */\n\n\n  getPageBlobClient(blobName) {\n    return new PageBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);\n  }\n  /**\n   * Returns all user-defined metadata and system properties for the specified\n   * container. The data returned does not include the container's list of blobs.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-properties\n   *\n   * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n   * they originally contained uppercase characters. This differs from the metadata keys returned by\n   * the `listContainers` method of {@link BlobServiceClient} using the `includeMetadata` option, which\n   * will retain their original casing.\n   *\n   * @param options - Options to Container Get Properties operation.\n   */\n\n\n  getProperties(options = {}) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!options.conditions) {\n        options.conditions = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-getProperties\", options);\n\n      try {\n        return yield _this4.containerContext.getProperties(Object.assign(Object.assign({\n          abortSignal: options.abortSignal\n        }, options.conditions), convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Marks the specified container for deletion. The container and any blobs\n   * contained within it are later deleted during garbage collection.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n   *\n   * @param options - Options to Container Delete operation.\n   */\n\n\n  delete(options = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!options.conditions) {\n        options.conditions = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-delete\", options);\n\n      try {\n        return yield _this5.containerContext.delete(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: options.conditions\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Marks the specified container for deletion if it exists. The container and any blobs\n   * contained within it are later deleted during garbage collection.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n   *\n   * @param options - Options to Container Delete operation.\n   */\n\n\n  deleteIfExists(options = {}) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-deleteIfExists\", options);\n\n      try {\n        const res = yield _this6.delete(updatedOptions);\n        return Object.assign(Object.assign({\n          succeeded: true\n        }, res), {\n          _response: res._response // _response is made non-enumerable\n\n        });\n      } catch (e) {\n        if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"ContainerNotFound\") {\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: \"Expected exception when deleting a container only if it exists.\"\n          });\n          return Object.assign(Object.assign({\n            succeeded: false\n          }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), {\n            _response: e.response\n          });\n        }\n\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets one or more user-defined name-value pairs for the specified container.\n   *\n   * If no option provided, or no metadata defined in the parameter, the container\n   * metadata will be removed.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-metadata\n   *\n   * @param metadata - Replace existing metadata with this value.\n   *                            If no value provided the existing metadata will be removed.\n   * @param options - Options to Container Set Metadata operation.\n   */\n\n\n  setMetadata(metadata, options = {}) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!options.conditions) {\n        options.conditions = {};\n      }\n\n      if (options.conditions.ifUnmodifiedSince) {\n        throw new RangeError(\"the IfUnmodifiedSince must have their default values because they are ignored by the blob service\");\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-setMetadata\", options);\n\n      try {\n        return yield _this7.containerContext.setMetadata(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions,\n          metadata,\n          modifiedAccessConditions: options.conditions\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Gets the permissions for the specified container. The permissions indicate\n   * whether container data may be accessed publicly.\n   *\n   * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.\n   * For example, new Date(\"2018-12-31T03:44:23.8827891Z\").toISOString() will get \"2018-12-31T03:44:23.882Z\".\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-acl\n   *\n   * @param options - Options to Container Get Access Policy operation.\n   */\n\n\n  getAccessPolicy(options = {}) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!options.conditions) {\n        options.conditions = {};\n      }\n\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-getAccessPolicy\", options);\n\n      try {\n        const response = yield _this8.containerContext.getAccessPolicy(Object.assign({\n          abortSignal: options.abortSignal,\n          leaseAccessConditions: options.conditions\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n        const res = {\n          _response: response._response,\n          blobPublicAccess: response.blobPublicAccess,\n          date: response.date,\n          etag: response.etag,\n          errorCode: response.errorCode,\n          lastModified: response.lastModified,\n          requestId: response.requestId,\n          clientRequestId: response.clientRequestId,\n          signedIdentifiers: [],\n          version: response.version\n        };\n\n        for (const identifier of response) {\n          let accessPolicy = undefined;\n\n          if (identifier.accessPolicy) {\n            accessPolicy = {\n              permissions: identifier.accessPolicy.permissions\n            };\n\n            if (identifier.accessPolicy.expiresOn) {\n              accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);\n            }\n\n            if (identifier.accessPolicy.startsOn) {\n              accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);\n            }\n          }\n\n          res.signedIdentifiers.push({\n            accessPolicy,\n            id: identifier.id\n          });\n        }\n\n        return res;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Sets the permissions for the specified container. The permissions indicate\n   * whether blobs in a container may be accessed publicly.\n   *\n   * When you set permissions for a container, the existing permissions are replaced.\n   * If no access or containerAcl provided, the existing container ACL will be\n   * removed.\n   *\n   * When you establish a stored access policy on a container, it may take up to 30 seconds to take effect.\n   * During this interval, a shared access signature that is associated with the stored access policy will\n   * fail with status code 403 (Forbidden), until the access policy becomes active.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-acl\n   *\n   * @param access - The level of public access to data in the container.\n   * @param containerAcl - Array of elements each having a unique Id and details of the access policy.\n   * @param options - Options to Container Set Access Policy operation.\n   */\n\n\n  setAccessPolicy(access, containerAcl, options = {}) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      options.conditions = options.conditions || {};\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-setAccessPolicy\", options);\n\n      try {\n        const acl = [];\n\n        for (const identifier of containerAcl || []) {\n          acl.push({\n            accessPolicy: {\n              expiresOn: identifier.accessPolicy.expiresOn ? truncatedISO8061Date(identifier.accessPolicy.expiresOn) : \"\",\n              permissions: identifier.accessPolicy.permissions,\n              startsOn: identifier.accessPolicy.startsOn ? truncatedISO8061Date(identifier.accessPolicy.startsOn) : \"\"\n            },\n            id: identifier.id\n          });\n        }\n\n        return yield _this9.containerContext.setAccessPolicy(Object.assign({\n          abortSignal: options.abortSignal,\n          access,\n          containerAcl: acl,\n          leaseAccessConditions: options.conditions,\n          modifiedAccessConditions: options.conditions\n        }, convertTracingToRequestOptionsBase(updatedOptions)));\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Get a {@link BlobLeaseClient} that manages leases on the container.\n   *\n   * @param proposeLeaseId - Initial proposed lease Id.\n   * @returns A new BlobLeaseClient object for managing leases on the container.\n   */\n\n\n  getBlobLeaseClient(proposeLeaseId) {\n    return new BlobLeaseClient(this, proposeLeaseId);\n  }\n  /**\n   * Creates a new block blob, or updates the content of an existing block blob.\n   *\n   * Updating an existing block blob overwrites any existing metadata on the blob.\n   * Partial updates are not supported; the content of the existing blob is\n   * overwritten with the new content. To perform a partial update of a block blob's,\n   * use {@link BlockBlobClient.stageBlock} and {@link BlockBlobClient.commitBlockList}.\n   *\n   * This is a non-parallel uploading method, please use {@link BlockBlobClient.uploadFile},\n   * {@link BlockBlobClient.uploadStream} or {@link BlockBlobClient.uploadBrowserData} for better\n   * performance with concurrency uploading.\n   *\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param blobName - Name of the block blob to create or update.\n   * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function\n   *                               which returns a new Readable stream whose offset is from data source beginning.\n   * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a\n   *                               string including non non-Base64/Hex-encoded characters.\n   * @param options - Options to configure the Block Blob Upload operation.\n   * @returns Block Blob upload response data and the corresponding BlockBlobClient instance.\n   */\n\n\n  uploadBlockBlob(blobName, body, contentLength, options = {}) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-uploadBlockBlob\", options);\n\n      try {\n        const blockBlobClient = _this10.getBlockBlobClient(blobName);\n\n        const response = yield blockBlobClient.upload(body, contentLength, updatedOptions);\n        return {\n          blockBlobClient,\n          response\n        };\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Marks the specified blob or snapshot for deletion. The blob is later deleted\n   * during garbage collection. Note that in order to delete a blob, you must delete\n   * all of its snapshots. You can delete both at the same time with the Delete\n   * Blob operation.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n   *\n   * @param blobName -\n   * @param options - Options to Blob Delete operation.\n   * @returns Block blob deletion response data.\n   */\n\n\n  deleteBlob(blobName, options = {}) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-deleteBlob\", options);\n\n      try {\n        let blobClient = _this11.getBlobClient(blobName);\n\n        if (options.versionId) {\n          blobClient = blobClient.withVersion(options.versionId);\n        }\n\n        return yield blobClient.delete(updatedOptions);\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * listBlobFlatSegment returns a single segment of blobs starting from the\n   * specified Marker. Use an empty Marker to start enumeration from the beginning.\n   * After getting a segment, process it, and then call listBlobsFlatSegment again\n   * (passing the the previously-returned Marker) to get the next segment.\n   * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n   *\n   * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n   * @param options - Options to Container List Blob Flat Segment operation.\n   */\n\n\n  listBlobFlatSegment(marker, options = {}) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-listBlobFlatSegment\", options);\n\n      try {\n        const response = yield _this12.containerContext.listBlobFlatSegment(Object.assign(Object.assign({\n          marker\n        }, options), convertTracingToRequestOptionsBase(updatedOptions)));\n        const wrappedResponse = Object.assign(Object.assign({}, response), {\n          _response: response._response,\n          segment: Object.assign(Object.assign({}, response.segment), {\n            blobItems: response.segment.blobItems.map(blobItemInteral => {\n              const blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n                tags: toTags(blobItemInteral.blobTags),\n                objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInteral.objectReplicationMetadata)\n              });\n              return blobItem;\n            })\n          })\n        });\n        return wrappedResponse;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * listBlobHierarchySegment returns a single segment of blobs starting from\n   * the specified Marker. Use an empty Marker to start enumeration from the\n   * beginning. After getting a segment, process it, and then call listBlobsHierarchicalSegment\n   * again (passing the the previously-returned Marker) to get the next segment.\n   * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n   *\n   * @param delimiter - The character or string used to define the virtual hierarchy\n   * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n   * @param options - Options to Container List Blob Hierarchy Segment operation.\n   */\n\n\n  listBlobHierarchySegment(delimiter, marker, options = {}) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        span,\n        updatedOptions\n      } = createSpan(\"ContainerClient-listBlobHierarchySegment\", options);\n\n      try {\n        const response = yield _this13.containerContext.listBlobHierarchySegment(delimiter, Object.assign(Object.assign({\n          marker\n        }, options), convertTracingToRequestOptionsBase(updatedOptions)));\n        const wrappedResponse = Object.assign(Object.assign({}, response), {\n          _response: response._response,\n          segment: Object.assign(Object.assign({}, response.segment), {\n            blobItems: response.segment.blobItems.map(blobItemInteral => {\n              const blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n                tags: toTags(blobItemInteral.blobTags),\n                objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInteral.objectReplicationMetadata)\n              });\n              return blobItem;\n            })\n          })\n        });\n        return wrappedResponse;\n      } catch (e) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: e.message\n        });\n        throw e;\n      } finally {\n        span.end();\n      }\n    })();\n  }\n  /**\n   * Returns an AsyncIterableIterator for ContainerListBlobFlatSegmentResponse\n   *\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the ContinuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The ContinuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to list blobs operation.\n   */\n\n\n  listSegments(marker, options = {}) {\n    return __asyncGenerator(this, arguments, function* listSegments_1() {\n      let listBlobsFlatSegmentResponse;\n\n      if (!!marker || marker === undefined) {\n        do {\n          listBlobsFlatSegmentResponse = yield __await(this.listBlobFlatSegment(marker, options));\n          marker = listBlobsFlatSegmentResponse.continuationToken;\n          yield yield __await(yield __await(listBlobsFlatSegmentResponse));\n        } while (marker);\n      }\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator of {@link BlobItem} objects\n   *\n   * @param options - Options to list blobs operation.\n   */\n\n\n  listItems(options = {}) {\n    return __asyncGenerator(this, arguments, function* listItems_1() {\n      var e_1, _a;\n\n      let marker;\n\n      try {\n        for (var _b = __asyncValues(this.listSegments(marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n          const listBlobsFlatSegmentResponse = _c.value;\n          yield __await(yield* __asyncDelegator(__asyncValues(listBlobsFlatSegmentResponse.segment.blobItems)));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  /**\n   * Returns an async iterable iterator to list all the blobs\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * // Get the containerClient before you run these snippets,\n   * // Can be obtained from `blobServiceClient.getContainerClient(\"<your-container-name>\");`\n   * let i = 1;\n   * for await (const blob of containerClient.listBlobsFlat()) {\n   *   console.log(`Blob ${i++}: ${blob.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * let iter = containerClient.listBlobsFlat();\n   * let blobItem = await iter.next();\n   * while (!blobItem.done) {\n   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n   *   blobItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of containerClient.listBlobsFlat().byPage({ maxPageSize: 20 })) {\n   *   for (const blob of response.segment.blobItems) {\n   *     console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = containerClient.listBlobsFlat().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 blob names\n   * for (const blob of response.segment.blobItems) {\n   *   console.log(`Blob ${i++}: ${blob.name}`);\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   *\n   * // Passing next marker as continuationToken\n   *\n   * iterator = containerClient.listBlobsFlat().byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 blob names\n   * for (const blob of response.segment.blobItems) {\n   *   console.log(`Blob ${i++}: ${blob.name}`);\n   * }\n   * ```\n   *\n   * @param options - Options to list blobs.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n\n\n  listBlobsFlat(options = {}) {\n    const include = [];\n\n    if (options.includeCopy) {\n      include.push(\"copy\");\n    }\n\n    if (options.includeDeleted) {\n      include.push(\"deleted\");\n    }\n\n    if (options.includeMetadata) {\n      include.push(\"metadata\");\n    }\n\n    if (options.includeSnapshots) {\n      include.push(\"snapshots\");\n    }\n\n    if (options.includeVersions) {\n      include.push(\"versions\");\n    }\n\n    if (options.includeUncommitedBlobs) {\n      include.push(\"uncommittedblobs\");\n    }\n\n    if (options.includeTags) {\n      include.push(\"tags\");\n    }\n\n    if (options.includeDeletedWithVersions) {\n      include.push(\"deletedwithversions\");\n    }\n\n    if (options.includeImmutabilityPolicy) {\n      include.push(\"immutabilitypolicy\");\n    }\n\n    if (options.includeLegalHold) {\n      include.push(\"legalhold\");\n    }\n\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    const updatedOptions = Object.assign(Object.assign({}, options), include.length > 0 ? {\n      include: include\n    } : {}); // AsyncIterableIterator to iterate over blobs\n\n    const iter = this.listItems(updatedOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings = {}) => {\n        return this.listSegments(settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, updatedOptions));\n      }\n    };\n  }\n  /**\n   * Returns an AsyncIterableIterator for ContainerListBlobHierarchySegmentResponse\n   *\n   * @param delimiter - The character or string used to define the virtual hierarchy\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the ContinuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The ContinuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to list blobs operation.\n   */\n\n\n  listHierarchySegments(delimiter, marker, options = {}) {\n    return __asyncGenerator(this, arguments, function* listHierarchySegments_1() {\n      let listBlobsHierarchySegmentResponse;\n\n      if (!!marker || marker === undefined) {\n        do {\n          listBlobsHierarchySegmentResponse = yield __await(this.listBlobHierarchySegment(delimiter, marker, options));\n          marker = listBlobsHierarchySegmentResponse.continuationToken;\n          yield yield __await(yield __await(listBlobsHierarchySegmentResponse));\n        } while (marker);\n      }\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator for {@link BlobPrefix} and {@link BlobItem} objects.\n   *\n   * @param delimiter - The character or string used to define the virtual hierarchy\n   * @param options - Options to list blobs operation.\n   */\n\n\n  listItemsByHierarchy(delimiter, options = {}) {\n    return __asyncGenerator(this, arguments, function* listItemsByHierarchy_1() {\n      var e_2, _a;\n\n      let marker;\n\n      try {\n        for (var _b = __asyncValues(this.listHierarchySegments(delimiter, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n          const listBlobsHierarchySegmentResponse = _c.value;\n          const segment = listBlobsHierarchySegmentResponse.segment;\n\n          if (segment.blobPrefixes) {\n            for (const prefix of segment.blobPrefixes) {\n              yield yield __await(Object.assign({\n                kind: \"prefix\"\n              }, prefix));\n            }\n          }\n\n          for (const blob of segment.blobItems) {\n            yield yield __await(Object.assign({\n              kind: \"blob\"\n            }, blob));\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n  /**\n   * Returns an async iterable iterator to list all the blobs by hierarchy.\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs by hierarchy in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * for await (const item of containerClient.listBlobsByHierarchy(\"/\")) {\n   *   if (item.kind === \"prefix\") {\n   *     console.log(`\\tBlobPrefix: ${item.name}`);\n   *   } else {\n   *     console.log(`\\tBlobItem: name - ${item.name}, last modified - ${item.properties.lastModified}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let iter = containerClient.listBlobsByHierarchy(\"/\", { prefix: \"prefix1/\" });\n   * let entity = await iter.next();\n   * while (!entity.done) {\n   *   let item = entity.value;\n   *   if (item.kind === \"prefix\") {\n   *     console.log(`\\tBlobPrefix: ${item.name}`);\n   *   } else {\n   *     console.log(`\\tBlobItem: name - ${item.name}, last modified - ${item.properties.lastModified}`);\n   *   }\n   *   entity = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * console.log(\"Listing blobs by hierarchy by page\");\n   * for await (const response of containerClient.listBlobsByHierarchy(\"/\").byPage()) {\n   *   const segment = response.segment;\n   *   if (segment.blobPrefixes) {\n   *     for (const prefix of segment.blobPrefixes) {\n   *       console.log(`\\tBlobPrefix: ${prefix.name}`);\n   *     }\n   *   }\n   *   for (const blob of response.segment.blobItems) {\n   *     console.log(`\\tBlobItem: name - ${blob.name}, last modified - ${blob.properties.lastModified}`);\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a max page size:\n   *\n   * ```js\n   * console.log(\"Listing blobs by hierarchy by page, specifying a prefix and a max page size\");\n   *\n   * let i = 1;\n   * for await (const response of containerClient.listBlobsByHierarchy(\"/\", { prefix: \"prefix2/sub1/\"}).byPage({ maxPageSize: 2 })) {\n   *   console.log(`Page ${i++}`);\n   *   const segment = response.segment;\n   *\n   *   if (segment.blobPrefixes) {\n   *     for (const prefix of segment.blobPrefixes) {\n   *       console.log(`\\tBlobPrefix: ${prefix.name}`);\n   *     }\n   *   }\n   *\n   *   for (const blob of response.segment.blobItems) {\n   *     console.log(`\\tBlobItem: name - ${blob.name}, last modified - ${blob.properties.lastModified}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param delimiter - The character or string used to define the virtual hierarchy\n   * @param options - Options to list blobs operation.\n   */\n\n\n  listBlobsByHierarchy(delimiter, options = {}) {\n    if (delimiter === \"\") {\n      throw new RangeError(\"delimiter should contain one or more characters\");\n    }\n\n    const include = [];\n\n    if (options.includeCopy) {\n      include.push(\"copy\");\n    }\n\n    if (options.includeDeleted) {\n      include.push(\"deleted\");\n    }\n\n    if (options.includeMetadata) {\n      include.push(\"metadata\");\n    }\n\n    if (options.includeSnapshots) {\n      include.push(\"snapshots\");\n    }\n\n    if (options.includeVersions) {\n      include.push(\"versions\");\n    }\n\n    if (options.includeUncommitedBlobs) {\n      include.push(\"uncommittedblobs\");\n    }\n\n    if (options.includeTags) {\n      include.push(\"tags\");\n    }\n\n    if (options.includeDeletedWithVersions) {\n      include.push(\"deletedwithversions\");\n    }\n\n    if (options.includeImmutabilityPolicy) {\n      include.push(\"immutabilitypolicy\");\n    }\n\n    if (options.includeLegalHold) {\n      include.push(\"legalhold\");\n    }\n\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    const updatedOptions = Object.assign(Object.assign({}, options), include.length > 0 ? {\n      include: include\n    } : {}); // AsyncIterableIterator to iterate over blob prefixes and blobs\n\n    const iter = this.listItemsByHierarchy(delimiter, updatedOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return _asyncToGenerator(function* () {\n          return iter.next();\n        })();\n      },\n\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings = {}) => {\n        return this.listHierarchySegments(delimiter, settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, updatedOptions));\n      }\n    };\n  }\n\n  getContainerNameFromUrl() {\n    let containerName;\n\n    try {\n      //  URL may look like the following\n      // \"https://myaccount.blob.core.windows.net/mycontainer?sasString\";\n      // \"https://myaccount.blob.core.windows.net/mycontainer\";\n      // IPv4/IPv6 address hosts, Endpoints - `http://127.0.0.1:10000/devstoreaccount1/containername`\n      // http://localhost:10001/devstoreaccount1/containername\n      const parsedUrl = URLBuilder.parse(this.url);\n\n      if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n        // \"https://myaccount.blob.core.windows.net/containername\".\n        // \"https://customdomain.com/containername\".\n        // .getPath() -> /containername\n        containerName = parsedUrl.getPath().split(\"/\")[1];\n      } else if (isIpEndpointStyle(parsedUrl)) {\n        // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/containername\n        // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/containername\n        // .getPath() -> /devstoreaccount1/containername\n        containerName = parsedUrl.getPath().split(\"/\")[2];\n      } else {\n        // \"https://customdomain.com/containername\".\n        // .getPath() -> /containername\n        containerName = parsedUrl.getPath().split(\"/\")[1];\n      } // decode the encoded containerName - to get all the special characters that might be present in it\n\n\n      containerName = decodeURIComponent(containerName);\n\n      if (!containerName) {\n        throw new Error(\"Provided containerName is invalid.\");\n      }\n\n      return containerName;\n    } catch (error) {\n      throw new Error(\"Unable to extract containerName with provided information.\");\n    }\n  }\n  /**\n   * Only available for ContainerClient constructed with a shared key credential.\n   *\n   * Generates a Blob Container Service Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n   *\n   * @param options - Optional parameters.\n   * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n\n\n  generateSasUrl(options) {\n    return new Promise(resolve => {\n      if (!(this.credential instanceof StorageSharedKeyCredential)) {\n        throw new RangeError(\"Can only generate the SAS when the client is initialized with a shared key credential\");\n      }\n\n      const sas = generateBlobSASQueryParameters(Object.assign({\n        containerName: this._containerName\n      }, options), this.credential).toString();\n      resolve(appendToURLQuery(this.url, sas));\n    });\n  }\n  /**\n   * Creates a BlobBatchClient object to conduct batch operations.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch\n   *\n   * @returns A new BlobBatchClient object for this container.\n   */\n\n\n  getBlobBatchClient() {\n    return new BlobBatchClient(this.url, this.pipeline);\n  }\n\n} //# sourceMappingURL=ContainerClient.js.map","map":{"version":3,"sources":["F:/statvalu/project/AR_DocuExpert_Test/node_modules/@azure/storage-blob/dist-esm/storage-blob/src/ContainerClient.js"],"names":["__asyncDelegator","__asyncGenerator","__asyncValues","__await","getDefaultProxySettings","isNode","isTokenCredential","URLBuilder","SpanStatusCode","AnonymousCredential","StorageSharedKeyCredential","Container","newPipeline","isPipelineLike","StorageClient","convertTracingToRequestOptionsBase","createSpan","appendToURLPath","appendToURLQuery","extractConnectionStringParts","isIpEndpointStyle","parseObjectReplicationRecord","toTags","truncatedISO8061Date","generateBlobSASQueryParameters","BlobLeaseClient","AppendBlobClient","BlobClient","BlockBlobClient","PageBlobClient","BlobBatchClient","ContainerClient","constructor","urlOrConnectionString","credentialOrPipelineOrContainerName","options","pipeline","url","containerName","extractedCreds","kind","sharedKeyCredential","accountName","accountKey","encodeURIComponent","proxyOptions","proxyUri","Error","accountSas","_containerName","getContainerNameFromUrl","containerContext","storageClientContext","create","span","updatedOptions","Object","assign","e","setStatus","code","ERROR","message","end","createIfNotExists","_a","_b","res","succeeded","_response","details","errorCode","response","parsedHeaders","exists","getProperties","abortSignal","tracingOptions","statusCode","getBlobClient","blobName","getAppendBlobClient","getBlockBlobClient","getPageBlobClient","conditions","delete","leaseAccessConditions","modifiedAccessConditions","deleteIfExists","setMetadata","metadata","ifUnmodifiedSince","RangeError","getAccessPolicy","blobPublicAccess","date","etag","lastModified","requestId","clientRequestId","signedIdentifiers","version","identifier","accessPolicy","undefined","permissions","expiresOn","Date","startsOn","push","id","setAccessPolicy","access","containerAcl","acl","getBlobLeaseClient","proposeLeaseId","uploadBlockBlob","body","contentLength","blockBlobClient","upload","deleteBlob","blobClient","versionId","withVersion","listBlobFlatSegment","marker","wrappedResponse","segment","blobItems","map","blobItemInteral","blobItem","tags","blobTags","objectReplicationSourceProperties","objectReplicationMetadata","listBlobHierarchySegment","delimiter","listSegments","arguments","listSegments_1","listBlobsFlatSegmentResponse","continuationToken","listItems","listItems_1","e_1","_c","next","done","value","e_1_1","error","return","call","listBlobsFlat","include","includeCopy","includeDeleted","includeMetadata","includeSnapshots","includeVersions","includeUncommitedBlobs","includeTags","includeDeletedWithVersions","includeImmutabilityPolicy","includeLegalHold","prefix","length","iter","Symbol","asyncIterator","byPage","settings","maxPageSize","listHierarchySegments","listHierarchySegments_1","listBlobsHierarchySegmentResponse","listItemsByHierarchy","listItemsByHierarchy_1","e_2","blobPrefixes","blob","e_2_1","listBlobsByHierarchy","parsedUrl","parse","getHost","split","getPath","decodeURIComponent","generateSasUrl","Promise","resolve","credential","sas","toString","getBlobBatchClient"],"mappings":"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","sourcesContent":["import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { getDefaultProxySettings, isNode, isTokenCredential, URLBuilder } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { Container } from \"./generated/src/operations\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { StorageClient } from \"./StorageClient\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport { appendToURLPath, appendToURLQuery, extractConnectionStringParts, isIpEndpointStyle, parseObjectReplicationRecord, toTags, truncatedISO8061Date } from \"./utils/utils.common\";\nimport { generateBlobSASQueryParameters } from \"./sas/BlobSASSignatureValues\";\nimport { BlobLeaseClient } from \"./BlobLeaseClient\";\nimport { AppendBlobClient, BlobClient, BlockBlobClient, PageBlobClient } from \"./Clients\";\nimport { BlobBatchClient } from \"./BlobBatchClient\";\n/**\n * A ContainerClient represents a URL to the Azure Storage container allowing you to manipulate its blobs.\n */\nexport class ContainerClient extends StorageClient {\n    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, \n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options) {\n        let pipeline;\n        let url;\n        options = options || {};\n        if (isPipelineLike(credentialOrPipelineOrContainerName)) {\n            // (url: string, pipeline: Pipeline)\n            url = urlOrConnectionString;\n            pipeline = credentialOrPipelineOrContainerName;\n        }\n        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||\n            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||\n            isTokenCredential(credentialOrPipelineOrContainerName)) {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            url = urlOrConnectionString;\n            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);\n        }\n        else if (!credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName !== \"string\") {\n            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)\n            // The second parameter is undefined. Use anonymous credential.\n            url = urlOrConnectionString;\n            pipeline = newPipeline(new AnonymousCredential(), options);\n        }\n        else if (credentialOrPipelineOrContainerName &&\n            typeof credentialOrPipelineOrContainerName === \"string\") {\n            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)\n            const containerName = credentialOrPipelineOrContainerName;\n            const extractedCreds = extractConnectionStringParts(urlOrConnectionString);\n            if (extractedCreds.kind === \"AccountConnString\") {\n                if (isNode) {\n                    const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n                    url = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName));\n                    options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n                    pipeline = newPipeline(sharedKeyCredential, options);\n                }\n                else {\n                    throw new Error(\"Account connection string is only supported in Node.js environment\");\n                }\n            }\n            else if (extractedCreds.kind === \"SASConnString\") {\n                url =\n                    appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)) +\n                        \"?\" +\n                        extractedCreds.accountSas;\n                pipeline = newPipeline(new AnonymousCredential(), options);\n            }\n            else {\n                throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n            }\n        }\n        else {\n            throw new Error(\"Expecting non-empty strings for containerName parameter\");\n        }\n        super(url, pipeline);\n        this._containerName = this.getContainerNameFromUrl();\n        this.containerContext = new Container(this.storageClientContext);\n    }\n    /**\n     * The name of the container.\n     */\n    get containerName() {\n        return this._containerName;\n    }\n    /**\n     * Creates a new container under the specified account. If the container with\n     * the same name already exists, the operation fails.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n     *\n     * @param options - Options to Container Create operation.\n     *\n     *\n     * Example usage:\n     *\n     * ```js\n     * const containerClient = blobServiceClient.getContainerClient(\"<container name>\");\n     * const createContainerResponse = await containerClient.create();\n     * console.log(\"Container was created successfully\", createContainerResponse.requestId);\n     * ```\n     */\n    async create(options = {}) {\n        const { span, updatedOptions } = createSpan(\"ContainerClient-create\", options);\n        try {\n            // Spread operator in destructuring assignments,\n            // this will filter out unwanted properties from the response object into result object\n            return await this.containerContext.create(Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Creates a new container under the specified account. If the container with\n     * the same name already exists, it is not changed.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n     *\n     * @param options -\n     */\n    async createIfNotExists(options = {}) {\n        var _a, _b;\n        const { span, updatedOptions } = createSpan(\"ContainerClient-createIfNotExists\", options);\n        try {\n            const res = await this.create(updatedOptions);\n            return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response // _response is made non-enumerable\n             });\n        }\n        catch (e) {\n            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"ContainerAlreadyExists\") {\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: \"Expected exception when creating a container only if it does not already exist.\"\n                });\n                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });\n            }\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns true if the Azure container resource represented by this client exists; false otherwise.\n     *\n     * NOTE: use this function with care since an existing container might be deleted by other clients or\n     * applications. Vice versa new containers with the same name might be added by other clients or\n     * applications after this function completes.\n     *\n     * @param options -\n     */\n    async exists(options = {}) {\n        const { span, updatedOptions } = createSpan(\"ContainerClient-exists\", options);\n        try {\n            await this.getProperties({\n                abortSignal: options.abortSignal,\n                tracingOptions: updatedOptions.tracingOptions\n            });\n            return true;\n        }\n        catch (e) {\n            if (e.statusCode === 404) {\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: \"Expected exception when checking container existence\"\n                });\n                return false;\n            }\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Creates a {@link BlobClient}\n     *\n     * @param blobName - A blob name\n     * @returns A new BlobClient object for the given blob name.\n     */\n    getBlobClient(blobName) {\n        return new BlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);\n    }\n    /**\n     * Creates an {@link AppendBlobClient}\n     *\n     * @param blobName - An append blob name\n     */\n    getAppendBlobClient(blobName) {\n        return new AppendBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);\n    }\n    /**\n     * Creates a {@link BlockBlobClient}\n     *\n     * @param blobName - A block blob name\n     *\n     *\n     * Example usage:\n     *\n     * ```js\n     * const content = \"Hello world!\";\n     *\n     * const blockBlobClient = containerClient.getBlockBlobClient(\"<blob name>\");\n     * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);\n     * ```\n     */\n    getBlockBlobClient(blobName) {\n        return new BlockBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);\n    }\n    /**\n     * Creates a {@link PageBlobClient}\n     *\n     * @param blobName - A page blob name\n     */\n    getPageBlobClient(blobName) {\n        return new PageBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);\n    }\n    /**\n     * Returns all user-defined metadata and system properties for the specified\n     * container. The data returned does not include the container's list of blobs.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-properties\n     *\n     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if\n     * they originally contained uppercase characters. This differs from the metadata keys returned by\n     * the `listContainers` method of {@link BlobServiceClient} using the `includeMetadata` option, which\n     * will retain their original casing.\n     *\n     * @param options - Options to Container Get Properties operation.\n     */\n    async getProperties(options = {}) {\n        if (!options.conditions) {\n            options.conditions = {};\n        }\n        const { span, updatedOptions } = createSpan(\"ContainerClient-getProperties\", options);\n        try {\n            return await this.containerContext.getProperties(Object.assign(Object.assign({ abortSignal: options.abortSignal }, options.conditions), convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Marks the specified container for deletion. The container and any blobs\n     * contained within it are later deleted during garbage collection.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n     *\n     * @param options - Options to Container Delete operation.\n     */\n    async delete(options = {}) {\n        if (!options.conditions) {\n            options.conditions = {};\n        }\n        const { span, updatedOptions } = createSpan(\"ContainerClient-delete\", options);\n        try {\n            return await this.containerContext.delete(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, modifiedAccessConditions: options.conditions }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Marks the specified container for deletion if it exists. The container and any blobs\n     * contained within it are later deleted during garbage collection.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container\n     *\n     * @param options - Options to Container Delete operation.\n     */\n    async deleteIfExists(options = {}) {\n        var _a, _b;\n        const { span, updatedOptions } = createSpan(\"ContainerClient-deleteIfExists\", options);\n        try {\n            const res = await this.delete(updatedOptions);\n            return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response // _response is made non-enumerable\n             });\n        }\n        catch (e) {\n            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === \"ContainerNotFound\") {\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: \"Expected exception when deleting a container only if it exists.\"\n                });\n                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });\n            }\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets one or more user-defined name-value pairs for the specified container.\n     *\n     * If no option provided, or no metadata defined in the parameter, the container\n     * metadata will be removed.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-metadata\n     *\n     * @param metadata - Replace existing metadata with this value.\n     *                            If no value provided the existing metadata will be removed.\n     * @param options - Options to Container Set Metadata operation.\n     */\n    async setMetadata(metadata, options = {}) {\n        if (!options.conditions) {\n            options.conditions = {};\n        }\n        if (options.conditions.ifUnmodifiedSince) {\n            throw new RangeError(\"the IfUnmodifiedSince must have their default values because they are ignored by the blob service\");\n        }\n        const { span, updatedOptions } = createSpan(\"ContainerClient-setMetadata\", options);\n        try {\n            return await this.containerContext.setMetadata(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions, metadata, modifiedAccessConditions: options.conditions }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Gets the permissions for the specified container. The permissions indicate\n     * whether container data may be accessed publicly.\n     *\n     * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.\n     * For example, new Date(\"2018-12-31T03:44:23.8827891Z\").toISOString() will get \"2018-12-31T03:44:23.882Z\".\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-acl\n     *\n     * @param options - Options to Container Get Access Policy operation.\n     */\n    async getAccessPolicy(options = {}) {\n        if (!options.conditions) {\n            options.conditions = {};\n        }\n        const { span, updatedOptions } = createSpan(\"ContainerClient-getAccessPolicy\", options);\n        try {\n            const response = await this.containerContext.getAccessPolicy(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.conditions }, convertTracingToRequestOptionsBase(updatedOptions)));\n            const res = {\n                _response: response._response,\n                blobPublicAccess: response.blobPublicAccess,\n                date: response.date,\n                etag: response.etag,\n                errorCode: response.errorCode,\n                lastModified: response.lastModified,\n                requestId: response.requestId,\n                clientRequestId: response.clientRequestId,\n                signedIdentifiers: [],\n                version: response.version\n            };\n            for (const identifier of response) {\n                let accessPolicy = undefined;\n                if (identifier.accessPolicy) {\n                    accessPolicy = {\n                        permissions: identifier.accessPolicy.permissions\n                    };\n                    if (identifier.accessPolicy.expiresOn) {\n                        accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);\n                    }\n                    if (identifier.accessPolicy.startsOn) {\n                        accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);\n                    }\n                }\n                res.signedIdentifiers.push({\n                    accessPolicy,\n                    id: identifier.id\n                });\n            }\n            return res;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Sets the permissions for the specified container. The permissions indicate\n     * whether blobs in a container may be accessed publicly.\n     *\n     * When you set permissions for a container, the existing permissions are replaced.\n     * If no access or containerAcl provided, the existing container ACL will be\n     * removed.\n     *\n     * When you establish a stored access policy on a container, it may take up to 30 seconds to take effect.\n     * During this interval, a shared access signature that is associated with the stored access policy will\n     * fail with status code 403 (Forbidden), until the access policy becomes active.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-acl\n     *\n     * @param access - The level of public access to data in the container.\n     * @param containerAcl - Array of elements each having a unique Id and details of the access policy.\n     * @param options - Options to Container Set Access Policy operation.\n     */\n    async setAccessPolicy(access, containerAcl, options = {}) {\n        options.conditions = options.conditions || {};\n        const { span, updatedOptions } = createSpan(\"ContainerClient-setAccessPolicy\", options);\n        try {\n            const acl = [];\n            for (const identifier of containerAcl || []) {\n                acl.push({\n                    accessPolicy: {\n                        expiresOn: identifier.accessPolicy.expiresOn\n                            ? truncatedISO8061Date(identifier.accessPolicy.expiresOn)\n                            : \"\",\n                        permissions: identifier.accessPolicy.permissions,\n                        startsOn: identifier.accessPolicy.startsOn\n                            ? truncatedISO8061Date(identifier.accessPolicy.startsOn)\n                            : \"\"\n                    },\n                    id: identifier.id\n                });\n            }\n            return await this.containerContext.setAccessPolicy(Object.assign({ abortSignal: options.abortSignal, access, containerAcl: acl, leaseAccessConditions: options.conditions, modifiedAccessConditions: options.conditions }, convertTracingToRequestOptionsBase(updatedOptions)));\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Get a {@link BlobLeaseClient} that manages leases on the container.\n     *\n     * @param proposeLeaseId - Initial proposed lease Id.\n     * @returns A new BlobLeaseClient object for managing leases on the container.\n     */\n    getBlobLeaseClient(proposeLeaseId) {\n        return new BlobLeaseClient(this, proposeLeaseId);\n    }\n    /**\n     * Creates a new block blob, or updates the content of an existing block blob.\n     *\n     * Updating an existing block blob overwrites any existing metadata on the blob.\n     * Partial updates are not supported; the content of the existing blob is\n     * overwritten with the new content. To perform a partial update of a block blob's,\n     * use {@link BlockBlobClient.stageBlock} and {@link BlockBlobClient.commitBlockList}.\n     *\n     * This is a non-parallel uploading method, please use {@link BlockBlobClient.uploadFile},\n     * {@link BlockBlobClient.uploadStream} or {@link BlockBlobClient.uploadBrowserData} for better\n     * performance with concurrency uploading.\n     *\n     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n     *\n     * @param blobName - Name of the block blob to create or update.\n     * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function\n     *                               which returns a new Readable stream whose offset is from data source beginning.\n     * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a\n     *                               string including non non-Base64/Hex-encoded characters.\n     * @param options - Options to configure the Block Blob Upload operation.\n     * @returns Block Blob upload response data and the corresponding BlockBlobClient instance.\n     */\n    async uploadBlockBlob(blobName, body, contentLength, options = {}) {\n        const { span, updatedOptions } = createSpan(\"ContainerClient-uploadBlockBlob\", options);\n        try {\n            const blockBlobClient = this.getBlockBlobClient(blobName);\n            const response = await blockBlobClient.upload(body, contentLength, updatedOptions);\n            return {\n                blockBlobClient,\n                response\n            };\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Marks the specified blob or snapshot for deletion. The blob is later deleted\n     * during garbage collection. Note that in order to delete a blob, you must delete\n     * all of its snapshots. You can delete both at the same time with the Delete\n     * Blob operation.\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n     *\n     * @param blobName -\n     * @param options - Options to Blob Delete operation.\n     * @returns Block blob deletion response data.\n     */\n    async deleteBlob(blobName, options = {}) {\n        const { span, updatedOptions } = createSpan(\"ContainerClient-deleteBlob\", options);\n        try {\n            let blobClient = this.getBlobClient(blobName);\n            if (options.versionId) {\n                blobClient = blobClient.withVersion(options.versionId);\n            }\n            return await blobClient.delete(updatedOptions);\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * listBlobFlatSegment returns a single segment of blobs starting from the\n     * specified Marker. Use an empty Marker to start enumeration from the beginning.\n     * After getting a segment, process it, and then call listBlobsFlatSegment again\n     * (passing the the previously-returned Marker) to get the next segment.\n     * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n     *\n     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n     * @param options - Options to Container List Blob Flat Segment operation.\n     */\n    async listBlobFlatSegment(marker, options = {}) {\n        const { span, updatedOptions } = createSpan(\"ContainerClient-listBlobFlatSegment\", options);\n        try {\n            const response = await this.containerContext.listBlobFlatSegment(Object.assign(Object.assign({ marker }, options), convertTracingToRequestOptionsBase(updatedOptions)));\n            const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, segment: Object.assign(Object.assign({}, response.segment), { blobItems: response.segment.blobItems.map((blobItemInteral) => {\n                        const blobItem = Object.assign(Object.assign({}, blobItemInteral), { tags: toTags(blobItemInteral.blobTags), objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInteral.objectReplicationMetadata) });\n                        return blobItem;\n                    }) }) });\n            return wrappedResponse;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * listBlobHierarchySegment returns a single segment of blobs starting from\n     * the specified Marker. Use an empty Marker to start enumeration from the\n     * beginning. After getting a segment, process it, and then call listBlobsHierarchicalSegment\n     * again (passing the the previously-returned Marker) to get the next segment.\n     * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs\n     *\n     * @param delimiter - The character or string used to define the virtual hierarchy\n     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.\n     * @param options - Options to Container List Blob Hierarchy Segment operation.\n     */\n    async listBlobHierarchySegment(delimiter, marker, options = {}) {\n        const { span, updatedOptions } = createSpan(\"ContainerClient-listBlobHierarchySegment\", options);\n        try {\n            const response = await this.containerContext.listBlobHierarchySegment(delimiter, Object.assign(Object.assign({ marker }, options), convertTracingToRequestOptionsBase(updatedOptions)));\n            const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, segment: Object.assign(Object.assign({}, response.segment), { blobItems: response.segment.blobItems.map((blobItemInteral) => {\n                        const blobItem = Object.assign(Object.assign({}, blobItemInteral), { tags: toTags(blobItemInteral.blobTags), objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInteral.objectReplicationMetadata) });\n                        return blobItem;\n                    }) }) });\n            return wrappedResponse;\n        }\n        catch (e) {\n            span.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: e.message\n            });\n            throw e;\n        }\n        finally {\n            span.end();\n        }\n    }\n    /**\n     * Returns an AsyncIterableIterator for ContainerListBlobFlatSegmentResponse\n     *\n     * @param marker - A string value that identifies the portion of\n     *                          the list of blobs to be returned with the next listing operation. The\n     *                          operation returns the ContinuationToken value within the response body if the\n     *                          listing operation did not return all blobs remaining to be listed\n     *                          with the current page. The ContinuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of list\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to list blobs operation.\n     */\n    listSegments(marker, options = {}) {\n        return __asyncGenerator(this, arguments, function* listSegments_1() {\n            let listBlobsFlatSegmentResponse;\n            if (!!marker || marker === undefined) {\n                do {\n                    listBlobsFlatSegmentResponse = yield __await(this.listBlobFlatSegment(marker, options));\n                    marker = listBlobsFlatSegmentResponse.continuationToken;\n                    yield yield __await(yield __await(listBlobsFlatSegmentResponse));\n                } while (marker);\n            }\n        });\n    }\n    /**\n     * Returns an AsyncIterableIterator of {@link BlobItem} objects\n     *\n     * @param options - Options to list blobs operation.\n     */\n    listItems(options = {}) {\n        return __asyncGenerator(this, arguments, function* listItems_1() {\n            var e_1, _a;\n            let marker;\n            try {\n                for (var _b = __asyncValues(this.listSegments(marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n                    const listBlobsFlatSegmentResponse = _c.value;\n                    yield __await(yield* __asyncDelegator(__asyncValues(listBlobsFlatSegmentResponse.segment.blobItems)));\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        });\n    }\n    /**\n     * Returns an async iterable iterator to list all the blobs\n     * under the specified account.\n     *\n     * .byPage() returns an async iterable iterator to list the blobs in pages.\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * // Get the containerClient before you run these snippets,\n     * // Can be obtained from `blobServiceClient.getContainerClient(\"<your-container-name>\");`\n     * let i = 1;\n     * for await (const blob of containerClient.listBlobsFlat()) {\n     *   console.log(`Blob ${i++}: ${blob.name}`);\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let i = 1;\n     * let iter = containerClient.listBlobsFlat();\n     * let blobItem = await iter.next();\n     * while (!blobItem.done) {\n     *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n     *   blobItem = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * // passing optional maxPageSize in the page settings\n     * let i = 1;\n     * for await (const response of containerClient.listBlobsFlat().byPage({ maxPageSize: 20 })) {\n     *   for (const blob of response.segment.blobItems) {\n     *     console.log(`Blob ${i++}: ${blob.name}`);\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a marker:\n     *\n     * ```js\n     * let i = 1;\n     * let iterator = containerClient.listBlobsFlat().byPage({ maxPageSize: 2 });\n     * let response = (await iterator.next()).value;\n     *\n     * // Prints 2 blob names\n     * for (const blob of response.segment.blobItems) {\n     *   console.log(`Blob ${i++}: ${blob.name}`);\n     * }\n     *\n     * // Gets next marker\n     * let marker = response.continuationToken;\n     *\n     * // Passing next marker as continuationToken\n     *\n     * iterator = containerClient.listBlobsFlat().byPage({ continuationToken: marker, maxPageSize: 10 });\n     * response = (await iterator.next()).value;\n     *\n     * // Prints 10 blob names\n     * for (const blob of response.segment.blobItems) {\n     *   console.log(`Blob ${i++}: ${blob.name}`);\n     * }\n     * ```\n     *\n     * @param options - Options to list blobs.\n     * @returns An asyncIterableIterator that supports paging.\n     */\n    listBlobsFlat(options = {}) {\n        const include = [];\n        if (options.includeCopy) {\n            include.push(\"copy\");\n        }\n        if (options.includeDeleted) {\n            include.push(\"deleted\");\n        }\n        if (options.includeMetadata) {\n            include.push(\"metadata\");\n        }\n        if (options.includeSnapshots) {\n            include.push(\"snapshots\");\n        }\n        if (options.includeVersions) {\n            include.push(\"versions\");\n        }\n        if (options.includeUncommitedBlobs) {\n            include.push(\"uncommittedblobs\");\n        }\n        if (options.includeTags) {\n            include.push(\"tags\");\n        }\n        if (options.includeDeletedWithVersions) {\n            include.push(\"deletedwithversions\");\n        }\n        if (options.includeImmutabilityPolicy) {\n            include.push(\"immutabilitypolicy\");\n        }\n        if (options.includeLegalHold) {\n            include.push(\"legalhold\");\n        }\n        if (options.prefix === \"\") {\n            options.prefix = undefined;\n        }\n        const updatedOptions = Object.assign(Object.assign({}, options), (include.length > 0 ? { include: include } : {}));\n        // AsyncIterableIterator to iterate over blobs\n        const iter = this.listItems(updatedOptions);\n        return {\n            /**\n             * The next method, part of the iteration protocol\n             */\n            next() {\n                return iter.next();\n            },\n            /**\n             * The connection to the async iterator, part of the iteration protocol\n             */\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n            /**\n             * Return an AsyncIterableIterator that works a page at a time\n             */\n            byPage: (settings = {}) => {\n                return this.listSegments(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, updatedOptions));\n            }\n        };\n    }\n    /**\n     * Returns an AsyncIterableIterator for ContainerListBlobHierarchySegmentResponse\n     *\n     * @param delimiter - The character or string used to define the virtual hierarchy\n     * @param marker - A string value that identifies the portion of\n     *                          the list of blobs to be returned with the next listing operation. The\n     *                          operation returns the ContinuationToken value within the response body if the\n     *                          listing operation did not return all blobs remaining to be listed\n     *                          with the current page. The ContinuationToken value can be used as the value for\n     *                          the marker parameter in a subsequent call to request the next page of list\n     *                          items. The marker value is opaque to the client.\n     * @param options - Options to list blobs operation.\n     */\n    listHierarchySegments(delimiter, marker, options = {}) {\n        return __asyncGenerator(this, arguments, function* listHierarchySegments_1() {\n            let listBlobsHierarchySegmentResponse;\n            if (!!marker || marker === undefined) {\n                do {\n                    listBlobsHierarchySegmentResponse = yield __await(this.listBlobHierarchySegment(delimiter, marker, options));\n                    marker = listBlobsHierarchySegmentResponse.continuationToken;\n                    yield yield __await(yield __await(listBlobsHierarchySegmentResponse));\n                } while (marker);\n            }\n        });\n    }\n    /**\n     * Returns an AsyncIterableIterator for {@link BlobPrefix} and {@link BlobItem} objects.\n     *\n     * @param delimiter - The character or string used to define the virtual hierarchy\n     * @param options - Options to list blobs operation.\n     */\n    listItemsByHierarchy(delimiter, options = {}) {\n        return __asyncGenerator(this, arguments, function* listItemsByHierarchy_1() {\n            var e_2, _a;\n            let marker;\n            try {\n                for (var _b = __asyncValues(this.listHierarchySegments(delimiter, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n                    const listBlobsHierarchySegmentResponse = _c.value;\n                    const segment = listBlobsHierarchySegmentResponse.segment;\n                    if (segment.blobPrefixes) {\n                        for (const prefix of segment.blobPrefixes) {\n                            yield yield __await(Object.assign({ kind: \"prefix\" }, prefix));\n                        }\n                    }\n                    for (const blob of segment.blobItems) {\n                        yield yield __await(Object.assign({ kind: \"blob\" }, blob));\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        });\n    }\n    /**\n     * Returns an async iterable iterator to list all the blobs by hierarchy.\n     * under the specified account.\n     *\n     * .byPage() returns an async iterable iterator to list the blobs by hierarchy in pages.\n     *\n     * Example using `for await` syntax:\n     *\n     * ```js\n     * for await (const item of containerClient.listBlobsByHierarchy(\"/\")) {\n     *   if (item.kind === \"prefix\") {\n     *     console.log(`\\tBlobPrefix: ${item.name}`);\n     *   } else {\n     *     console.log(`\\tBlobItem: name - ${item.name}, last modified - ${item.properties.lastModified}`);\n     *   }\n     * }\n     * ```\n     *\n     * Example using `iter.next()`:\n     *\n     * ```js\n     * let iter = containerClient.listBlobsByHierarchy(\"/\", { prefix: \"prefix1/\" });\n     * let entity = await iter.next();\n     * while (!entity.done) {\n     *   let item = entity.value;\n     *   if (item.kind === \"prefix\") {\n     *     console.log(`\\tBlobPrefix: ${item.name}`);\n     *   } else {\n     *     console.log(`\\tBlobItem: name - ${item.name}, last modified - ${item.properties.lastModified}`);\n     *   }\n     *   entity = await iter.next();\n     * }\n     * ```\n     *\n     * Example using `byPage()`:\n     *\n     * ```js\n     * console.log(\"Listing blobs by hierarchy by page\");\n     * for await (const response of containerClient.listBlobsByHierarchy(\"/\").byPage()) {\n     *   const segment = response.segment;\n     *   if (segment.blobPrefixes) {\n     *     for (const prefix of segment.blobPrefixes) {\n     *       console.log(`\\tBlobPrefix: ${prefix.name}`);\n     *     }\n     *   }\n     *   for (const blob of response.segment.blobItems) {\n     *     console.log(`\\tBlobItem: name - ${blob.name}, last modified - ${blob.properties.lastModified}`);\n     *   }\n     * }\n     * ```\n     *\n     * Example using paging with a max page size:\n     *\n     * ```js\n     * console.log(\"Listing blobs by hierarchy by page, specifying a prefix and a max page size\");\n     *\n     * let i = 1;\n     * for await (const response of containerClient.listBlobsByHierarchy(\"/\", { prefix: \"prefix2/sub1/\"}).byPage({ maxPageSize: 2 })) {\n     *   console.log(`Page ${i++}`);\n     *   const segment = response.segment;\n     *\n     *   if (segment.blobPrefixes) {\n     *     for (const prefix of segment.blobPrefixes) {\n     *       console.log(`\\tBlobPrefix: ${prefix.name}`);\n     *     }\n     *   }\n     *\n     *   for (const blob of response.segment.blobItems) {\n     *     console.log(`\\tBlobItem: name - ${blob.name}, last modified - ${blob.properties.lastModified}`);\n     *   }\n     * }\n     * ```\n     *\n     * @param delimiter - The character or string used to define the virtual hierarchy\n     * @param options - Options to list blobs operation.\n     */\n    listBlobsByHierarchy(delimiter, options = {}) {\n        if (delimiter === \"\") {\n            throw new RangeError(\"delimiter should contain one or more characters\");\n        }\n        const include = [];\n        if (options.includeCopy) {\n            include.push(\"copy\");\n        }\n        if (options.includeDeleted) {\n            include.push(\"deleted\");\n        }\n        if (options.includeMetadata) {\n            include.push(\"metadata\");\n        }\n        if (options.includeSnapshots) {\n            include.push(\"snapshots\");\n        }\n        if (options.includeVersions) {\n            include.push(\"versions\");\n        }\n        if (options.includeUncommitedBlobs) {\n            include.push(\"uncommittedblobs\");\n        }\n        if (options.includeTags) {\n            include.push(\"tags\");\n        }\n        if (options.includeDeletedWithVersions) {\n            include.push(\"deletedwithversions\");\n        }\n        if (options.includeImmutabilityPolicy) {\n            include.push(\"immutabilitypolicy\");\n        }\n        if (options.includeLegalHold) {\n            include.push(\"legalhold\");\n        }\n        if (options.prefix === \"\") {\n            options.prefix = undefined;\n        }\n        const updatedOptions = Object.assign(Object.assign({}, options), (include.length > 0 ? { include: include } : {}));\n        // AsyncIterableIterator to iterate over blob prefixes and blobs\n        const iter = this.listItemsByHierarchy(delimiter, updatedOptions);\n        return {\n            /**\n             * The next method, part of the iteration protocol\n             */\n            async next() {\n                return iter.next();\n            },\n            /**\n             * The connection to the async iterator, part of the iteration protocol\n             */\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n            /**\n             * Return an AsyncIterableIterator that works a page at a time\n             */\n            byPage: (settings = {}) => {\n                return this.listHierarchySegments(delimiter, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, updatedOptions));\n            }\n        };\n    }\n    getContainerNameFromUrl() {\n        let containerName;\n        try {\n            //  URL may look like the following\n            // \"https://myaccount.blob.core.windows.net/mycontainer?sasString\";\n            // \"https://myaccount.blob.core.windows.net/mycontainer\";\n            // IPv4/IPv6 address hosts, Endpoints - `http://127.0.0.1:10000/devstoreaccount1/containername`\n            // http://localhost:10001/devstoreaccount1/containername\n            const parsedUrl = URLBuilder.parse(this.url);\n            if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n                // \"https://myaccount.blob.core.windows.net/containername\".\n                // \"https://customdomain.com/containername\".\n                // .getPath() -> /containername\n                containerName = parsedUrl.getPath().split(\"/\")[1];\n            }\n            else if (isIpEndpointStyle(parsedUrl)) {\n                // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/containername\n                // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/containername\n                // .getPath() -> /devstoreaccount1/containername\n                containerName = parsedUrl.getPath().split(\"/\")[2];\n            }\n            else {\n                // \"https://customdomain.com/containername\".\n                // .getPath() -> /containername\n                containerName = parsedUrl.getPath().split(\"/\")[1];\n            }\n            // decode the encoded containerName - to get all the special characters that might be present in it\n            containerName = decodeURIComponent(containerName);\n            if (!containerName) {\n                throw new Error(\"Provided containerName is invalid.\");\n            }\n            return containerName;\n        }\n        catch (error) {\n            throw new Error(\"Unable to extract containerName with provided information.\");\n        }\n    }\n    /**\n     * Only available for ContainerClient constructed with a shared key credential.\n     *\n     * Generates a Blob Container Service Shared Access Signature (SAS) URI based on the client properties\n     * and parameters passed in. The SAS is signed by the shared key credential of the client.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n     *\n     * @param options - Optional parameters.\n     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n     */\n    generateSasUrl(options) {\n        return new Promise((resolve) => {\n            if (!(this.credential instanceof StorageSharedKeyCredential)) {\n                throw new RangeError(\"Can only generate the SAS when the client is initialized with a shared key credential\");\n            }\n            const sas = generateBlobSASQueryParameters(Object.assign({ containerName: this._containerName }, options), this.credential).toString();\n            resolve(appendToURLQuery(this.url, sas));\n        });\n    }\n    /**\n     * Creates a BlobBatchClient object to conduct batch operations.\n     *\n     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch\n     *\n     * @returns A new BlobBatchClient object for this container.\n     */\n    getBlobBatchClient() {\n        return new BlobBatchClient(this.url, this.pipeline);\n    }\n}\n//# sourceMappingURL=ContainerClient.js.map"]},"metadata":{},"sourceType":"module"}