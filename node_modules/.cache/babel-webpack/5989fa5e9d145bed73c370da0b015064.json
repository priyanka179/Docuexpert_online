{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { shouldRetry, updateRetryData, DEFAULT_CLIENT_MAX_RETRY_INTERVAL, DEFAULT_CLIENT_RETRY_COUNT, DEFAULT_CLIENT_RETRY_INTERVAL, DEFAULT_CLIENT_MIN_RETRY_INTERVAL, isNumber } from \"../util/exponentialBackoffStrategy\";\nimport { delay } from \"../util/delay\";\nexport function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n  return {\n    create: (nextPolicy, options) => {\n      return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);\n    }\n  };\n}\n/**\n * @param retryCount - The client retry count.\n * @param retryInterval - The client retry interval, in milliseconds.\n * @param minRetryInterval - The minimum retry interval, in milliseconds.\n * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n */\n\nexport class SystemErrorRetryPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n    super(nextPolicy, options);\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.minRetryInterval = isNumber(minRetryInterval) ? minRetryInterval : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  sendRequest(request) {\n    return this._nextPolicy.sendRequest(request.clone()).catch(error => retry(this, request, error.response, error));\n  }\n\n}\n\nfunction retry(_x, _x2, _x3, _x4, _x5) {\n  return _retry.apply(this, arguments);\n} //# sourceMappingURL=systemErrorRetryPolicy.js.map\n\n\nfunction _retry() {\n  _retry = _asyncToGenerator(function* (policy, request, operationResponse, err, retryData) {\n    retryData = updateRetryData(policy, retryData, err);\n\n    function shouldPolicyRetry(_response, error) {\n      if (error && error.code && (error.code === \"ETIMEDOUT\" || error.code === \"ESOCKETTIMEDOUT\" || error.code === \"ECONNREFUSED\" || error.code === \"ECONNRESET\" || error.code === \"ENOENT\")) {\n        return true;\n      }\n\n      return false;\n    }\n\n    if (shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) {\n      // If previous operation ended with an error and the policy allows a retry, do that\n      try {\n        yield delay(retryData.retryInterval);\n        return policy._nextPolicy.sendRequest(request.clone());\n      } catch (nestedErr) {\n        return retry(policy, request, operationResponse, nestedErr, retryData);\n      }\n    } else {\n      if (err) {\n        // If the operation failed in the end, return all errors instead of just the last one\n        return Promise.reject(retryData.error);\n      }\n\n      return operationResponse;\n    }\n  });\n  return _retry.apply(this, arguments);\n}","map":{"version":3,"sources":["F:/statvalu/AR_DocuExpert_Test/node_modules/@azure/core-http/dist-esm/src/policies/systemErrorRetryPolicy.js"],"names":["BaseRequestPolicy","shouldRetry","updateRetryData","DEFAULT_CLIENT_MAX_RETRY_INTERVAL","DEFAULT_CLIENT_RETRY_COUNT","DEFAULT_CLIENT_RETRY_INTERVAL","DEFAULT_CLIENT_MIN_RETRY_INTERVAL","isNumber","delay","systemErrorRetryPolicy","retryCount","retryInterval","minRetryInterval","maxRetryInterval","create","nextPolicy","options","SystemErrorRetryPolicy","constructor","sendRequest","request","_nextPolicy","clone","catch","error","retry","response","policy","operationResponse","err","retryData","shouldPolicyRetry","_response","code","nestedErr","Promise","reject"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { shouldRetry, updateRetryData, DEFAULT_CLIENT_MAX_RETRY_INTERVAL, DEFAULT_CLIENT_RETRY_COUNT, DEFAULT_CLIENT_RETRY_INTERVAL, DEFAULT_CLIENT_MIN_RETRY_INTERVAL, isNumber } from \"../util/exponentialBackoffStrategy\";\nimport { delay } from \"../util/delay\";\nexport function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n    return {\n        create: (nextPolicy, options) => {\n            return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);\n        }\n    };\n}\n/**\n * @param retryCount - The client retry count.\n * @param retryInterval - The client retry interval, in milliseconds.\n * @param minRetryInterval - The minimum retry interval, in milliseconds.\n * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n */\nexport class SystemErrorRetryPolicy extends BaseRequestPolicy {\n    constructor(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n        super(nextPolicy, options);\n        this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n        this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n        this.minRetryInterval = isNumber(minRetryInterval)\n            ? minRetryInterval\n            : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n        this.maxRetryInterval = isNumber(maxRetryInterval)\n            ? maxRetryInterval\n            : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n    }\n    sendRequest(request) {\n        return this._nextPolicy\n            .sendRequest(request.clone())\n            .catch((error) => retry(this, request, error.response, error));\n    }\n}\nasync function retry(policy, request, operationResponse, err, retryData) {\n    retryData = updateRetryData(policy, retryData, err);\n    function shouldPolicyRetry(_response, error) {\n        if (error &&\n            error.code &&\n            (error.code === \"ETIMEDOUT\" ||\n                error.code === \"ESOCKETTIMEDOUT\" ||\n                error.code === \"ECONNREFUSED\" ||\n                error.code === \"ECONNRESET\" ||\n                error.code === \"ENOENT\")) {\n            return true;\n        }\n        return false;\n    }\n    if (shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) {\n        // If previous operation ended with an error and the policy allows a retry, do that\n        try {\n            await delay(retryData.retryInterval);\n            return policy._nextPolicy.sendRequest(request.clone());\n        }\n        catch (nestedErr) {\n            return retry(policy, request, operationResponse, nestedErr, retryData);\n        }\n    }\n    else {\n        if (err) {\n            // If the operation failed in the end, return all errors instead of just the last one\n            return Promise.reject(retryData.error);\n        }\n        return operationResponse;\n    }\n}\n//# sourceMappingURL=systemErrorRetryPolicy.js.map"]},"metadata":{},"sourceType":"module"}