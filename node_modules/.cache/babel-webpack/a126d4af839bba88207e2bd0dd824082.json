{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { delay } from \"@azure/core-http\";\nimport { Poller } from \"@azure/core-lro\";\n/**\n * This is the poller returned by {@link BlobClient.beginCopyFromURL}.\n * This can not be instantiated directly outside of this package.\n *\n * @hidden\n */\n\nexport class BlobBeginCopyFromUrlPoller extends Poller {\n  constructor(options) {\n    const {\n      blobClient,\n      copySource,\n      intervalInMs = 15000,\n      onProgress,\n      resumeFrom,\n      startCopyFromURLOptions\n    } = options;\n    let state;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = makeBlobBeginCopyFromURLPollOperation(Object.assign(Object.assign({}, state), {\n      blobClient,\n      copySource,\n      startCopyFromURLOptions\n    }));\n    super(operation);\n\n    if (typeof onProgress === \"function\") {\n      this.onProgress(onProgress);\n    }\n\n    this.intervalInMs = intervalInMs;\n  }\n\n  delay() {\n    return delay(this.intervalInMs);\n  }\n\n}\n/**\n * Note: Intentionally using function expression over arrow function expression\n * so that the function can be invoked with a different context.\n * This affects what `this` refers to.\n * @hidden\n */\n\nconst cancel = /*#__PURE__*/function () {\n  var _cancel = _asyncToGenerator(function* (options = {}) {\n    const state = this.state;\n    const {\n      copyId\n    } = state;\n\n    if (state.isCompleted) {\n      return makeBlobBeginCopyFromURLPollOperation(state);\n    }\n\n    if (!copyId) {\n      state.isCancelled = true;\n      return makeBlobBeginCopyFromURLPollOperation(state);\n    } // if abortCopyFromURL throws, it will bubble up to user's poller.cancelOperation call\n\n\n    yield state.blobClient.abortCopyFromURL(copyId, {\n      abortSignal: options.abortSignal\n    });\n    state.isCancelled = true;\n    return makeBlobBeginCopyFromURLPollOperation(state);\n  });\n\n  function cancel() {\n    return _cancel.apply(this, arguments);\n  }\n\n  return cancel;\n}();\n/**\n * Note: Intentionally using function expression over arrow function expression\n * so that the function can be invoked with a different context.\n * This affects what `this` refers to.\n * @hidden\n */\n\n\nconst update = /*#__PURE__*/function () {\n  var _update = _asyncToGenerator(function* (options = {}) {\n    const state = this.state;\n    const {\n      blobClient,\n      copySource,\n      startCopyFromURLOptions\n    } = state;\n\n    if (!state.isStarted) {\n      state.isStarted = true;\n      const result = yield blobClient.startCopyFromURL(copySource, startCopyFromURLOptions); // copyId is needed to abort\n\n      state.copyId = result.copyId;\n\n      if (result.copyStatus === \"success\") {\n        state.result = result;\n        state.isCompleted = true;\n      }\n    } else if (!state.isCompleted) {\n      try {\n        const result = yield state.blobClient.getProperties({\n          abortSignal: options.abortSignal\n        });\n        const {\n          copyStatus,\n          copyProgress\n        } = result;\n        const prevCopyProgress = state.copyProgress;\n\n        if (copyProgress) {\n          state.copyProgress = copyProgress;\n        }\n\n        if (copyStatus === \"pending\" && copyProgress !== prevCopyProgress && typeof options.fireProgress === \"function\") {\n          // trigger in setTimeout, or swallow error?\n          options.fireProgress(state);\n        } else if (copyStatus === \"success\") {\n          state.result = result;\n          state.isCompleted = true;\n        } else if (copyStatus === \"failed\") {\n          state.error = new Error(`Blob copy failed with reason: \"${result.copyStatusDescription || \"unknown\"}\"`);\n          state.isCompleted = true;\n        }\n      } catch (err) {\n        state.error = err;\n        state.isCompleted = true;\n      }\n    }\n\n    return makeBlobBeginCopyFromURLPollOperation(state);\n  });\n\n  function update() {\n    return _update.apply(this, arguments);\n  }\n\n  return update;\n}();\n/**\n * Note: Intentionally using function expression over arrow function expression\n * so that the function can be invoked with a different context.\n * This affects what `this` refers to.\n * @hidden\n */\n\n\nconst toString = function toString() {\n  return JSON.stringify({\n    state: this.state\n  }, (key, value) => {\n    // remove blobClient from serialized state since a client can't be hydrated from this info.\n    if (key === \"blobClient\") {\n      return undefined;\n    }\n\n    return value;\n  });\n};\n/**\n * Creates a poll operation given the provided state.\n * @hidden\n */\n\n\nfunction makeBlobBeginCopyFromURLPollOperation(state) {\n  return {\n    state: Object.assign({}, state),\n    cancel,\n    toString,\n    update\n  };\n} //# sourceMappingURL=BlobStartCopyFromUrlPoller.js.map","map":{"version":3,"sources":["F:/statvalu/AR_DocuExpert_Test/node_modules/@azure/storage-blob/dist-esm/storage-blob/src/pollers/BlobStartCopyFromUrlPoller.js"],"names":["delay","Poller","BlobBeginCopyFromUrlPoller","constructor","options","blobClient","copySource","intervalInMs","onProgress","resumeFrom","startCopyFromURLOptions","state","JSON","parse","operation","makeBlobBeginCopyFromURLPollOperation","Object","assign","cancel","copyId","isCompleted","isCancelled","abortCopyFromURL","abortSignal","update","isStarted","result","startCopyFromURL","copyStatus","getProperties","copyProgress","prevCopyProgress","fireProgress","error","Error","copyStatusDescription","err","toString","stringify","key","value","undefined"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { delay } from \"@azure/core-http\";\nimport { Poller } from \"@azure/core-lro\";\n/**\n * This is the poller returned by {@link BlobClient.beginCopyFromURL}.\n * This can not be instantiated directly outside of this package.\n *\n * @hidden\n */\nexport class BlobBeginCopyFromUrlPoller extends Poller {\n    constructor(options) {\n        const { blobClient, copySource, intervalInMs = 15000, onProgress, resumeFrom, startCopyFromURLOptions } = options;\n        let state;\n        if (resumeFrom) {\n            state = JSON.parse(resumeFrom).state;\n        }\n        const operation = makeBlobBeginCopyFromURLPollOperation(Object.assign(Object.assign({}, state), { blobClient,\n            copySource,\n            startCopyFromURLOptions }));\n        super(operation);\n        if (typeof onProgress === \"function\") {\n            this.onProgress(onProgress);\n        }\n        this.intervalInMs = intervalInMs;\n    }\n    delay() {\n        return delay(this.intervalInMs);\n    }\n}\n/**\n * Note: Intentionally using function expression over arrow function expression\n * so that the function can be invoked with a different context.\n * This affects what `this` refers to.\n * @hidden\n */\nconst cancel = async function cancel(options = {}) {\n    const state = this.state;\n    const { copyId } = state;\n    if (state.isCompleted) {\n        return makeBlobBeginCopyFromURLPollOperation(state);\n    }\n    if (!copyId) {\n        state.isCancelled = true;\n        return makeBlobBeginCopyFromURLPollOperation(state);\n    }\n    // if abortCopyFromURL throws, it will bubble up to user's poller.cancelOperation call\n    await state.blobClient.abortCopyFromURL(copyId, {\n        abortSignal: options.abortSignal\n    });\n    state.isCancelled = true;\n    return makeBlobBeginCopyFromURLPollOperation(state);\n};\n/**\n * Note: Intentionally using function expression over arrow function expression\n * so that the function can be invoked with a different context.\n * This affects what `this` refers to.\n * @hidden\n */\nconst update = async function update(options = {}) {\n    const state = this.state;\n    const { blobClient, copySource, startCopyFromURLOptions } = state;\n    if (!state.isStarted) {\n        state.isStarted = true;\n        const result = await blobClient.startCopyFromURL(copySource, startCopyFromURLOptions);\n        // copyId is needed to abort\n        state.copyId = result.copyId;\n        if (result.copyStatus === \"success\") {\n            state.result = result;\n            state.isCompleted = true;\n        }\n    }\n    else if (!state.isCompleted) {\n        try {\n            const result = await state.blobClient.getProperties({ abortSignal: options.abortSignal });\n            const { copyStatus, copyProgress } = result;\n            const prevCopyProgress = state.copyProgress;\n            if (copyProgress) {\n                state.copyProgress = copyProgress;\n            }\n            if (copyStatus === \"pending\" &&\n                copyProgress !== prevCopyProgress &&\n                typeof options.fireProgress === \"function\") {\n                // trigger in setTimeout, or swallow error?\n                options.fireProgress(state);\n            }\n            else if (copyStatus === \"success\") {\n                state.result = result;\n                state.isCompleted = true;\n            }\n            else if (copyStatus === \"failed\") {\n                state.error = new Error(`Blob copy failed with reason: \"${result.copyStatusDescription || \"unknown\"}\"`);\n                state.isCompleted = true;\n            }\n        }\n        catch (err) {\n            state.error = err;\n            state.isCompleted = true;\n        }\n    }\n    return makeBlobBeginCopyFromURLPollOperation(state);\n};\n/**\n * Note: Intentionally using function expression over arrow function expression\n * so that the function can be invoked with a different context.\n * This affects what `this` refers to.\n * @hidden\n */\nconst toString = function toString() {\n    return JSON.stringify({ state: this.state }, (key, value) => {\n        // remove blobClient from serialized state since a client can't be hydrated from this info.\n        if (key === \"blobClient\") {\n            return undefined;\n        }\n        return value;\n    });\n};\n/**\n * Creates a poll operation given the provided state.\n * @hidden\n */\nfunction makeBlobBeginCopyFromURLPollOperation(state) {\n    return {\n        state: Object.assign({}, state),\n        cancel,\n        toString,\n        update\n    };\n}\n//# sourceMappingURL=BlobStartCopyFromUrlPoller.js.map"]},"metadata":{},"sourceType":"module"}