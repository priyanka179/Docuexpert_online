{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders } from \"@azure/core-http\";\nimport { HTTP_VERSION_1_1, HTTP_LINE_ENDING, HeaderConstants, HTTPURLConnection } from \"./utils/constants\";\nimport { getBodyAsText } from \"./BatchUtils\";\nimport { logger } from \"./log\";\nconst HTTP_HEADER_DELIMITER = \": \";\nconst SPACE_DELIMITER = \" \";\nconst NOT_FOUND = -1;\n/**\n * Util class for parsing batch response.\n */\n\nexport class BatchResponseParser {\n  constructor(batchResponse, subRequests) {\n    if (!batchResponse || !batchResponse.contentType) {\n      // In special case(reported), server may return invalid content-type which could not be parsed.\n      throw new RangeError(\"batchResponse is malformed or doesn't contain valid content-type.\");\n    }\n\n    if (!subRequests || subRequests.size === 0) {\n      // This should be prevent during coding.\n      throw new RangeError(\"Invalid state: subRequests is not provided or size is 0.\");\n    }\n\n    this.batchResponse = batchResponse;\n    this.subRequests = subRequests;\n    this.responseBatchBoundary = this.batchResponse.contentType.split(\"=\")[1];\n    this.perResponsePrefix = `--${this.responseBatchBoundary}${HTTP_LINE_ENDING}`;\n    this.batchResponseEnding = `--${this.responseBatchBoundary}--`;\n  } // For example of response, please refer to https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#response\n\n\n  parseBatchResponse() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // When logic reach here, suppose batch request has already succeeded with 202, so we can further parse\n      // sub request's response.\n      if (_this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED) {\n        throw new Error(`Invalid state: batch request failed with status: '${_this.batchResponse._response.status}'.`);\n      }\n\n      const responseBodyAsText = yield getBodyAsText(_this.batchResponse);\n      const subResponses = responseBodyAsText.split(_this.batchResponseEnding)[0] // string after ending is useless\n      .split(_this.perResponsePrefix).slice(1); // string before first response boundary is useless\n\n      const subResponseCount = subResponses.length; // Defensive coding in case of potential error parsing.\n      // Note: subResponseCount == 1 is special case where sub request is invalid.\n      // We try to prevent such cases through early validation, e.g. validate sub request count >= 1.\n      // While in unexpected sub request invalid case, we allow sub response to be parsed and return to user.\n\n      if (subResponseCount !== _this.subRequests.size && subResponseCount !== 1) {\n        throw new Error(\"Invalid state: sub responses' count is not equal to sub requests' count.\");\n      }\n\n      const deserializedSubResponses = new Array(subResponseCount);\n      let subResponsesSucceededCount = 0;\n      let subResponsesFailedCount = 0; // Parse sub subResponses.\n\n      for (let index = 0; index < subResponseCount; index++) {\n        const subResponse = subResponses[index];\n        const deserializedSubResponse = {};\n        deserializedSubResponse.headers = new HttpHeaders();\n        const responseLines = subResponse.split(`${HTTP_LINE_ENDING}`);\n        let subRespHeaderStartFound = false;\n        let subRespHeaderEndFound = false;\n        let subRespFailed = false;\n        let contentId = NOT_FOUND;\n\n        for (const responseLine of responseLines) {\n          if (!subRespHeaderStartFound) {\n            // Convention line to indicate content ID\n            if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {\n              contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);\n            } // Http version line with status code indicates the start of sub request's response.\n            // Example: HTTP/1.1 202 Accepted\n\n\n            if (responseLine.startsWith(HTTP_VERSION_1_1)) {\n              subRespHeaderStartFound = true;\n              const tokens = responseLine.split(SPACE_DELIMITER);\n              deserializedSubResponse.status = parseInt(tokens[1]);\n              deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);\n            }\n\n            continue; // Skip convention headers not specifically for sub request i.e. Content-Type: application/http and Content-ID: *\n          }\n\n          if (responseLine.trim() === \"\") {\n            // Sub response's header start line already found, and the first empty line indicates header end line found.\n            if (!subRespHeaderEndFound) {\n              subRespHeaderEndFound = true;\n            }\n\n            continue; // Skip empty line\n          } // Note: when code reach here, it indicates subRespHeaderStartFound == true\n\n\n          if (!subRespHeaderEndFound) {\n            if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {\n              // Defensive coding to prevent from missing valuable lines.\n              throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);\n            } // Parse headers of sub response.\n\n\n            const tokens = responseLine.split(HTTP_HEADER_DELIMITER);\n            deserializedSubResponse.headers.set(tokens[0], tokens[1]);\n\n            if (tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {\n              deserializedSubResponse.errorCode = tokens[1];\n              subRespFailed = true;\n            }\n          } else {\n            // Assemble body of sub response.\n            if (!deserializedSubResponse.bodyAsText) {\n              deserializedSubResponse.bodyAsText = \"\";\n            }\n\n            deserializedSubResponse.bodyAsText += responseLine;\n          }\n        } // Inner for end\n        // The response will contain the Content-ID header for each corresponding subrequest response to use for tracking.\n        // The Content-IDs are set to a valid index in the subrequests we sent. In the status code 202 path, we could expect it\n        // to be 1-1 mapping from the [0, subRequests.size) to the Content-IDs returned. If not, we simply don't return that\n        // unexpected subResponse in the parsed reponse and we can always look it up in the raw response for debugging purpose.\n\n\n        if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < _this.subRequests.size && deserializedSubResponses[contentId] === undefined) {\n          deserializedSubResponse._request = _this.subRequests.get(contentId);\n          deserializedSubResponses[contentId] = deserializedSubResponse;\n        } else {\n          logger.error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);\n        }\n\n        if (subRespFailed) {\n          subResponsesFailedCount++;\n        } else {\n          subResponsesSucceededCount++;\n        }\n      }\n\n      return {\n        subResponses: deserializedSubResponses,\n        subResponsesSucceededCount: subResponsesSucceededCount,\n        subResponsesFailedCount: subResponsesFailedCount\n      };\n    })();\n  }\n\n} //# sourceMappingURL=BatchResponseParser.js.map","map":{"version":3,"sources":["F:/statvalu/AR_DocuExpert_Test/node_modules/@azure/storage-blob/dist-esm/storage-blob/src/BatchResponseParser.js"],"names":["HttpHeaders","HTTP_VERSION_1_1","HTTP_LINE_ENDING","HeaderConstants","HTTPURLConnection","getBodyAsText","logger","HTTP_HEADER_DELIMITER","SPACE_DELIMITER","NOT_FOUND","BatchResponseParser","constructor","batchResponse","subRequests","contentType","RangeError","size","responseBatchBoundary","split","perResponsePrefix","batchResponseEnding","parseBatchResponse","_response","status","HTTP_ACCEPTED","Error","responseBodyAsText","subResponses","slice","subResponseCount","length","deserializedSubResponses","Array","subResponsesSucceededCount","subResponsesFailedCount","index","subResponse","deserializedSubResponse","headers","responseLines","subRespHeaderStartFound","subRespHeaderEndFound","subRespFailed","contentId","responseLine","startsWith","CONTENT_ID","parseInt","tokens","statusMessage","join","trim","indexOf","set","X_MS_ERROR_CODE","errorCode","bodyAsText","Number","isInteger","undefined","_request","get","error"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders } from \"@azure/core-http\";\nimport { HTTP_VERSION_1_1, HTTP_LINE_ENDING, HeaderConstants, HTTPURLConnection } from \"./utils/constants\";\nimport { getBodyAsText } from \"./BatchUtils\";\nimport { logger } from \"./log\";\nconst HTTP_HEADER_DELIMITER = \": \";\nconst SPACE_DELIMITER = \" \";\nconst NOT_FOUND = -1;\n/**\n * Util class for parsing batch response.\n */\nexport class BatchResponseParser {\n    constructor(batchResponse, subRequests) {\n        if (!batchResponse || !batchResponse.contentType) {\n            // In special case(reported), server may return invalid content-type which could not be parsed.\n            throw new RangeError(\"batchResponse is malformed or doesn't contain valid content-type.\");\n        }\n        if (!subRequests || subRequests.size === 0) {\n            // This should be prevent during coding.\n            throw new RangeError(\"Invalid state: subRequests is not provided or size is 0.\");\n        }\n        this.batchResponse = batchResponse;\n        this.subRequests = subRequests;\n        this.responseBatchBoundary = this.batchResponse.contentType.split(\"=\")[1];\n        this.perResponsePrefix = `--${this.responseBatchBoundary}${HTTP_LINE_ENDING}`;\n        this.batchResponseEnding = `--${this.responseBatchBoundary}--`;\n    }\n    // For example of response, please refer to https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#response\n    async parseBatchResponse() {\n        // When logic reach here, suppose batch request has already succeeded with 202, so we can further parse\n        // sub request's response.\n        if (this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED) {\n            throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);\n        }\n        const responseBodyAsText = await getBodyAsText(this.batchResponse);\n        const subResponses = responseBodyAsText\n            .split(this.batchResponseEnding)[0] // string after ending is useless\n            .split(this.perResponsePrefix)\n            .slice(1); // string before first response boundary is useless\n        const subResponseCount = subResponses.length;\n        // Defensive coding in case of potential error parsing.\n        // Note: subResponseCount == 1 is special case where sub request is invalid.\n        // We try to prevent such cases through early validation, e.g. validate sub request count >= 1.\n        // While in unexpected sub request invalid case, we allow sub response to be parsed and return to user.\n        if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {\n            throw new Error(\"Invalid state: sub responses' count is not equal to sub requests' count.\");\n        }\n        const deserializedSubResponses = new Array(subResponseCount);\n        let subResponsesSucceededCount = 0;\n        let subResponsesFailedCount = 0;\n        // Parse sub subResponses.\n        for (let index = 0; index < subResponseCount; index++) {\n            const subResponse = subResponses[index];\n            const deserializedSubResponse = {};\n            deserializedSubResponse.headers = new HttpHeaders();\n            const responseLines = subResponse.split(`${HTTP_LINE_ENDING}`);\n            let subRespHeaderStartFound = false;\n            let subRespHeaderEndFound = false;\n            let subRespFailed = false;\n            let contentId = NOT_FOUND;\n            for (const responseLine of responseLines) {\n                if (!subRespHeaderStartFound) {\n                    // Convention line to indicate content ID\n                    if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {\n                        contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);\n                    }\n                    // Http version line with status code indicates the start of sub request's response.\n                    // Example: HTTP/1.1 202 Accepted\n                    if (responseLine.startsWith(HTTP_VERSION_1_1)) {\n                        subRespHeaderStartFound = true;\n                        const tokens = responseLine.split(SPACE_DELIMITER);\n                        deserializedSubResponse.status = parseInt(tokens[1]);\n                        deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);\n                    }\n                    continue; // Skip convention headers not specifically for sub request i.e. Content-Type: application/http and Content-ID: *\n                }\n                if (responseLine.trim() === \"\") {\n                    // Sub response's header start line already found, and the first empty line indicates header end line found.\n                    if (!subRespHeaderEndFound) {\n                        subRespHeaderEndFound = true;\n                    }\n                    continue; // Skip empty line\n                }\n                // Note: when code reach here, it indicates subRespHeaderStartFound == true\n                if (!subRespHeaderEndFound) {\n                    if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {\n                        // Defensive coding to prevent from missing valuable lines.\n                        throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);\n                    }\n                    // Parse headers of sub response.\n                    const tokens = responseLine.split(HTTP_HEADER_DELIMITER);\n                    deserializedSubResponse.headers.set(tokens[0], tokens[1]);\n                    if (tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {\n                        deserializedSubResponse.errorCode = tokens[1];\n                        subRespFailed = true;\n                    }\n                }\n                else {\n                    // Assemble body of sub response.\n                    if (!deserializedSubResponse.bodyAsText) {\n                        deserializedSubResponse.bodyAsText = \"\";\n                    }\n                    deserializedSubResponse.bodyAsText += responseLine;\n                }\n            } // Inner for end\n            // The response will contain the Content-ID header for each corresponding subrequest response to use for tracking.\n            // The Content-IDs are set to a valid index in the subrequests we sent. In the status code 202 path, we could expect it\n            // to be 1-1 mapping from the [0, subRequests.size) to the Content-IDs returned. If not, we simply don't return that\n            // unexpected subResponse in the parsed reponse and we can always look it up in the raw response for debugging purpose.\n            if (contentId !== NOT_FOUND &&\n                Number.isInteger(contentId) &&\n                contentId >= 0 &&\n                contentId < this.subRequests.size &&\n                deserializedSubResponses[contentId] === undefined) {\n                deserializedSubResponse._request = this.subRequests.get(contentId);\n                deserializedSubResponses[contentId] = deserializedSubResponse;\n            }\n            else {\n                logger.error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);\n            }\n            if (subRespFailed) {\n                subResponsesFailedCount++;\n            }\n            else {\n                subResponsesSucceededCount++;\n            }\n        }\n        return {\n            subResponses: deserializedSubResponses,\n            subResponsesSucceededCount: subResponsesSucceededCount,\n            subResponsesFailedCount: subResponsesFailedCount\n        };\n    }\n}\n//# sourceMappingURL=BatchResponseParser.js.map"]},"metadata":{},"sourceType":"module"}