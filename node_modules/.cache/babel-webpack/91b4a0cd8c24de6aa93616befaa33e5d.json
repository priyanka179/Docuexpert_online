{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/project/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { URLBuilder } from \"@azure/core-http\";\nimport { ToBlobEndpointHostMappings, ToDfsEndpointHostMappings } from \"./utils/constants\";\nimport { base64encode } from \"./utils/utils.common\";\n/**\n * Get a blob endpoint URL from incoming blob or dfs endpoint URLs.\n * Only handle known host name pair patterns, add more patterns into ToBlobEndpointHostMappings in constants.ts.\n *\n * Expected input and outputs:\n * http://account.blob.core.windows.net     - http://account.blob.core.windows.net\n * http://account.dfs.core.windows.net      - http://account.blob.core.windows.net\n * http://127.0.0.1:10000                   - http://127.0.0.1:10000\n * http://account.blob.core.windows.net/abc - http://account.blob.core.windows.net/abc\n * http://account.dfs.core.windows.net/abc  - http://account.blob.core.windows.net/abc\n * http://127.0.0.1:10000/abc               - http://127.0.0.1:10000/abc\n *\n * @param url -\n */\n\nexport function toBlobEndpointUrl(url) {\n  const urlParsed = URLBuilder.parse(url);\n  let host = urlParsed.getHost();\n\n  if (host === undefined) {\n    throw RangeError(`toBlobEndpointUrl() parameter url ${url} doesn't include valid host.`);\n  }\n\n  for (const mapping of ToBlobEndpointHostMappings) {\n    if (host.includes(mapping[0])) {\n      host = host.replace(mapping[0], mapping[1]);\n      break;\n    }\n  }\n\n  urlParsed.setHost(host);\n  return urlParsed.toString();\n}\n/**\n * Get a dfs endpoint URL from incoming blob or dfs endpoint URLs.\n * Only handle known host name pair patterns, add more patterns into ToDfsEndpointHostMappings in constants.ts.\n *\n * Expected input and outputs:\n * http://account.blob.core.windows.net     - http://account.dfs.core.windows.net\n * http://account.dfs.core.windows.net      - http://account.dfs.core.windows.net\n * http://127.0.0.1:10000                   - http://127.0.0.1:10000\n * http://account.blob.core.windows.net/abc - http://account.dfs.core.windows.net/abc\n * http://account.dfs.core.windows.net/abc  - http://account.dfs.core.windows.net/abc\n * http://127.0.0.1:10000/abc               - http://127.0.0.1:10000/abc\n *\n * @param url -\n */\n\nexport function toDfsEndpointUrl(url) {\n  const urlParsed = URLBuilder.parse(url);\n  let host = urlParsed.getHost();\n\n  if (host === undefined) {\n    throw RangeError(`toDfsEndpointUrl() parameter url ${url} doesn't include valid host.`);\n  }\n\n  for (const mapping of ToDfsEndpointHostMappings) {\n    if (host.includes(mapping[0])) {\n      host = host.replace(mapping[0], mapping[1]);\n      break;\n    }\n  }\n\n  urlParsed.setHost(host);\n  return urlParsed.toString();\n}\n\nfunction toFileSystemAsyncIterableIterator(iter) {\n  return {\n    next() {\n      return _asyncToGenerator(function* () {\n        const rawResult = yield iter.next();\n\n        if (rawResult.value) {\n          rawResult.value.fileSystemItems = rawResult.value.containerItems.map(val => {\n            return Object.assign(Object.assign({}, val), {\n              versionId: val.version,\n              properties: Object.assign(Object.assign({}, val.properties), {\n                publicAccess: toPublicAccessType(val.properties.publicAccess)\n              })\n            });\n          });\n        }\n\n        return rawResult;\n      })();\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}\n\nexport function toFileSystemPagedAsyncIterableIterator(iter) {\n  return {\n    next() {\n      return _asyncToGenerator(function* () {\n        const rawResult = yield iter.next();\n        const result = rawResult;\n\n        if (result.value) {\n          result.value.properties.publicAccess = toPublicAccessType(rawResult.value.properties.publicAccess);\n          result.value.versionId = rawResult.value.version;\n        }\n\n        return result;\n      })();\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    byPage(settings = {}) {\n      return toFileSystemAsyncIterableIterator(iter.byPage(settings));\n    }\n\n  };\n}\nexport function toContainerPublicAccessType(publicAccessType) {\n  if (!publicAccessType) {\n    return undefined;\n  }\n\n  switch (publicAccessType) {\n    case \"filesystem\":\n      return \"container\";\n\n    case \"file\":\n      return \"blob\";\n\n    default:\n      throw TypeError(`toContainerPublicAccessType() parameter ${publicAccessType} is not recognized.`);\n  }\n}\nexport function toPublicAccessType(containerPublicAccessType) {\n  if (!containerPublicAccessType) {\n    return undefined;\n  }\n\n  switch (containerPublicAccessType) {\n    case \"container\":\n      return \"filesystem\";\n\n    case \"blob\":\n      return \"file\";\n\n    default:\n      throw TypeError(`toPublicAccessType() parameter ${containerPublicAccessType} is not recognized.`);\n  }\n}\nexport function toProperties(metadata) {\n  if (metadata === undefined) {\n    return undefined;\n  }\n\n  const properties = [];\n\n  for (const key in metadata) {\n    if (Object.prototype.hasOwnProperty.call(metadata, key)) {\n      const value = metadata[key];\n      properties.push(`${key}=${base64encode(value)}`);\n    }\n  }\n\n  return properties.join(\",\");\n}\nexport function toPathGetAccessControlResponse(response) {\n  return Object.assign(Object.assign({}, response), {\n    _response: response._response,\n    permissions: toPermissions(response.permissions),\n    acl: toAcl(response.acl)\n  });\n}\nexport function toRolePermissions(permissionsString, allowStickyBit = false) {\n  const error = new RangeError(`toRolePermissions() Invalid role permissions string ${permissionsString}`);\n\n  if (permissionsString.length !== 3) {\n    throw error;\n  }\n\n  permissionsString = permissionsString.toLowerCase();\n  let read = false;\n\n  if (permissionsString[0] === \"r\") {\n    read = true;\n  } else if (permissionsString[0] !== \"-\") {\n    throw error;\n  }\n\n  let write = false;\n\n  if (permissionsString[1] === \"w\") {\n    write = true;\n  } else if (permissionsString[1] !== \"-\") {\n    throw error;\n  }\n\n  let execute = false;\n\n  if (permissionsString[2] === \"x\") {\n    execute = true;\n  } else if (allowStickyBit) {\n    if (permissionsString[2] === \"t\") {\n      execute = true;\n    } else if (permissionsString[2] !== \"-\") {\n      throw error;\n    }\n  } else if (permissionsString[2] !== \"-\") {\n    throw error;\n  }\n\n  return {\n    read,\n    write,\n    execute\n  };\n}\nexport function toPermissions(permissionsString) {\n  if (permissionsString === undefined || permissionsString === \"\" || permissionsString === null) {\n    return undefined;\n  }\n\n  if (permissionsString.length !== 9 && permissionsString.length !== 10) {\n    throw RangeError(`toPermissions() Invalid permissions string ${permissionsString}`);\n  } // Case insensitive\n\n\n  permissionsString = permissionsString.toLowerCase();\n  let stickyBit = false;\n\n  if (permissionsString[8] === \"t\") {\n    stickyBit = true;\n  }\n\n  let extendedAcls = false;\n\n  if (permissionsString.length === 10) {\n    if (permissionsString[9] === \"+\") {\n      extendedAcls = true;\n    } else {\n      throw RangeError(`toPermissions() Invalid extendedAcls bit ${permissionsString[9]} in permissions string ${permissionsString}`);\n    }\n  }\n\n  const owner = toRolePermissions(permissionsString.substr(0, 3), false);\n  const group = toRolePermissions(permissionsString.substr(3, 3), false);\n  const other = toRolePermissions(permissionsString.substr(6, 3), true);\n  return {\n    owner,\n    group,\n    other,\n    stickyBit,\n    extendedAcls\n  };\n}\nexport function toAccessControlItem(aclItemString) {\n  const error = new RangeError(`toAccessControlItem() Parameter access control item string ${aclItemString} is not valid.`);\n\n  if (aclItemString === \"\") {\n    throw error;\n  }\n\n  aclItemString = aclItemString.toLowerCase();\n  const parts = aclItemString.split(\":\");\n\n  if (parts.length < 3 || parts.length > 4) {\n    throw error;\n  }\n\n  let defaultScope = false;\n  let index = 0;\n\n  if (parts.length === 4) {\n    if (parts[index] !== \"default\") {\n      throw error;\n    }\n\n    defaultScope = true;\n    index++;\n  }\n\n  const accessControlType = parts[index++];\n\n  if (accessControlType !== \"user\" && accessControlType !== \"group\" && accessControlType !== \"mask\" && accessControlType !== \"other\") {\n    throw error;\n  }\n\n  const entityId = parts[index++];\n  const permissions = toRolePermissions(parts[index++]);\n  return {\n    defaultScope,\n    accessControlType,\n    entityId,\n    permissions\n  };\n}\nexport function toRemoveAccessControlItem(aclItemString) {\n  const error = new RangeError(`toAccessControlItem() Parameter access control item string \"${aclItemString}\" is not valid.`);\n\n  if (aclItemString === \"\") {\n    throw error;\n  }\n\n  aclItemString = aclItemString.toLowerCase();\n  const parts = aclItemString.split(\":\");\n\n  if (parts.length < 1 || parts.length > 3) {\n    throw error;\n  }\n\n  if (parts.length === 3) {\n    if (parts[0] !== \"default\") {\n      throw error;\n    }\n  }\n\n  let defaultScope = false;\n  let index = 0;\n\n  if (parts[index] === \"default\") {\n    defaultScope = true;\n    index++;\n  }\n\n  const accessControlType = parts[index++];\n\n  if (accessControlType !== \"user\" && accessControlType !== \"group\" && accessControlType !== \"mask\" && accessControlType !== \"other\") {\n    throw error;\n  }\n\n  const entityId = parts[index++];\n  return {\n    defaultScope,\n    accessControlType,\n    entityId\n  };\n}\nexport function toAcl(aclString) {\n  if (aclString === undefined || aclString === \"\" || aclString === null) {\n    return [];\n  }\n\n  const acls = [];\n  const aclParts = aclString.split(\",\");\n\n  for (const aclPart of aclParts) {\n    acls.push(toAccessControlItem(aclPart));\n  }\n\n  return acls;\n}\nexport function toRemoveAcl(aclString) {\n  if (aclString === undefined || aclString === \"\" || aclString === null) {\n    return [];\n  }\n\n  const acls = [];\n  const aclParts = aclString.split(\",\");\n\n  for (const aclPart of aclParts) {\n    acls.push(toRemoveAccessControlItem(aclPart));\n  }\n\n  return acls;\n}\nexport function toAccessControlItemString(item) {\n  const entityIdString = item.entityId !== undefined ? `:${item.entityId}` : \"\";\n  const permissionsString = item.permissions !== undefined ? `:${toRolePermissionsString(item.permissions)}` : \"\";\n  return `${item.defaultScope ? \"default:\" : \"\"}${item.accessControlType}${entityIdString}${permissionsString}`;\n}\nexport function toAclString(acl) {\n  return acl.map(toAccessControlItemString).join(\",\");\n}\nexport function toRolePermissionsString(p, stickyBit = false) {\n  return `${p.read ? \"r\" : \"-\"}${p.write ? \"w\" : \"-\"}${stickyBit ? \"t\" : p.execute ? \"x\" : \"-\"}`;\n}\nexport function toPermissionsString(permissions) {\n  return `${toRolePermissionsString(permissions.owner)}${toRolePermissionsString(permissions.group)}${toRolePermissionsString(permissions.other, permissions.stickyBit)}${permissions.extendedAcls ? \"+\" : \"\"}`;\n}\nexport function toAccessControlChangeFailureArray(aclFailedEntries = []) {\n  return aclFailedEntries.map(aclFailedEntry => {\n    return {\n      name: aclFailedEntry.name || \"\",\n      isDirectory: (aclFailedEntry.type || \"\").toLowerCase() === \"directory\",\n      message: aclFailedEntry.errorMessage || \"\"\n    };\n  });\n} //# sourceMappingURL=transforms.js.map","map":{"version":3,"sources":["F:/statvalu/project/AR_DocuExpert_Test/node_modules/@azure/storage-file-datalake/dist-esm/storage-file-datalake/src/transforms.js"],"names":["URLBuilder","ToBlobEndpointHostMappings","ToDfsEndpointHostMappings","base64encode","toBlobEndpointUrl","url","urlParsed","parse","host","getHost","undefined","RangeError","mapping","includes","replace","setHost","toString","toDfsEndpointUrl","toFileSystemAsyncIterableIterator","iter","next","rawResult","value","fileSystemItems","containerItems","map","val","Object","assign","versionId","version","properties","publicAccess","toPublicAccessType","Symbol","asyncIterator","toFileSystemPagedAsyncIterableIterator","result","byPage","settings","toContainerPublicAccessType","publicAccessType","TypeError","containerPublicAccessType","toProperties","metadata","key","prototype","hasOwnProperty","call","push","join","toPathGetAccessControlResponse","response","_response","permissions","toPermissions","acl","toAcl","toRolePermissions","permissionsString","allowStickyBit","error","length","toLowerCase","read","write","execute","stickyBit","extendedAcls","owner","substr","group","other","toAccessControlItem","aclItemString","parts","split","defaultScope","index","accessControlType","entityId","toRemoveAccessControlItem","aclString","acls","aclParts","aclPart","toRemoveAcl","toAccessControlItemString","item","entityIdString","toRolePermissionsString","toAclString","p","toPermissionsString","toAccessControlChangeFailureArray","aclFailedEntries","aclFailedEntry","name","isDirectory","type","message","errorMessage"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { URLBuilder } from \"@azure/core-http\";\nimport { ToBlobEndpointHostMappings, ToDfsEndpointHostMappings } from \"./utils/constants\";\nimport { base64encode } from \"./utils/utils.common\";\n/**\n * Get a blob endpoint URL from incoming blob or dfs endpoint URLs.\n * Only handle known host name pair patterns, add more patterns into ToBlobEndpointHostMappings in constants.ts.\n *\n * Expected input and outputs:\n * http://account.blob.core.windows.net     - http://account.blob.core.windows.net\n * http://account.dfs.core.windows.net      - http://account.blob.core.windows.net\n * http://127.0.0.1:10000                   - http://127.0.0.1:10000\n * http://account.blob.core.windows.net/abc - http://account.blob.core.windows.net/abc\n * http://account.dfs.core.windows.net/abc  - http://account.blob.core.windows.net/abc\n * http://127.0.0.1:10000/abc               - http://127.0.0.1:10000/abc\n *\n * @param url -\n */\nexport function toBlobEndpointUrl(url) {\n    const urlParsed = URLBuilder.parse(url);\n    let host = urlParsed.getHost();\n    if (host === undefined) {\n        throw RangeError(`toBlobEndpointUrl() parameter url ${url} doesn't include valid host.`);\n    }\n    for (const mapping of ToBlobEndpointHostMappings) {\n        if (host.includes(mapping[0])) {\n            host = host.replace(mapping[0], mapping[1]);\n            break;\n        }\n    }\n    urlParsed.setHost(host);\n    return urlParsed.toString();\n}\n/**\n * Get a dfs endpoint URL from incoming blob or dfs endpoint URLs.\n * Only handle known host name pair patterns, add more patterns into ToDfsEndpointHostMappings in constants.ts.\n *\n * Expected input and outputs:\n * http://account.blob.core.windows.net     - http://account.dfs.core.windows.net\n * http://account.dfs.core.windows.net      - http://account.dfs.core.windows.net\n * http://127.0.0.1:10000                   - http://127.0.0.1:10000\n * http://account.blob.core.windows.net/abc - http://account.dfs.core.windows.net/abc\n * http://account.dfs.core.windows.net/abc  - http://account.dfs.core.windows.net/abc\n * http://127.0.0.1:10000/abc               - http://127.0.0.1:10000/abc\n *\n * @param url -\n */\nexport function toDfsEndpointUrl(url) {\n    const urlParsed = URLBuilder.parse(url);\n    let host = urlParsed.getHost();\n    if (host === undefined) {\n        throw RangeError(`toDfsEndpointUrl() parameter url ${url} doesn't include valid host.`);\n    }\n    for (const mapping of ToDfsEndpointHostMappings) {\n        if (host.includes(mapping[0])) {\n            host = host.replace(mapping[0], mapping[1]);\n            break;\n        }\n    }\n    urlParsed.setHost(host);\n    return urlParsed.toString();\n}\nfunction toFileSystemAsyncIterableIterator(iter) {\n    return {\n        async next() {\n            const rawResult = await iter.next();\n            if (rawResult.value) {\n                rawResult.value.fileSystemItems = rawResult.value.containerItems.map((val) => {\n                    return Object.assign(Object.assign({}, val), { versionId: val.version, properties: Object.assign(Object.assign({}, val.properties), { publicAccess: toPublicAccessType(val.properties.publicAccess) }) });\n                });\n            }\n            return rawResult;\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        }\n    };\n}\nexport function toFileSystemPagedAsyncIterableIterator(iter) {\n    return {\n        async next() {\n            const rawResult = await iter.next();\n            const result = rawResult;\n            if (result.value) {\n                result.value.properties.publicAccess = toPublicAccessType(rawResult.value.properties.publicAccess);\n                result.value.versionId = rawResult.value.version;\n            }\n            return result;\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n        byPage(settings = {}) {\n            return toFileSystemAsyncIterableIterator(iter.byPage(settings));\n        }\n    };\n}\nexport function toContainerPublicAccessType(publicAccessType) {\n    if (!publicAccessType) {\n        return undefined;\n    }\n    switch (publicAccessType) {\n        case \"filesystem\":\n            return \"container\";\n        case \"file\":\n            return \"blob\";\n        default:\n            throw TypeError(`toContainerPublicAccessType() parameter ${publicAccessType} is not recognized.`);\n    }\n}\nexport function toPublicAccessType(containerPublicAccessType) {\n    if (!containerPublicAccessType) {\n        return undefined;\n    }\n    switch (containerPublicAccessType) {\n        case \"container\":\n            return \"filesystem\";\n        case \"blob\":\n            return \"file\";\n        default:\n            throw TypeError(`toPublicAccessType() parameter ${containerPublicAccessType} is not recognized.`);\n    }\n}\nexport function toProperties(metadata) {\n    if (metadata === undefined) {\n        return undefined;\n    }\n    const properties = [];\n    for (const key in metadata) {\n        if (Object.prototype.hasOwnProperty.call(metadata, key)) {\n            const value = metadata[key];\n            properties.push(`${key}=${base64encode(value)}`);\n        }\n    }\n    return properties.join(\",\");\n}\nexport function toPathGetAccessControlResponse(response) {\n    return Object.assign(Object.assign({}, response), { _response: response._response, permissions: toPermissions(response.permissions), acl: toAcl(response.acl) });\n}\nexport function toRolePermissions(permissionsString, allowStickyBit = false) {\n    const error = new RangeError(`toRolePermissions() Invalid role permissions string ${permissionsString}`);\n    if (permissionsString.length !== 3) {\n        throw error;\n    }\n    permissionsString = permissionsString.toLowerCase();\n    let read = false;\n    if (permissionsString[0] === \"r\") {\n        read = true;\n    }\n    else if (permissionsString[0] !== \"-\") {\n        throw error;\n    }\n    let write = false;\n    if (permissionsString[1] === \"w\") {\n        write = true;\n    }\n    else if (permissionsString[1] !== \"-\") {\n        throw error;\n    }\n    let execute = false;\n    if (permissionsString[2] === \"x\") {\n        execute = true;\n    }\n    else if (allowStickyBit) {\n        if (permissionsString[2] === \"t\") {\n            execute = true;\n        }\n        else if (permissionsString[2] !== \"-\") {\n            throw error;\n        }\n    }\n    else if (permissionsString[2] !== \"-\") {\n        throw error;\n    }\n    return { read, write, execute };\n}\nexport function toPermissions(permissionsString) {\n    if (permissionsString === undefined || permissionsString === \"\" || permissionsString === null) {\n        return undefined;\n    }\n    if (permissionsString.length !== 9 && permissionsString.length !== 10) {\n        throw RangeError(`toPermissions() Invalid permissions string ${permissionsString}`);\n    }\n    // Case insensitive\n    permissionsString = permissionsString.toLowerCase();\n    let stickyBit = false;\n    if (permissionsString[8] === \"t\") {\n        stickyBit = true;\n    }\n    let extendedAcls = false;\n    if (permissionsString.length === 10) {\n        if (permissionsString[9] === \"+\") {\n            extendedAcls = true;\n        }\n        else {\n            throw RangeError(`toPermissions() Invalid extendedAcls bit ${permissionsString[9]} in permissions string ${permissionsString}`);\n        }\n    }\n    const owner = toRolePermissions(permissionsString.substr(0, 3), false);\n    const group = toRolePermissions(permissionsString.substr(3, 3), false);\n    const other = toRolePermissions(permissionsString.substr(6, 3), true);\n    return {\n        owner,\n        group,\n        other,\n        stickyBit,\n        extendedAcls\n    };\n}\nexport function toAccessControlItem(aclItemString) {\n    const error = new RangeError(`toAccessControlItem() Parameter access control item string ${aclItemString} is not valid.`);\n    if (aclItemString === \"\") {\n        throw error;\n    }\n    aclItemString = aclItemString.toLowerCase();\n    const parts = aclItemString.split(\":\");\n    if (parts.length < 3 || parts.length > 4) {\n        throw error;\n    }\n    let defaultScope = false;\n    let index = 0;\n    if (parts.length === 4) {\n        if (parts[index] !== \"default\") {\n            throw error;\n        }\n        defaultScope = true;\n        index++;\n    }\n    const accessControlType = parts[index++];\n    if (accessControlType !== \"user\" &&\n        accessControlType !== \"group\" &&\n        accessControlType !== \"mask\" &&\n        accessControlType !== \"other\") {\n        throw error;\n    }\n    const entityId = parts[index++];\n    const permissions = toRolePermissions(parts[index++]);\n    return {\n        defaultScope,\n        accessControlType,\n        entityId,\n        permissions\n    };\n}\nexport function toRemoveAccessControlItem(aclItemString) {\n    const error = new RangeError(`toAccessControlItem() Parameter access control item string \"${aclItemString}\" is not valid.`);\n    if (aclItemString === \"\") {\n        throw error;\n    }\n    aclItemString = aclItemString.toLowerCase();\n    const parts = aclItemString.split(\":\");\n    if (parts.length < 1 || parts.length > 3) {\n        throw error;\n    }\n    if (parts.length === 3) {\n        if (parts[0] !== \"default\") {\n            throw error;\n        }\n    }\n    let defaultScope = false;\n    let index = 0;\n    if (parts[index] === \"default\") {\n        defaultScope = true;\n        index++;\n    }\n    const accessControlType = parts[index++];\n    if (accessControlType !== \"user\" &&\n        accessControlType !== \"group\" &&\n        accessControlType !== \"mask\" &&\n        accessControlType !== \"other\") {\n        throw error;\n    }\n    const entityId = parts[index++];\n    return {\n        defaultScope,\n        accessControlType,\n        entityId\n    };\n}\nexport function toAcl(aclString) {\n    if (aclString === undefined || aclString === \"\" || aclString === null) {\n        return [];\n    }\n    const acls = [];\n    const aclParts = aclString.split(\",\");\n    for (const aclPart of aclParts) {\n        acls.push(toAccessControlItem(aclPart));\n    }\n    return acls;\n}\nexport function toRemoveAcl(aclString) {\n    if (aclString === undefined || aclString === \"\" || aclString === null) {\n        return [];\n    }\n    const acls = [];\n    const aclParts = aclString.split(\",\");\n    for (const aclPart of aclParts) {\n        acls.push(toRemoveAccessControlItem(aclPart));\n    }\n    return acls;\n}\nexport function toAccessControlItemString(item) {\n    const entityIdString = item.entityId !== undefined ? `:${item.entityId}` : \"\";\n    const permissionsString = item.permissions !== undefined ? `:${toRolePermissionsString(item.permissions)}` : \"\";\n    return `${item.defaultScope ? \"default:\" : \"\"}${item.accessControlType}${entityIdString}${permissionsString}`;\n}\nexport function toAclString(acl) {\n    return acl.map(toAccessControlItemString).join(\",\");\n}\nexport function toRolePermissionsString(p, stickyBit = false) {\n    return `${p.read ? \"r\" : \"-\"}${p.write ? \"w\" : \"-\"}${stickyBit ? \"t\" : p.execute ? \"x\" : \"-\"}`;\n}\nexport function toPermissionsString(permissions) {\n    return `${toRolePermissionsString(permissions.owner)}${toRolePermissionsString(permissions.group)}${toRolePermissionsString(permissions.other, permissions.stickyBit)}${permissions.extendedAcls ? \"+\" : \"\"}`;\n}\nexport function toAccessControlChangeFailureArray(aclFailedEntries = []) {\n    return aclFailedEntries.map((aclFailedEntry) => {\n        return {\n            name: aclFailedEntry.name || \"\",\n            isDirectory: (aclFailedEntry.type || \"\").toLowerCase() === \"directory\",\n            message: aclFailedEntry.errorMessage || \"\"\n        };\n    });\n}\n//# sourceMappingURL=transforms.js.map"]},"metadata":{},"sourceType":"module"}