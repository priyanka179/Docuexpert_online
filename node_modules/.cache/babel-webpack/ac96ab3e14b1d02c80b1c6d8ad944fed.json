{"ast":null,"code":"import _asyncToGenerator from \"F:/statvalu/project/AR_DocuExpert_Test/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { DEFAULT_CLIENT_MAX_RETRY_INTERVAL, DEFAULT_CLIENT_RETRY_COUNT, DEFAULT_CLIENT_RETRY_INTERVAL, isNumber, updateRetryData, shouldRetry } from \"../util/exponentialBackoffStrategy\";\nimport { RestError } from \"../restError\";\nimport { logger } from \"../log\";\nimport { Constants } from \"../util/constants\";\nimport { delay } from \"../util/delay\";\nexport function exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {\n  return {\n    create: (nextPolicy, options) => {\n      return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval);\n    }\n  };\n}\n/**\n * Describes the Retry Mode type. Currently supporting only Exponential.\n */\n\nexport var RetryMode;\n\n(function (RetryMode) {\n  RetryMode[RetryMode[\"Exponential\"] = 0] = \"Exponential\";\n})(RetryMode || (RetryMode = {}));\n\nexport const DefaultRetryOptions = {\n  maxRetries: DEFAULT_CLIENT_RETRY_COUNT,\n  retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,\n  maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL\n};\n/**\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\n\nexport class ExponentialRetryPolicy extends BaseRequestPolicy {\n  /**\n   * @param nextPolicy - The next RequestPolicy in the pipeline chain.\n   * @param options - The options for this RequestPolicy.\n   * @param retryCount - The client retry count.\n   * @param retryInterval - The client retry interval, in milliseconds.\n   * @param minRetryInterval - The minimum retry interval, in milliseconds.\n   * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n   */\n  constructor(nextPolicy, options, retryCount, retryInterval, maxRetryInterval) {\n    super(nextPolicy, options);\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  sendRequest(request) {\n    return this._nextPolicy.sendRequest(request.clone()).then(response => retry(this, request, response)).catch(error => retry(this, request, error.response, undefined, error));\n  }\n\n}\n\nfunction retry(_x, _x2, _x3, _x4, _x5) {\n  return _retry.apply(this, arguments);\n} //# sourceMappingURL=exponentialRetryPolicy.js.map\n\n\nfunction _retry() {\n  _retry = _asyncToGenerator(function* (policy, request, response, retryData, requestError) {\n    function shouldPolicyRetry(responseParam) {\n      const statusCode = responseParam === null || responseParam === void 0 ? void 0 : responseParam.status;\n\n      if (statusCode === 503 && (response === null || response === void 0 ? void 0 : response.headers.get(Constants.HeaderConstants.RETRY_AFTER))) {\n        return false;\n      }\n\n      if (statusCode === undefined || statusCode < 500 && statusCode !== 408 || statusCode === 501 || statusCode === 505) {\n        return false;\n      }\n\n      return true;\n    }\n\n    retryData = updateRetryData({\n      retryInterval: policy.retryInterval,\n      minRetryInterval: 0,\n      maxRetryInterval: policy.maxRetryInterval\n    }, retryData, requestError);\n    const isAborted = request.abortSignal && request.abortSignal.aborted;\n\n    if (!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response)) {\n      logger.info(`Retrying request in ${retryData.retryInterval}`);\n\n      try {\n        yield delay(retryData.retryInterval);\n        const res = yield policy._nextPolicy.sendRequest(request.clone());\n        return retry(policy, request, res, retryData);\n      } catch (err) {\n        return retry(policy, request, response, retryData, err);\n      }\n    } else if (isAborted || requestError || !response) {\n      // If the operation failed in the end, return all errors instead of just the last one\n      const err = retryData.error || new RestError(\"Failed to send the request.\", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);\n      throw err;\n    } else {\n      return response;\n    }\n  });\n  return _retry.apply(this, arguments);\n}","map":{"version":3,"sources":["F:/statvalu/project/AR_DocuExpert_Test/node_modules/@azure/core-http/dist-esm/src/policies/exponentialRetryPolicy.js"],"names":["BaseRequestPolicy","DEFAULT_CLIENT_MAX_RETRY_INTERVAL","DEFAULT_CLIENT_RETRY_COUNT","DEFAULT_CLIENT_RETRY_INTERVAL","isNumber","updateRetryData","shouldRetry","RestError","logger","Constants","delay","exponentialRetryPolicy","retryCount","retryInterval","maxRetryInterval","create","nextPolicy","options","ExponentialRetryPolicy","RetryMode","DefaultRetryOptions","maxRetries","retryDelayInMs","maxRetryDelayInMs","constructor","sendRequest","request","_nextPolicy","clone","then","response","retry","catch","error","undefined","policy","retryData","requestError","shouldPolicyRetry","responseParam","statusCode","status","headers","get","HeaderConstants","RETRY_AFTER","minRetryInterval","isAborted","abortSignal","aborted","info","res","err","REQUEST_SEND_ERROR"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { DEFAULT_CLIENT_MAX_RETRY_INTERVAL, DEFAULT_CLIENT_RETRY_COUNT, DEFAULT_CLIENT_RETRY_INTERVAL, isNumber, updateRetryData, shouldRetry } from \"../util/exponentialBackoffStrategy\";\nimport { RestError } from \"../restError\";\nimport { logger } from \"../log\";\nimport { Constants } from \"../util/constants\";\nimport { delay } from \"../util/delay\";\nexport function exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {\n    return {\n        create: (nextPolicy, options) => {\n            return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval);\n        }\n    };\n}\n/**\n * Describes the Retry Mode type. Currently supporting only Exponential.\n */\nexport var RetryMode;\n(function (RetryMode) {\n    RetryMode[RetryMode[\"Exponential\"] = 0] = \"Exponential\";\n})(RetryMode || (RetryMode = {}));\nexport const DefaultRetryOptions = {\n    maxRetries: DEFAULT_CLIENT_RETRY_COUNT,\n    retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,\n    maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL\n};\n/**\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\nexport class ExponentialRetryPolicy extends BaseRequestPolicy {\n    /**\n     * @param nextPolicy - The next RequestPolicy in the pipeline chain.\n     * @param options - The options for this RequestPolicy.\n     * @param retryCount - The client retry count.\n     * @param retryInterval - The client retry interval, in milliseconds.\n     * @param minRetryInterval - The minimum retry interval, in milliseconds.\n     * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n     */\n    constructor(nextPolicy, options, retryCount, retryInterval, maxRetryInterval) {\n        super(nextPolicy, options);\n        this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n        this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n        this.maxRetryInterval = isNumber(maxRetryInterval)\n            ? maxRetryInterval\n            : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n    }\n    sendRequest(request) {\n        return this._nextPolicy\n            .sendRequest(request.clone())\n            .then((response) => retry(this, request, response))\n            .catch((error) => retry(this, request, error.response, undefined, error));\n    }\n}\nasync function retry(policy, request, response, retryData, requestError) {\n    function shouldPolicyRetry(responseParam) {\n        const statusCode = responseParam === null || responseParam === void 0 ? void 0 : responseParam.status;\n        if (statusCode === 503 && (response === null || response === void 0 ? void 0 : response.headers.get(Constants.HeaderConstants.RETRY_AFTER))) {\n            return false;\n        }\n        if (statusCode === undefined ||\n            (statusCode < 500 && statusCode !== 408) ||\n            statusCode === 501 ||\n            statusCode === 505) {\n            return false;\n        }\n        return true;\n    }\n    retryData = updateRetryData({\n        retryInterval: policy.retryInterval,\n        minRetryInterval: 0,\n        maxRetryInterval: policy.maxRetryInterval\n    }, retryData, requestError);\n    const isAborted = request.abortSignal && request.abortSignal.aborted;\n    if (!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response)) {\n        logger.info(`Retrying request in ${retryData.retryInterval}`);\n        try {\n            await delay(retryData.retryInterval);\n            const res = await policy._nextPolicy.sendRequest(request.clone());\n            return retry(policy, request, res, retryData);\n        }\n        catch (err) {\n            return retry(policy, request, response, retryData, err);\n        }\n    }\n    else if (isAborted || requestError || !response) {\n        // If the operation failed in the end, return all errors instead of just the last one\n        const err = retryData.error ||\n            new RestError(\"Failed to send the request.\", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);\n        throw err;\n    }\n    else {\n        return response;\n    }\n}\n//# sourceMappingURL=exponentialRetryPolicy.js.map"]},"metadata":{},"sourceType":"module"}